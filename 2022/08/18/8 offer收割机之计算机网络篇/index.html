<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>军哥面试题-8.计算机网络篇 | By Wang</title><meta name="keywords" content="面试题"><meta name="author" content="Tiamo"><meta name="copyright" content="Tiamo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="军哥面试题-8.计算机网络篇"><meta name="application-name" content="军哥面试题-8.计算机网络篇"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="军哥面试题-8.计算机网络篇"><meta property="og:url" content="https://blog.xiaoadai.com/2022/08/18/8%20offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87/index.html"><meta property="og:site_name" content="By Wang"><meta property="og:description" content="🥧军哥面试题-8.计算机网络篇"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://source.fomal.cc/img/default_cover_8.webp"><meta property="article:author" content="Tiamo"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://source.fomal.cc/img/default_cover_8.webp"><meta name="description" content="🥧军哥面试题-8.计算机网络篇"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.xiaoadai.com/2022/08/18/8%20offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87/"><link rel="preconnect" href="//npm.elemecdn.com"/><link rel="preconnect" href="//npm.onmicrosoft.cn"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"Tiamo","mode":"tianli","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":6,"basicWordCount":1999,"key":"207d044fe5f22c1dc77b","Referer":"https://blog.xiaoadai.com/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://comment.xiaoadai.com/',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Tiamo","link":"链接: ","source":"来源: By Wang","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'By Wang',
  title: '军哥面试题-8.计算机网络篇',
  postAI: '',
  pageFillDescription: '一、HTTP协议, 1. GET和POST的请求的区别, 2. POST和PUT请求的区别, 3. 常见的HTTP请求头和响应头, 4. HTTP状态码304是多好还是少好, 5. 常见的HTTP请求方法, 6. OPTIONS请求方法及使用场景, 7. HTTP 1.0 和 HTTP 1.1 之间有哪些区别？, 8. HTTP 1.1 和 HTTP 2.0 的区别, 9. HTTP和HTTPS协议的区别, 10. GET方法URL长度限制的原因, 11. 当在浏览器中输入 Google.com 并且按下回车之后发生了什么？, 12. 对keep-alive的理解, 13. 页面有多张图片HTTP是怎样的加载表现？, 14. HTTP2的头部压缩算法是怎样的？, 15. HTTP请求报文的是什么样的？, 16. HTTP响应报文的是什么样的？, 17. HTTP协议的优点和缺点, 18. 说一下HTTP 3.0, 19. HTTP协议的性能怎么样, 20. URL有哪些组成部分, 21. 与缓存相关的HTTP请求头有哪些, 二、HTTPS协议, 1. 什么是HTTPS协议？, 2. TLS/SSL的工作原理, （1）散列函数hash, （2）对称加密, （3）非对称加密, 3. 数字证书是什么？, 4. HTTPS通信（握手）过程, 5. HTTPS的特点, 6. HTTPS是如何保证安全的？, 三、HTTP状态码, 1. 2XX (Success 成功状态码), （1）200 OK, （2）204 No Content, （3）206 Partial Content, 2. 3XX (Redirection 重定向状态码), （1）301 Moved Permanently, （2）302 Found, （3）303 See Other, （4）304 Not Modified, （5）307 Temporary Redirect, 3. 4XX (Client Error 客户端错误状态码), （1）400 Bad Request, （2）401 Unauthorized, （3）403 Forbidden, （4）404 Not Found, （5）405 Method Not Allowed, 4. 5XX (Server Error 服务器错误状态码), （1）500 Internal Server Error, （2）502 Bad Gateway, （3）503 Service Unavailable, （4）504 Gateway Timeout, 5. 总结, 6. 同样是重定向307303302的区别？, 四、DNS协议介绍, 1. DNS 协议是什么, 2. DNS同时使用TCP和UDP协议？, 3. DNS完整的查询过程, 4. 迭代查询与递归查询, 5. DNS 记录和报文, 五、网络模型, 1. OSI七层模型, （1）应用层, （2）表示层, （3）会话层, （4）传输层, （5）网络层, （6）数据链路层, （7）物理层, 2. TCP/IP五层协议, 六、TCP与UDP, 1. TCP 和 UDP的概念及特点, 2. TCP和UDP的区别, 3. TCP和UDP的使用场景, 4. UDP协议为什么不可靠？, 5. TCP的重传机制, 6. TCP的拥塞控制机制, 7. TCP的流量控制机制, 8. TCP的可靠传输机制, 9. TCP的三次握手和四次挥手, （1）三次握手, （2）四次挥手, 10. TCP粘包是怎么回事如何处理**?**, 11. 为什么udp不会粘包？, 七、WebSocket, 1. 对 WebSocket 的理解, 2. 即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？一协议和的请求的区别和是请求的两种方法其区别如下应用场景请求是一个幂等的请求一般请求用于对服务器资源不会产生影响的场景比如说请求一个网页的资源而不是一个幂等的请求一般用于对服务器资源会产生影响的情景比如注册用户这一类的操作是否缓存因为两者应用场景不同浏览器一般会对请求缓存但很少对请求缓存发送的报文格式请求的报文中实体部分为空请求的报文中实体部分一般为向服务器发送的数据安全性请求可以将请求的参数放入中向服务器发送这样的做法相对于请求来说是不太安全的因为请求的会被保留在历史记录中请求长度浏览器由于对长度的限制所以会影响请求发送数据时的长度这个限制是浏览器规定的并不是规定的参数类型的参数传递支持更多的数据类型和请求的区别请求是向服务器端发送数据从而修改数据的内容但是不会增加数据的种类等也就是说无论进行多少次操作其结果并没有不同可以理解为是更新数据请求是向服务器端发送数据该请求会改变数据的种类等资源它会创建新的内容可以理解为是创建数据常见的请求头和响应头常见的请求头浏览器能够处理的内容类型浏览器能够显示的字符集浏览器能够处理的压缩编码浏览器当前设置的语言浏览器与服务器之间连接的类型当前页面设置的任何发出请求的页面所在的域发出请求的页面的浏览器的用户代理字符串常见的响应头表示消息发送的时间时间的描述格式由定义服务器名称浏览器与服务器之间连接的类型控制缓存表示后面的文档属于什么类型常见的属性值有以下四种浏览器的原生表单如果不设置属性那么最终就会以方式提交数据该种方式提交的数据放在里面数据按照的方式进行编码和都进行了转码该种方式也是一个常见的提交方式通常表单上传文件时使用该种方式服务器消息主体是序列化后的字符串该种方式主要用来提交格式的数据状态码是多好还是少好服务器为了提高网站访问速度对之前访问的部分页面指定缓存机制当客户端在此对这些页面进行请求服务器会根据缓存内容判断页面与之前是否相同若相同便直接返回此时客户端调用缓存内容不必进行二次下载状态码不应该认为是一种错误而是对客户端有缓存情况下服务端的一种响应搜索引擎蜘蛛会更加青睐内容源更新频繁的网站通过特定时间内对网站抓取返回的状态码来调节对该网站的抓取频次若网站在一定时间内一直处于的状态那么蜘蛛可能会降低对网站的抓取次数相反若网站变化的频率非常之快每次抓取都能获取新内容那么日积月累的回访率也会提高产生较多状态码的原因页面更新周期长或不更新纯静态页面或强制生成静态状态码出现过多会造成以下问题网站快照停止收录减少权重下降常见的请求方法向服务器获取数据将实体提交到指定的资源通常会造成服务器资源的修改上传文件更新数据删除服务器上的对象获取报文首部与相比不返回报文主体部分询问支持的请求方法用来跨域请求要求在与代理服务器通信时建立隧道使用隧道进行通信回显服务器收到的请求主要于测试或诊断请求方法及使用场景是除了和之外的其中一种请求方法方法是用于请求获得由标识的资源在请求响应的通信过程中可以使用的功能选项通过这个方法客户端可以在采取具体资源请求之前决定对该资源采取何种必要措施或者了解服务器的性能该请求方法的响应不能缓存请求方法的主要用途有两个获取服务器支持的所有请求方法用来检查访问权限例如在进行跨域资源共享时对于复杂请求就是使用方法发送嗅探请求以判断是否有对指定资源的访问权限和之间有哪些区别和有以下区别连接方面默认使用非持久连接而默认使用持久连接通过使用持久连接来使多个请求复用同一个连接以此来避免使用非持久连接时每次需要建立连接的时延资源请求方面在中存在一些浪费带宽的现象例如客户端只是需要某个对象的一部分而服务器却将整个对象送过来了并且不支持断点续传功能则在请求头引入了头域它允许只请求资源的某个部分即返回码是这样就方便了开发者自由的选择以便于充分利用带宽和连接缓存方面在中主要使用里的来做为缓存判断的标准则引入了更多的缓存控制策略例如等更多可供选择的缓存头来控制缓存策略中新增了字段用来指定服务器的域名中认为每台服务器都绑定一个唯一的地址因此请求消息中的并没有传递主机名但随着虚拟主机技术的发展在一台物理服务器上可以存在多个虚拟主机并且它们共享一个地址因此有了字段这样就可以将请求发往到同一台服务器上的不同网站相对于还新增了很多请求方法如等和的区别二进制协议是一个二进制协议在版中报文的头信息必须是文本编码数据体可以是文本也可以是二进制则是一个彻底的二进制协议头信息和数据体都是二进制并且统称为帧可以分为头信息帧和数据帧帧的概念是它实现多路复用的基础多路复用实现了多路复用仍然复用连接但是在一个连接里客户端和服务器都可以同时发送多个请求或回应而且不用按照顺序一一发送这样就避免了队头堵塞的问题数据流使用了数据流的概念因为的数据包是不按顺序发送的同一个连接里面连续的数据包可能属于不同的请求因此必须要对数据包做标记指出它属于哪个请求将每个请求或回应的所有数据包称为一个数据流每个数据流都有一个独一无二的编号数据包发送时都必须标记数据流用来区分它属于哪个数据流头信息压缩实现了头信息压缩由于协议不带状态每次请求都必须附上所有信息所以请求的很多字段都是重复的比如和一模一样的内容每次请求都必须附带这会浪费很多带宽也影响速度对这一点做了优化引入了头信息压缩机制一方面头信息使用或压缩后再发送另一方面客户端和服务器同时维护一张头信息表所有字段都会存入这个表生成一个索引号以后就不发送同样字段了只发送索引号这样就能提高速度了服务器推送允许服务器未经请求主动向客户端发送资源这叫做服务器推送使用服务器推送提前给客户端推送必要的资源这样就可以相对减少一些延迟时间这里需要注意的是下服务器主动推送的是静态资源和以及使用等方式向客户端发送即时数据的推送是不同的队头堵塞队头阻塞是由基本的请求应答模型所导致的规定报文必须是一发一收这就形成了一个先进先出的串行队列队列里的请求是没有优先级的只有入队的先后顺序排在最前面的请求会被最优先处理如果队首的请求因为处理的太慢耽误了时间那么队列里后面的所有请求也不得不跟着一起等待结果就是其他的请求承担了不应有的时间成本造成了队头堵塞的现象和协议的区别和协议的主要区别如下协议需要证书费用较高而协议不需要协议是超文本传输协议信息是明文传输的则是具有安全性的加密传输协议使用不同的连接方式端口也不同协议端口是协议端口是协议连接很简单是无状态的协议是有和协议构建的可进行加密传输身份认证的网络协议比更加安全方法长度限制的原因实际上协议规范并没有对方法请求的长度进行限制这个限制是特定的浏览器及服务器对它的限制对长度的限制是字节由于浏览器对长度的允许值是最小的所以开发过程中只要不超过字节那么在所有浏览器中工作都不会有问题的长度值你的是请求中两个字符的长度下面看一下主流浏览器对方法中的长度限制范围浏览器对的最大限制为个字符如果超过这个数字提交按钮没有任何反应对于浏览器的长度限制为个字符最大长度限制为个字符最大长度限制为个字符最大长度限制为个字符主流的服务器对方法中的长度限制范围能接受最大长度为个字符能接受最大的长度为个字符根据上面的数据可以知道方法中的长度最长不超过个字符这样所有的浏览器和服务器都可能正常工作当在浏览器中输入并且按下回车之后发生了什么解析首先会对进行解析分析所需要使用的传输协议和请求的资源的路径如果输入的中的协议或者主机名不合法将会把地址栏中输入的内容传递给搜索引擎如果没有问题浏览器会检查中是否出现了非法字符如果存在非法字符则对非法字符进行转义后再进行下一过程缓存判断浏览器会判断所请求的资源是否在缓存里如果请求的资源在缓存里并且没有失效那么就直接使用否则向服务器发起新的请求解析下一步首先需要获取的是输入的中的域名的地址首先会判断本地是否有该域名的地址的缓存如果有则使用如果没有则向本地服务器发起请求本地服务器也会先检查是否存在缓存如果没有就会先向根域名服务器发起请求获得负责的顶级域名服务器的地址后再向顶级域名服务器请求然后获得负责的权威域名服务器的地址后再向权威域名服务器发起请求最终获得域名的地址后本地服务器再将这个地址返回给请求的用户用户向本地服务器发起请求属于递归请求本地服务器向各级域名服务器发起请求属于迭代请求获取地址当浏览器得到地址后数据传输还需要知道目的主机地址因为应用层下发数据给传输层协议会指定源端口号和目的端口号然后下发给网络层网络层会将本机地址作为源地址获取的地址作为目的地址然后将下发给数据链路层数据链路层的发送需要加入通信双方的地址本机的地址作为源地址目的地址需要分情况处理通过将地址与本机的子网掩码相与可以判断是否与请求主机在同一个子网里如果在同一个子网里可以使用协议获取到目的主机的地址如果不在一个子网里那么请求应该转发给网关由它代为转发此时同样可以通过协议来获取网关的地址此时目的主机的地址应该为网关的地址三次握手下面是建立连接的三次握手的过程首先客户端向服务器发送一个连接请求报文段和一个随机序号服务端接收到请求后向服务器端发送一个报文段确认连接请求并且也向客户端发送一个随机序号客户端接收服务器的确认应答后进入连接建立的状态同时向服务器也发送一个确认报文段服务器端接收到确认后也进入连接建立状态此时双方的连接就建立起来了握手如果使用的是协议在通信前还存在的一个四次握手的过程首先由客户端向服务器端发送使用的协议的版本号一个随机数和可以使用的加密方法服务器端收到后确认加密的方法也向客户端发送一个随机数和自己的数字证书客户端收到后首先检查数字证书是否有效如果有效则再生成一个随机数并使用证书中的公钥对随机数加密然后发送给服务器端并且还会提供一个前面所有内容的值供服务器端检验服务器端接收后使用自己的私钥对数据解密同时向客户端发送一个前面所有内容的值供客户端检验这个时候双方都有了三个随机数按照之前所约定的加密方法使用这三个随机数生成一把秘钥以后双方通信前就使用这个秘钥对数据进行加密后再传输返回数据当页面请求发送到服务器端后服务器端会返回一个文件作为响应浏览器接收到响应后开始对文件进行解析开始页面的渲染过程页面渲染浏览器首先会根据文件构建树根据解析到的文件构建树如果遇到标签则判端是否含有或者属性要不然的加载和执行会造成页面的渲染的阻塞当树和树建立好后根据它们来构建渲染树渲染树构建好后会根据渲染树来进行布局布局完成后最后使用浏览器的接口对页面进行绘制这个时候整个页面就显示出来了四次挥手最后一步是断开连接的四次挥手过程若客户端认为数据发送完成则它需要向服务端发送连接释放请求服务端收到连接释放请求后会告诉应用层要释放链接然后会发送包并进入状态此时表明客户端到服务端的连接已经释放不再接收客户端发的数据了但是因为连接是双向的所以服务端仍旧可以发送数据给客户端服务端如果此时还有没发完的数据会继续发送完毕后会向客户端发送连接释放请求然后服务端便进入状态客户端收到释放请求后向服务端发送确认应答此时客户端进入状态该状态会持续最大段生存期指报文段在网络中生存的时间超时会被抛弃时间若该时间段内没有服务端的重发请求的话就进入状态当服务端收到确认应答后也便进入状态对的理解中默认是在每次请求应答客户端和服务器都要新建一个连接完成之后立即断开连接这就是短连接当使用模式时功能使客户端到服务器端的连接持续有效当出现对服务器的后继请求时功能避免了建立或者重新建立连接这就是长连接其使用方法如下版本是默认没有的也就是默认会发送所以要想连接得到保持必须手动配置发送字段若想断开连接需发送字段规定了默认保持长连接数据传输完成了保持连接不断开等待在同域名下继续用这个通道传输数据如果需要关闭需要客户端发送首部字段的建立过程客户端向服务器在发送请求报文同时在首部添加发送字段服务器收到请求并处理字段服务器回送字段给客户端客户端接收到字段连接建立成功服务端自动断开过程也就是没有客户端向服务器只是发送内容报文不包含字段服务器收到请求并处理服务器返回客户端请求的资源并关闭连接客户端接收资源发现没有字段断开连接客户端请求断开连接过程客户端向服务器发送字段服务器收到请求并处理字段服务器回送响应资源并断开连接客户端接收资源并断开连接开启的优点较少的和内存的使由于同时打开的连接的减少了允许请求和应答的管线化降低拥塞控制连接减少了减少了后续请求的延迟需再进握报告错误需关闭连开启的缺点长时间的连接容易导致系统资源无效占用浪费系统资源页面有多张图片是怎样的加载表现在下浏览器对一个域名下最大连接数为所以会请求多次可以用多域名部署解决这样可以提高同时请求的数目加快页面图片的获取速度在下可以一瞬间加载出来很多资源因为支持多路复用可以在一个连接中发送多个请求的头部压缩算法是怎样的的头部压缩是算法在客户端和服务器两端建立字典用索引号表示重复的字符串采用哈夫曼编码来压缩整数和字符串可以达到的高压缩率具体来说在客户端和服务器端使用首部表来跟踪和存储之前发送的键值对对于相同的数据不再通过每次请求和响应发送首部表在的连接存续期内始终存在由客户端和服务器共同渐进地更新每个新的首部键值对要么被追加到当前表的末尾要么替换表中之前的值例如下图中的两个请求请求一发送了所有的头部字段第二个请求则只需要发送差异数据这样可以减少冗余数据降低开销请求报文的是什么样的请求报有部分组成请求请求头部空请求体其中请求包括请求法字段字段协议版本字段它们空格分隔例如请求头部请求头部由关键字值对组成每对关键字和值英冒号分隔产请求的浏览器类型客户端可识别的内容类型列表请求的主机名允许多个域名同处个地址即虚拟主机请求体等请求携带的数据响应报文的是什么样的请求报有部分组成响应响应头空响应体响应由网络协议版本状态码和状态码的原因短语组成例如响应头响应部组成响应体服务器响应的数据协议的优点和缺点是超文本传输协议它定义了客户端和服务器之间交换报文的格式和方式默认使用端口它使用作为传输层协议保证了数据传输的可靠性协议具有以下优点支持客户端服务器模式简单快速客户向服务器请求服务时只需传送请求方法和路径由于协议简单使得服务器的程序规模小因而通信速度很快无连接无连接就是限制每次连接只处理一个请求服务器处理完客户的请求并收到客户的应答后即断开连接采用这种方式可以节省传输时间无状态协议是无状态协议这里的状态是指通信过程的上下文信息缺少状态意味着如果后续处理需要前面的信息则它必须重传这样可能会导致每次连接传送的数据量增大另一方面在服务器不需要先前信息时它的应答就比较快灵活允许传输任意类型的数据对象正在传输的类型由加以标记协议具有以下缺点无状态是一个无状态的协议服务器不会保存关于客户的任何信息明文传输协议中的报文使用的是文本形式这就直接暴露给外界不安全不安全通信使用明文不加密内容可能会被窃听不验证通信方的身份因此有可能遭遇伪装无法证明报文的完整性所以有可能已遭篡改说一下基于协议实现了类似于的多路复用数据流传输可靠性等功能这套功能被称为协议流量控制传输可靠性功能在的基础上增加了一层来保证数据传输可靠性它提供了数据包重传拥塞控制以及其他一些中的特性集成加密功能目前使用减少了握手所花费的数多路复用同一物理连接上可以有多个独立的逻辑数据流实现了数据流的单独传输解决了的队头阻塞问题快速握手由于基于可以实现使用个来建立连接协议的性能怎么样协议是基于并且使用了请求应答的通信模式所以性能的关键就在这两点里长连接协议有两种连接模式一种是持续连接一种非持续连接非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接持续连接下连接默认不关闭可以被多个请求复用采用持续连接的好处是可以避免每次建立连接三次握手时所花费的时间对于不同版本的采用不同的连接方式在每发起一个请求都要新建一次连接三次握手而且是串行请求做了无畏的连接建立和断开增加了通信开销该版本使用的非持续的连接但是可以在请求时加上来要求服务器不要关闭连接在提出了长连接的通信方式也叫持久连接这种方式的好处在于减少了连接的重复建立和断开所造成的额外开销减轻了服务器端的负载该版本及以后版本默认采用的是持续的连接目前对于同一个域大多数浏览器支持同时建立个持久连接管道网络传输采用了长连接的方式这使得管道网络传输成为了可能管道网络传输是指可以在同一个连接里面客户端可以发起多个请求只要第一个请求发出去了不必等其回来就可以发第二个请求出去可以减少整体的响应时间但是服务器还是按照顺序回应请求如果前面的回应特别慢后面就会有许多请求排队等着这称为队头堵塞队头堵塞传输的报文必须是一发一收但是里面的任务被放在一个任务队列中串行执行一旦队首的请求处理太慢就会阻塞后面请求的处理这就是队头阻塞问题队头阻塞的解决方案并发连接对于一个域名允许分配多个长连接那么相当于增加了任务队列不至于一个队伍的任务阻塞其它所有任务域名分片将域名分出很多二级域名它们都指向同样的一台服务器能够并发的长连接数变多解决了队头阻塞的问题有哪些组成部分以下面的为例从上面的可以看出一个完整的包括以下几部分协议部分该的协议部分为这代表网页使用的是协议在中可以使用多种协议如等等本例中使用的是协议在后面的为分隔符域名部分该的域名部分为一个中也可以使用地址作为域名使用端口部分跟在域名后面的是端口域名和端口之间使用作为分隔符端口不是一个必须的部分如果省略端口部分将采用默认端口协议默认端口是协议默认端口是虚拟目录部分从域名后的第一个开始到最后一个为止是虚拟目录部分虚拟目录也不是一个必须的部分本例中的虚拟目录是文件名部分从域名后的最后一个开始到为止是文件名部分如果没有则是从域名后的最后一个开始到为止是文件部分如果没有和那么从域名后的最后一个开始到结束都是文件名部分本例中的文件名是文件名部分也不是一个必须的部分如果省略该部分则使用默认的文件名锚部分从开始到最后都是锚部分本例中的锚部分是锚部分也不是一个必须的部分参数部分从开始到为止之间的部分为参数部分又称搜索部分查询部分本例中的参数部分为参数可以允许有多个参数参数与参数之间用作为分隔符与缓存相关的请求头有哪些强缓存协商缓存二协议什么是协议超文本传输安全协议简称是一种通过计算机网络进行安全通信的传输协议经由进行通信利用来加密数据包的主要目的是提供对网站服务器的身份认证保护交换数据的隐私与完整性协议采用明文传输信息存在信息窃听信息篡改和信息劫持的风险而协议具有身份验证信息加密和完整性校验的功能可以避免此类问题发生安全层的主要职责就是对发起的请求的数据进行加密操作和对接收到的的内容进行解密操作的工作原理全称安全传输层协议是介于和之间的一层安全协议不影响原有的协议和协议所以使用基本上不需要对页面进行太多的改造的功能实现主要依赖三类基本算法散列函数对称加密非对称加密这三类算法的作用如下基于散列函数验证信息的完整性对称加密算法采用协商的秘钥对数据加密非对称加密实现身份认证和秘钥协商散列函数常见的散列函数有该函数的特点是单向不可逆对输入数据非常敏感输出的长度固定任何数据的修改都会改变散列函数的结果可以用于防止信息篡改并验证数据的完整性特点在信息传输过程中散列函数不能三都实现信息防篡改由于传输是明文传输中间人可以修改信息后重新计算信息的摘要所以需要对传输的信息和信息摘要进行加密对称加密对称加密的方法是双方使用同一个秘钥对数据进行加密和解密但是对称加密的存在一个问题就是如何保证秘钥传输的安全性因为秘钥还是会通过网络传输的一旦秘钥被其他人获取到那么整个加密过程就毫无作用了这就要用到非对称加密的方法常见的对称加密算法有等相同的秘钥可以用于信息的加密和解密掌握秘钥才能获取信息防止信息窃听其通讯方式是一对一特点对称加密的优势就是信息传输使用一对一需要共享相同的密码密码的安全是保证信息安全的基础服务器和个客户端通信需要维持个密码记录且不能修改密码非对称加密非对称加密的方法是我们拥有两个秘钥一个是公钥一个是私钥公钥是公开的私钥是保密的用私钥加密的数据只有对应的公钥才能解密用公钥加密的数据只有对应的私钥才能解密我们可以将公钥公布出去任何想和我们通信的客户都可以使用我们提供的公钥对数据进行加密这样我们就可以使用私钥进行解密这样就能保证数据的安全了但是非对称加密有一个缺点就是加密的过程很慢因此如果每次通信都使用非对称加密的方式的话反而会造成等待时间过长的问题常见的非对称加密算法有等秘钥成对出现一般称为公钥公开和私钥保密公钥加密的信息只有私钥可以解开私钥加密的信息只能公钥解开因此掌握公钥的不同客户端之间不能相互解密信息只能和服务器进行加密通信服务器可以实现一对多的的通信客户端也可以用来验证掌握私钥的服务器的身份特点非对称加密的特点就是信息一对多服务器只需要维持一个私钥就可以和多个客户端进行通信但服务器发出的信息能够被所有的客户端解密且该算法的计算复杂加密的速度慢综合上述算法特点的工作方式就是客户端使用非对称加密与服务器进行通信实现身份的验证并协商对称加密使用的秘钥对称加密算法采用协商秘钥对信息以及信息摘要进行加密通信不同节点之间采用的对称秘钥不同从而保证信息只能通信双方获取这样就解决了两个方法各自存在的问题数字证书是什么现在的方法也不一定是安全的因为没有办法确定得到的公钥就一定是安全的公钥可能存在一个中间人截取了对方发给我们的公钥然后将他自己的公钥发送给我们当我们使用他的公钥加密后发送的信息就可以被他用自己的私钥解密然后他伪装成我们以同样的方法向对方发送信息这样我们的信息就被窃取了然而自己还不知道为了解决这样的问题可以使用数字证书首先使用一种算法来对公钥和其他信息进行加密生成一个信息摘要然后让有公信力的认证中心简称用它的私钥对消息摘要加密形成签名最后将原始的信息和签名合在一起称为数字证书当接收方收到数字证书的时候先根据原始信息使用同样的算法生成一个摘要然后使用公证处的公钥来对数字证书中的摘要进行解密最后将解密的摘要和生成的摘要进行对比就能发现得到的信息是否被更改了这个方法最要的是认证中心的可靠性一般浏览器里会内置一些顶层的认证中心的证书相当于我们自动信任了他们只有这样才能保证数据的安全通信握手过程的通信过程如下客户端向服务器发起请求请求中包含使用的协议版本号生成的一个随机数以及客户端支持的加密方法服务器端接收到请求后确认双方使用的加密方法并给出服务器的证书以及一个服务器生成的随机数客户端确认服务器证书有效后生成一个新的随机数并使用数字证书中的公钥加密这个随机数然后发给服务器并且还会提供一个前面所有内容的的值用来供服务器检验服务器使用自己的私钥来解密客户端发送过来的随机数并提供前面所有内容的值来供客户端检验客户端和服务器端根据约定的加密方法使用前面的三个随机数生成对话秘钥以后的对话过程都使用这个秘钥来加密信息的特点的优点如下使用协议可以认证用户和服务器确保数据发送到正确的客户端和服务器使用协议可以进行加密传输身份认证通信更加安全防止数据在传输过程中被窃取修改确保数据安全性是现行架构下最安全的解决方案虽然不是绝对的安全但是大幅增加了中间人攻击的成本的缺点如下需要做服务器和客户端双方的加密个解密处理耗费更多服务器资源过程复杂协议握手阶段比较费时增加页面的加载时间证书是收费的功能越强大的证书费用越高连接服务器端资源占用高很多支持访客稍多的网站需要投入更大的成本证书需要绑定不能再同一个上绑定多个域名是如何保证安全的先理解两个概念对称加密即通信的双都使同个秘钥进加解密对称加密虽然很简单性能也好但是法解决次把秘钥发给对的问题很容易被客拦截秘钥对称加密私钥公钥密钥对即私钥加密的数据只有对应的公钥才能解密公钥加密的数据只有对应的私钥才能解密因为通信双的都有套的密钥对通信之前双会先把的公钥都先发给对然后对再拿着这个公钥来加密数据响应给对等到到了对那对再的私钥进解密对称加密虽然安全性更但是带来的问题就是速度很慢影响性能解决案结合两种加密式将对称加密的密钥使对称加密的公钥进加密然后发送出去接收使私钥进解密得到对称加密的密钥然后双可以使对称加密来进沟通此时带来个问题中间问题如果此时在客户端和服务器之间存在个中间这个中间只需要把原本双通信互发的公钥换成的公钥这样中间就可以轻松解密通信双所发送的所有数据所以这个时候需要个安全的第三颁发证书证明身份的身份防被中间攻击证书中包括签发者证书途使者公钥使者私钥使者的算法证书到期时间等但是问题来了如果中间篡改了证书那么身份证明是不是就效了这个证明就买了这个时候需要个新的技术数字签名数字签名就是带的算法对证书的内容进得到个摘要再的私钥加密最终组成数字签名当别把他的证书发过来的时候我再同样的算法再次成消息摘要然后的公钥对数字签名解密得到创建的消息摘要两者就知道中间有没有被篡改了这个时候就能最程度保证通信的安全了三状态码状态码的类别类别原因描述信息性状态码接受的请求正在处理成功状态码请求正常处理完毕重定向状态码需要进行附加操作一完成请求客户端错误状态码服务器无法处理请求服务器错误状态码服务器处理请求出错成功状态码状态码表示请求被正常处理了表示客户端发来的请求被服务器端正常处理了该状态码表示客户端发送的请求已经在服务器端正常处理了但是没有返回的内容响应报文中不包含实体的主体部分一般在只需要从客户端往服务器端发送信息而服务器端不需要往客户端发送内容时使用该状态码表示客户端进行了范围请求而服务器端执行了这部分的请求响应报文中包含由指定范围的实体内容重定向状态码响应结果表明浏览器需要执行某些特殊的处理以正确处理请求永久重定向该状态码表示请求的资源已经被分配了新的以后应使用资源指定的新的会在响应头中的首部字段指定若用户已经把原来的保存为书签此时会按照中新的重新保存该书签同时搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址使用场景当我们想换个域名旧的域名不再使用时用户访问旧域名时用就重定向到新的域名其实也是告诉搜索引擎收录的域名需要对新的域名进行收录在搜索引擎的搜索结果中出现了不带的域名而带的域名却没有收录这个时候可以用重定向来告诉搜索引擎我们目标的域名是哪一个临时重定向该状态码表示请求的资源被分配到了新的希望用户本次能使用新的访问资源和状态码相似但是代表的资源不是被永久重定向只是临时性质的也就是说已移动的资源对应的将来还有可能发生改变若用户把保存成书签但不会像状态码出现时那样去更新书签而是仍旧保留返回状态码的页面对应的同时搜索引擎会抓取新的内容而保留旧的网址因为服务器返回代码搜索引擎认为新的网址只是暂时的使用场景当我们在做活动时登录到首页自动重定向进入活动页面未登陆的用户访问用户中心重定向到登录页面访问页面重新定向到首页该状态码表示由于请求对应的资源存在着另一个应使用方法定向获取请求的资源状态码和状态码有着相似的功能但是状态码明确表示客户端应当采用方法获取资源状态码通常作为或操作的返回结果它表示重定向链接指向的不是新上传的资源而是另外一个页面比如消息确认页面或上传进度页面而请求重定向页面的方法要总是使用注意当响应状态码返回时几乎所有的浏览器都会把改成并删除请求报文内的主体之后请求会再次自动发送标准是禁止将方法变成方法的但实际大家都会这么做浏览器缓存相关该状态码表示客户端发送附带条件的请求时服务器端允许请求访问资源但未满足条件的情况状态码返回时不包含任何响应的主体部分虽然被划分在类别中但是和重定向没有关系带条件的请求条件请求使用方法请求请求报文中包含中任意首部状态码并不是一种错误而是告诉客户端有缓存直接使用缓存中的数据返回页面的只有头部信息是没有内容部分的这样在一定程度上提高了网页的性能表示临时重定向该状态码与有着相同含义尽管标准禁止变成但是实际使用时还是这样做了会遵守浏览器标准不会从变成但是对于处理请求的行为时不同浏览器还是会出现不同的情况规范要求浏览器继续向的地址内容规范要求浏览器继续向的地址内容客户端错误状态码的响应结果表明客户端是发生错误的原因所在该状态码表示请求报文中存在语法错误当错误发生时需修改请求的内容后再次发送请求另外浏览器会像一样对待该状态码该状态码表示发送的请求需要有通过认证认证认证的认证信息若之前已进行过一次请求则表示用户认证失败返回含有的响应必须包含一个适用于被请求资源的首部用以质询用户信息当浏览器初次接收到响应会弹出认证用的对话窗口以下情况会出现登录失败服务器配置导致登录失败由于对资源的限制而未获得授权筛选器授权失败应用程序授权失败访问被服务器上的授权策略拒绝这个错误代码为所专用该状态码表明请求资源的访问被服务器拒绝了服务器端没有必要给出详细理由但是可以在响应报文实体的主体中进行说明进入该状态后不能再继续进行验证该访问是永久禁止的并且与应用逻辑密切相关定义了许多不同的错误它们指明更为具体的错误原因执行访问被禁止读访问被禁止写访问被禁止要求要求地址被拒绝要求客户端证书站点访问被拒绝用户数过多配置无效密码更改拒绝访问映射表客户端证书被吊销拒绝目录列表超出客户端访问许可客户端证书不受信任或无效客户端证书已过期或尚未生效在当前的应用程序池中不能执行所请求的这个错误代码为所专用不能为这个应用程序池中的客户端执行这个错误代码为所专用登录失败这个错误代码为所专用该状态码表明服务器上无法找到请求的资源除此之外也可以在服务器端拒绝请求且不想说明理由时使用以下情况会出现无没有找到文件或目录无法在所请求的端口上访问站点服务扩展锁定策略阻止本请求映射策略阻止本请求该状态码表示客户端请求的方法虽然能被服务器识别但是服务器禁止使用该方法和方法服务器应该总是允许客户端进行访问客户端可以通过方法预检来查看服务器允许的访问方法如下服务器错误状态码的响应结果表明服务器本身发生错误该状态码表明服务器端在执行请求时发生了错误也有可能是应用存在的或某些临时的故障该状态码表明扮演网关或代理角色的服务器从上游服务器中接收到的响应是无效的注意错误通常不是客户端能够修复的而是需要由途经的服务器或者代理服务器对其进行修复以下情况会出现通用网关接口应用程序超时通用网关接口应用程序出错该状态码表明服务器暂时处于超负载或正在进行停机维护现在无法处理请求如果事先得知解除以上状况需要的时间最好写入首部字段再返回给客户端使用场景服务器停机维护时主动用响应请求设置限速超过限速会返回该状态码表示网关或者代理的服务器无法在规定的时间内获得想要的响应他是中新加入的使用场景代码执行时间超时或者发生了死循环总结成功表示从客户端发来的请求在服务器端被正确处理表示请求成功但响应报文不含实体的主体部分表示请求成功但响应报文不含实体的主体部分但是与响应不同在于要求请求方重置内容进行范围请求重定向永久性重定向表示资源已被分配了新的临时性重定向表示资源临时被分配了新的表示资源存在着另一个应使用方法获取资源表示服务器允许访问资源但因发生请求未满足条件的情况临时重定向和含义类似但是期望客户端保持请求方法不变向新的地址发出请求客户端错误请求报文存在语法错误表示发送的请求需要有通过认证的认证信息表示对请求资源的访问被服务器拒绝表示在服务器上没有找到请求的资源服务器错误表示服务器端在执行请求时发生了错误表示服务器不支持当前请求所需要的某个功能表明服务器暂时处于超负载或正在停机维护无法处理请求同样是重定向的区别是的协议状态码在版本的时候为了细化状态码出来了两个和明确表示客户端应当采法获取资源他会把请求变为请求进重定向会遵照浏览器标准不会从变为四协议介绍协议是什么概念是域名系统的缩写提供的是一种主机名到地址的转换服务就是我们常说的域名系统它是一个由分层的服务器组成的分布式数据库是定义了主机如何查询这个分布式数据库的方式的应用层协议能够使人更方便的访问互联网而不用去记住能够被机器直接读取的数串作用将域名解析为地址客户端向服务器服务器有自己的地址发送域名查询请求服务器告知客户机服务器的地址同时使用和协议占用号端口同时使用和协议在区域传输的时候使用协议辅域名服务器会定时一般小时向主域名服务器进行查询以便了解数据是否有变动如有变动会执行一次区域传送进行数据同步区域传送使用而不是因为数据同步传送的数据量比一个请求应答的数据量要多得多是一种可靠连接保证了数据的准确性在域名解析的时候使用协议客户端向服务器查询域名一般返回的内容都不超过字节用传输即可不用经过三次握手这样服务器负载更低响应更快理论上说客户端也可以指定向服务器查询时用但事实上很多服务器进行配置的时候仅支持查询包完整的查询过程服务器解析域名的过程首先会在浏览器的缓存中查找对应的地址如果查找到直接返回若找不到继续下一步将请求发送给本地服务器在本地域名服务器缓存中查询如果查找到就直接将查找结果返回若找不到继续下一步本地服务器向根域名服务器发送请求根域名服务器会返回一个所查询域的顶级域名服务器地址本地服务器向顶级域名服务器发送请求接受请求的服务器查询自己的缓存如果有记录就返回查询结果如果没有就返回相关的下一级的权威域名服务器的地址本地服务器向权威域名服务器发送请求域名服务器返回对应的结果本地服务器将返回结果保存在缓存中便于下次使用本地服务器将返回结果返回给浏览器比如要查询的地址首先会在浏览器的缓存中查找是否有该域名的缓存如果不存在就将请求发送到本地的服务器中本地服务器会判断是否存在该域名的缓存如果不存在则向根域名服务器发送一个请求根域名服务器返回负责的顶级域名服务器的地址的列表然后本地服务器再向其中一个负责的顶级域名服务器发送一个请求负责的顶级域名服务器返回负责的权威域名服务器的地址列表然后本地服务器再向其中一个权威域名服务器发送一个请求最后权威域名服务器返回一个对应的主机名的地址列表迭代查询与递归查询实际上解析是一个包含迭代查询和递归查询的过程递归查询指的是查询请求发出后域名服务器代为向下一级域名服务器发出请求最后向用户返回查询的最终结果使用递归查询用户只需要发出一次查询请求迭代查询指的是查询请求后域名服务器返回单次查询的结果下一级的查询由用户自己请求使用迭代查询用户需要发出多次的查询请求一般我们向本地服务器发送请求的方式就是递归查询因为我们只需要发出一次请求然后本地服务器返回给我们最终的请求结果而本地服务器向其他域名服务器请求的过程是迭代查询的过程因为每一次域名服务器只返回单次查询的结果下一级的查询由本地服务器自己进行记录和报文服务器中以资源记录的形式存储信息每一个响应报文一般包含多条资源记录一条资源记录的具体的格式为其中是资源记录的生存时间它定义了资源记录能够被其他的服务器缓存多长时间常用的一共有四种的值分别是和不同的值对应资源记录代表的意义不同如果则是主机名是主机名对应的地址因此一条记录为的资源记录提供了标准的主机名到地址的映射如果则是个域名是负责该域名的服务器的主机名这个记录主要用于链式查询时返回下一级需要查询的服务器的信息如果则为别名为该主机的规范主机名该条记录用于向查询的主机返回一个主机名对应的规范主机名从而告诉查询主机去查询这个主机名的地址主机别名主要是为了通过给一些复杂的主机名提供一个便于记忆的简单的别名如果则为一个邮件服务器的别名为邮件服务器的规范主机名它的作用和是一样的都是为了解决规范主机名不利于记忆的缺点五网络模型七层模型为了更好的使网络应用更为普及推出了参考模型应用层参考模型中最靠近用户的一层是为计算机用户提供应用接口也为用户直接提供各种网络服务我们常见应用层的网络服务协议有等在客户端与服务器中经常会有数据的请求这个时候就是会用到超文本传输协议或者在后端设计数据接口时我们常常使用到这个协议是文件传输协议在开发过程中个人并没有涉及到但是我想在一些资源网站比如百度网盘迅雷应该是基于此协议的是简单邮件传输协议在一个项目中在用户邮箱验证码登录的功能时使用到了这个协议表示层表示层提供各种用于应用层数据的编码和转换功能确保一个系统的应用层发送的数据能被另一个系统的应用层识别如果必要该层可提供一种标准表示形式用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式数据压缩和加密也是表示层可提供的转换功能之一在项目开发中为了方便数据传输可以使用对数据进行编解码如果按功能来划分应该是工作在表示层会话层会话层就是负责建立管理和终止表示层实体之间的通信会话该层的通信由不同设备中的应用程序之间的服务请求和响应组成传输层传输层建立了主机端到端的链接传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务包括处理差错控制和流量控制等问题该层向高层屏蔽了下层数据通信的细节使高层用户看到的只是在两个传输实体间的一条主机到主机的可由用户控制和设定的可靠的数据通路我们通常说的就是在这一层端口号既是这里的端网络层本层通过寻址来建立两个节点之间的连接为源端的运输层送来的分组选择合适的路由和交换节点正确无误地按照地址传送给目的端的运输层就是通常说的层这一层就是我们经常说的协议层协议是的基础我们可以这样理解网络层规定了数据包的传输路线而传输层则规定了数据包的传输方式数据链路层将比特组合成字节再将字节组合成帧使用链路层地址以太网使用地址来访问介质并进行差错检测网络层与数据链路层的对比通过上面的描述我们或许可以这样理解网络层是规划了数据包的传输路线而数据链路层就是传输路线不过在数据链路层上还增加了差错控制的功能物理层实际最终信号的传输是通过物理层实现的通过物理介质传输比特流规定了电平速度和电缆针脚常用设备有各种物理设备集线器中继器调制解调器网线双绞线同轴电缆这些都是物理层的传输介质七层模型通信特点对等通信对等通信为了使数据分组从源传送到目的地源端模型的每一层都必须与目的端的对等层进行通信这种通信方式称为对等层通信在每一层通信过程中使用本层自己协议进行通信五层协议五层协议和的七层协议对应关系如下应用层直接为应用进程提供服务应用层协议定义的是应用进程间通讯和交互的规则不同的应用有着不同的应用层协议如协议万维网服务协议文件传输协议电子邮件域名查询等传输层有时也译为运输层它负责为两台主机中的进程提供通信服务该层主要有以下两种协议传输控制协议提供面向连接的可靠的数据传输服务数据传输的基本单位是报文段用户数据报协议提供无连接的尽最大努力的数据传输服务但不保证数据传输的可靠性数据传输的基本单位是用户数据报网络层有时也译为网际层它负责为两台主机提供通信服务并通过选择合适的路由将数据传递到目标主机数据链路层负责将网络层交下来的数据报封装成帧并在链路的两个相邻节点间传送帧每一帧都包含数据和必要的控制信息如同步信息地址信息差错控制等物理层确保数据可以在各种物理媒介上进行传输为数据的传输提供可靠的环境从上图中可以看出模型比模型更加简洁它把应用层表示层会话层全部整合为了应用层在每一层都工作着不同的设备比如我们常用的交换机就工作在数据链路层的一般的路由器是工作在网络层的在每一层实现的协议也各不同即每一层的服务也不同下图列出了每层主要的传输协议同样五层协议的通信方式也是对等通信六与和的概念及特点和都是传输层协议他们都属于协议族的全称是用户数据报协议在网络中它与协议一样用于处理数据包是一种无连接的协议在模型中在传输层处于协议的上一层有不提供数据包分组组装和不能对数据包进行排序的缺点也就是说当报文发送之后是无法得知其是否安全完整到达的它的特点如下面向无连接首先是不需要和一样在发送数据前进行三次握手建立连接的想发数据就可以开始发送了并且也只是数据报文的搬运工不会对数据报文进行任何拆分和拼接操作具体来说就是在发送端应用层将数据传递给传输层的协议只会给数据增加一个头标识下是协议然后就传递给网络层了在接收端网络层将数据传递给传输层只去除报文头就传递给应用层不会任何拼接操作有单播多播广播的功能不止支持一对一的传输方式同样支持一对多多对多多对一的方式也就是说提供了单播多播广播的功能面向报文发送方的对应用程序交下来的报文在添加首部后就向下交付层对应用层交下来的报文既不合并也不拆分而是保留这些报文的边界因此应用程序必须选择合适大小的报文不可靠性首先不可靠性体现在无连接上通信都不需要建立连接想发就发这样的情况肯定不可靠并且收到什么数据就传递什么数据并且也不会备份数据发送数据也不会关心对方是否已经正确接收到数据了再者网络环境时好时坏但是因为没有拥塞控制一直会以恒定的速度发送数据即使网络条件不好也不会对发送速率进行调整这样实现的弊端就是在网络条件不好的情况下可能会导致丢包但是优点也很明显在某些实时性要求高的场景比如电话会议就需要使用而不是头部开销小传输数据报文时是很高效的头部包含了以下几个数据两个十六位的端口号分别为源端口可选字段和目标端口整个数据报文的长度整个数据报文的检验和可选字段该字段用于发现头部信息和数据中的错误因此的头部开销小只有字节相比的至少字节要少得多在传输数据报文时是很高效的的全称是传输控制协议是一种面向连接的可靠的基于字节流的传输层通信协议是面向连接的可靠的流协议流就是指不间断的数据结构它有以下几个特点面向连接面向连接是指发送数据之前必须在两端建立连接建立连接的方法是三次握手这样能建立可靠的连接建立连接是为数据的可靠传输打下了基础仅支持单播传输每条传输连接只能有两个端点只能进行点对点的数据传输不支持多播和广播传输方式面向字节流不像一样那样一个个报文独立地传输而是在不保留报文边界的情况下以字节流方式进行传输可靠传输对于可靠传输判断丢包误码靠的是的段编号以及确认号为了保证报文传输的可靠就给每个包一个序号同时序号也保证了传送到接收端实体的包的按序接收然后接收端实体对已成功收到的字节发回一个相应的确认如果发送端实体在合理的往返时延内未收到确认那么对应的数据假设丢失了将会被重传提供拥塞控制当网络出现拥塞的时候能够减小向网络注入数据的速率和数量缓解拥塞提供全双工通信允许通信双方的应用程序在任何时候都能发送数据因为连接的两端都设有缓存用来临时存放双向通信的数据当然可以立即发送一个数据段也可以缓存一段时间以便一次发送更多的数据段最大的数据段大小取决于和的区别是否连接无连接面向连接是否可靠不可靠传输不使用流量控制和拥塞控制可靠传输数据顺序和正确性使用流量控制和拥塞控制连接对象个数支持一对一一对多多对一和多对多交互通信只能是一对一通信传输方式面向报文面向字节流首部开销首部开销小仅字节首部最小字节最大字节适用场景适用于实时应用例如视频会议直播适用于要求可靠传输的应用例如文件传输和的使用场景应用场景效率要求相对低但对准确性要求相对高的场景因为传输中需要对数据确认重发排序等操作相比之下效率没有高例如文件传输准确高要求高但是速度可以相对慢接受邮件远程登录应用场景效率要求相对高对准确性要求相对低的场景例如聊天在线视频网络语音电话即时通讯速度要求高但是出现偶尔断续不是太大问题并且此处完全不可以使用重发机制广播通信广播多播协议为什么不可靠在传输数据之前不需要先建立连接远地主机的运输层在接收到报文后不需要确认提供不可靠交付总结就以下四点不保证消息交付不确认不重传无超时不保证交付顺序不设置包序号不重排不会发生队首阻塞不跟踪连接状态不必建立连接或重启状态机不进行拥塞控制不内置客户端或网络反馈机制的重传机制由于的下层网络网络层可能出现丢失重复或失序的情况协议提供可靠数据传输服务为保证数据传输的正确性会重传其认为已丢失包括报文中的比特错误的包使用两套独立的机制来完成重传一是基于时间二是基于确认信息在发送一个数据之后就开启一个定时器若是在这个时间内没有收到发送数据的确认报文则对该报文进行重传在达到一定次数还没有成功时放弃并发送一个复位信号的拥塞控制机制的拥塞控制机制主要是以下四种机制慢启动慢开始拥塞避免快速重传快速恢复慢启动慢开始在开始发送的时候设置指的是拥塞窗口思路开始的时候不要发送大量数据而是先测试一下网络的拥塞程度由小到大增加拥塞窗口的大小为了防止增长过大引起网络拥塞设置一个慢开始门限状态变量当使用慢开始算法当既可使用慢开始算法也可以使用拥塞避免算法当使用拥塞避免算法拥塞避免拥塞避免未必能够完全避免拥塞是说在拥塞避免阶段将拥塞窗口控制为按线性增长使网络不容易出现阻塞思路让拥塞窗口缓慢的增大即每经过一个返回时间就把发送方的拥塞控制窗口加一无论是在慢开始阶段还是在拥塞避免阶段只要发送方判断网络出现拥塞就把慢开始门限设置为出现拥塞时的发送窗口大小的一半然后把拥塞窗口设置为执行慢开始算法如图所示其中判断网络出现拥塞的根据就是没有收到确认虽然没有收到确认可能是其他原因的分组丢失但是因为无法判定所以都当做拥塞来处理快速重传快重传要求接收方在收到一个失序的报文段后就立即发出重复确认为的是使发送方及早知道有报文段没有到达对方发送方只要连续收到三个重复确认就立即重传对方尚未收到的报文段而不必继续等待设置的重传计时器时间到期由于不需要等待设置的重传计时器到期能尽早重传未被确认的报文段能提高整个网络的吞吐量快速恢复当发送方连续收到三个重复确认时就执行乘法减小算法把门限减半但是接下去并不执行慢开始算法考虑到如果网络出现拥塞的话就不会收到好几个重复的确认所以发送方现在认为网络可能没有出现拥塞所以此时不执行慢开始算法而是将设置为的大小然后执行拥塞避免算法的流量控制机制一般来说流量控制就是为了让发送方发送数据的速度不要太快要让接收方来得及接收采用大小可变的滑动窗口进行流量控制窗口大小的单位是字节这里说的窗口大小其实就是每次传输的数据大小当一个连接建立时连接的每一端分配一个缓冲区来保存输入的数据并将缓冲区的大小发送给另一端当数据到达时接收方发送确认其中包含了自己剩余的缓冲区大小剩余的缓冲区空间的大小被称为窗口指出窗口大小的通知称为窗口通告接收方在发送的每一确认中都含有一个窗口通告如果接收方应用程序读数据的速度能够与数据到达的速度一样快接收方将在每一确认中发送一个正的窗口通告如果发送方操作的速度快于接收方接收到的数据最终将充满接收方的缓冲区导致接收方通告一个零窗口发送方收到一个零窗口通告时必须停止发送直到接收方重新通告一个正的窗口的可靠传输机制的可靠传输机制是基于连续协议和滑动窗口协议的协议在发送方维持了一个发送窗口发送窗口以前的报文段是已经发送并确认了的报文段发送窗口中包含了已经发送但未确认的报文段和允许发送但还未发送的报文段发送窗口以后的报文段是缓存中还不允许发送的报文段当发送方向接收方发送报文时会依次发送窗口内的所有报文段并且设置一个定时器这个定时器可以理解为是最早发送但未收到确认的报文段如果在定时器的时间内收到某一个报文段的确认回答则滑动窗口将窗口的首部向后滑动到确认报文段的后一个位置此时如果还有已发送但没有确认的报文段则重新设置定时器如果没有了则关闭定时器如果定时器超时则重新发送所有已经发送但还未收到确认的报文段并将超时的间隔设置为以前的两倍当发送方收到接收方的三个冗余的确认应答后这是一种指示说明该报文段以后的报文段很有可能发生丢失了那么发送方会启用快速重传的机制就是当前定时器结束前发送所有的已发送但确认的报文段接收方使用的是累计确认的机制对于所有按序到达的报文段接收方返回一个报文段的肯定回答如果收到了一个乱序的报文段那么接方会直接丢弃并返回一个最近的按序到达的报文段的肯定回答使用累计确认保证了返回的确认号之前的报文段都已经按序到达了所以发送窗口可以移动到已确认报文段的后面发送窗口的大小是变化的它是由接收窗口剩余大小和网络中拥塞程度来决定的就是通过控制发送窗口的长度来控制报文段的发送速率但是协议并不完全和滑动窗口协议相同因为许多的实现会将失序的报文段给缓存起来并且发生重传时只会重传一个报文段因此协议的可靠传输机制更像是窗口滑动协议和选择重传协议的一个混合体的三次握手和四次挥手三次握手三次握手其实就是指建立一个连接时需要客户端和服务器总共发送个包进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常指定自己的初始化序列号为后面的可靠性传送做准备实质上其实就是连接服务器指定端口建立连接并同步连接双方的序列号和确认号交换窗口大小信息刚开始客户端处于的状态服务端处于状态第一次握手客户端给服务端发一个报文并指明客户端的初始化序列号此时客户端处于状态首部的同步位初始序号的报文段不能携带数据但要消耗掉一个序号第二次握手服务器收到客户端的报文之后会以自己的报文作为应答并且也是指定了自己的初始化序列号同时会把客户端的作为的值表示自己已经收到了客户端的此时服务器处于的状态在确认报文段中确认号初始序号第三次握手客户端收到报文之后会发送一个报文当然也是一样把服务器的作为的值表示已经收到了服务端的报文此时客户端处于状态服务器收到报文之后也处于状态此时双方已建立起了连接确认报文段确认号序号初始为第二个报文段所以要报文段可以携带数据不携带数据则不消耗序号那为什么要三次握手呢两次不行吗为了确认双方的接收能力和发送能力都正常如果是用两次握手则会出现下面这种情况如客户端发出连接请求但因连接请求报文丢失而未收到确认于是客户端再重传一次连接请求后来收到了确认建立了连接数据传输完毕后就释放了连接客户端共发出了两个连接请求报文段其中第一个丢失第二个到达了服务端但是第一个丢失的报文段只是在某些网络结点长时间滞留了延误到连接释放以后的某个时间才到达服务端此时服务端误认为客户端又发出一次新的连接请求于是就向客户端发出确认报文段同意建立连接不采用三次握手只要服务端发出确认就建立新的连接了此时客户端忽略服务端发来的确认也不发送数据则服务端一致等待客户端发送数据浪费资源简单来说就是以下三步第一次握手客户端向服务端发送连接请求报文段该报文段中包含自身的数据通讯初始序号请求发送后客户端便进入状态第二次握手服务端收到连接请求报文段后如果同意连接则会发送一个应答该应答中也会包含自身的数据通讯初始序号发送完成后便进入状态第三次握手当客户端收到连接同意的应答后还要向服务端发送一个确认报文客户端发完这个报文段后便进入状态服务端收到这个应答后也进入状态此时连接建立成功三次握手的建立连接的过程就是相互确认初始序号的过程告诉对方什么样序号的报文段能够被正确接收第三次握手的作用是客户端对服务器端的初始序号的确认如果只使用两次握手那么服务器就没有办法知道自己的序号是否已被确认同时这样也是为了防止失效的请求报文段被服务器接收而出现错误的情况四次挥手刚开始双方都处于状态假如是客户端先发起关闭请求四次挥手的过程如下第一次挥手客户端会发送一个报文报文中会指定一个序列号此时客户端处于状态即发出连接释放报文段序号并停止再发送数据主动关闭连接进入终止等待状态等待服务端的确认第二次挥手服务端收到之后会发送报文且把客户端的序列号值作为报文的序列号值表明已经收到客户端的报文了此时服务端处于状态即服务端收到连接释放报文段后即发出确认报文段确认号序号服务端进入关闭等待状态此时的处于半关闭状态客户端到服务端的连接释放客户端收到服务端的确认后进入终止等待状态等待服务端发出的连接释放报文段第三次挥手如果服务端也想断开连接了和客户端的第一次挥手一样发给报文且指定一个序列号此时服务端处于的状态即服务端没有要向客户端发出的数据服务端发出连接释放报文段序号确认号服务端进入最后确认状态等待客户端的确认第四次挥手客户端收到之后一样发送一个报文作为应答且把服务端的序列号值作为自己报文的序列号值此时客户端处于状态需要过一阵子以确保服务端收到自己的报文之后才会进入状态服务端收到报文之后就处于关闭连接了处于状态即客户端收到服务端的连接释放报文段后对此发出确认报文段客户端进入时间等待状态此时未释放掉需要经过时间等待计时器设置的时间后客户端才进入状态那为什么需要四次挥手呢因为当服务端收到客户端的连接请求报文后可以直接发送报文其中报文是用来应答的报文是用来同步的但是关闭连接时当服务端收到报文时很可能并不会立即关闭所以只能先回复一个报文告诉客户端你发的报文我收到了只有等到我服务端所有的报文都发送完了我才能发送报文因此不能一起发送故需要四次挥手简单来说就是以下四步第一次挥手若客户端认为数据发送完成则它需要向服务端发送连接释放请求第二次挥手服务端收到连接释放请求后会告诉应用层要释放链接然后会发送包并进入状态此时表明客户端到服务端的连接已经释放不再接收客户端发的数据了但是因为连接是双向的所以服务端仍旧可以发送数据给客户端第三次挥手服务端如果此时还有没发完的数据会继续发送完毕后会向客户端发送连接释放请求然后服务端便进入状态第四次挥手客户端收到释放请求后向服务端发送确认应答此时客户端进入状态该状态会持续最大段生存期指报文段在网络中生存的时间超时会被抛弃时间若该时间段内没有服务端的重发请求的话就进入状态当服务端收到确认应答后也便进入状态使用四次挥手的原因是因为的连接是全双工的所以需要双方分别释放到对方的连接单独一方的连接释放只代表不能再向对方发送数据连接处于的是半释放的状态最后一次挥手中客户端会等待一段时间再关闭的原因是为了防止发送给服务器的确认报文段丢失或者出错从而导致服务器端不能正常关闭粘包是怎么回事如何处理默认情况下连接会启延迟传送算法算法在数据发送之前缓存他们如果短时间有多个数据发送会缓冲到起作次发送缓冲这样可以减少消耗提性能如果是传输件的话那么根本不处理粘包的问题来个包拼个包就好了但是如果是多条消息或者是别的途的数据那么就需要处理粘包下面看个例连续调两次分别发送两段数据和在接收端有以下种常的情况先接收到然后接收到先接收到的部分数据然后接收到余下的部分以及的全部先接收到了的全部数据和的部分数据然后接收到了的余下的数据次性接收到了和的全部数据其中的就是我们常的粘包的情况对于处理粘包的问题常的解决案有多次发送之前间隔个等待时间只需要等上段时间再进下次就好适于交互频率特别低的场景缺点也很明显对于较频繁的场景传输效率实在太低不过乎不做什么处理关闭算法关闭算法在中你可以通过法来关闭算法让每次都不缓冲直接发送该法较适于每次发送的数据都较但不是件那么并且频率不是特别的场景如果是每次发送的数据量较并且频率特别的关闭纯属废武功另外该法不适于络较差的情况因为算法是在服务端进的包合并情况但是如果短时间内客户端的络情况不好或者应层由于某些原因不能及时将的数据就会造成多个包在客户端缓冲从粘包的情况如果是在稳定的机房内部通信那么这个概率是较可以选择忽略的进封包拆包封包拆包是前业内常的解决案了即给每个数据包在发送之前于其前后放些有特征的数据然后收到数据的时候根据特征数据分割出来各个数据包为什么不会粘包协议是向流的协议是向消息的协议段都是条消息应程序必须以消息为单位提取数据不能次提取任意字节的数据具有保护消息边界在每个包中就有了消息头消息来源地址端等信息这样对于接收端来说就容易进区分处理了传输协议把数据当作条独的消息在上传输接收端只能接收独的消息接收端次只能接收发送端发出的个数据包如果次接受数据的于发送端次发送的数据就会丢失部分数据即使丢失接受端也不会分两次去接收七对的理解是提供的一种浏览器与服务器进行全双工通讯的网络技术属于应用层协议它基于传输协议并复用的握手通道浏览器和服务器只需要完成一次握手两者之间就直接可以创建持久性的连接并进行双向数据传输的出现就解决了半双工通信的弊端它最大的特点是服务器可以向客户端主动推动消息客户端也可以主动向服务器推送消息原理客户端向服务器通知一个带有所有接收者的事件服务器接收后立即通知所有活跃的客户端只有在接收者序列中的客户端才会处理这个事件特点的如下支持双向通信实时性更强可以发送文本也可以发送二进制数据建立在协议之上服务端的实现比较容易数据格式比较轻量性能开销小通信高效没有同源限制客户端可以与任意服务器通信协议标识符是如果加密则为服务器网址就是与协议有着良好的兼容性默认端口也是和并且握手阶段采用协议因此握手时不容易屏蔽能通过各种代理服务器的使用方法如下在客户端中在中直接写设置服务端的端口号为在客户端与服务端建立连接后触发在服务端给客户端发来消息的时候触发打印的是对象打印的是收到的消息在客户端与服务端建立关闭后触发即时通讯的实现短轮询长轮询和间的区别短轮询和长轮询的目的都是用于实现客户端和服务器端的一个即时通讯短轮询的基本思路浏览器每隔一段时间向浏览器发送请求服务器端在收到请求后不论是否有数据更新都直接进行响应这种方式实现的即时通信本质上还是浏览器发送请求服务器接受请求的一个过程通过让客户端不断的进行请求使得客户端能够模拟实时地收到服务器端的数据的变化这种方式的优点是比较简单易于理解缺点是这种方式由于需要不断的建立连接严重浪费了服务器端和客户端的资源当用户增加时服务器端的压力就会变大这是很不合理的长轮询的基本思路首先由客户端向服务器发起请求当服务器收到客户端发来的请求后服务器端不会直接进行响应而是先将这个请求挂起然后判断服务器端数据是否有更新如果有更新则进行响应如果一直没有数据则到达一定的时间限制才返回客户端响应处理函数会在处理完服务器返回的信息后再次发出请求重新建立连接长轮询和短轮询比起来它的优点是明显减少了很多不必要的请求次数相比之下节约了资源长轮询的缺点在于连接挂起也会导致资源的浪费的基本思想服务器使用流信息向服务器推送信息严格地说协议无法做到服务器主动推送信息但是有一种变通方法就是服务器向客户端声明接下来要发送的是流信息也就是说发送的不是一次性的数据包而是一个数据流会连续不断地发送过来这时客户端不会关闭连接会一直等着服务器发过来的新的数据流视频播放就是这样的例子就是利用这种机制使用流信息向浏览器推送信息它基于协议目前除了其他浏览器都支持它相对于前面两种方式来说不需要建立过多的请求相比之下节约了资源是定义的一个新协议议与传统的协议不同该协议允许由服务器主动的向客户端推送信息使用协议的缺点是在服务器端的配置比较复杂是一个全双工的协议也就是通信双方是平等的可以相互发送消息而的方式是单向通信的只能由服务器端向客户端推送信息如果客户端需要发送信息就是属于下一个请求了上面的四个通信协议前三个都是基于协议的对于这四种即使通信协议从性能的角度来看长连接长轮询短轮询但是我们如果考虑浏览器的兼容性问题顺序就恰恰相反了短轮询长轮询长连接所以还是要根据具体的使用场景来判断使用哪种方式',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-08-18 12:19:03',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://z1.ax1x.com/2023/09/24/pPToDgg.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">By Wang</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Chat-GPT/" style="font-size: 1.05rem;">Chat GPT<sup>1</sup></a><a href="/tags/Linux%E3%80%90Vi%E3%80%91/" style="font-size: 1.05rem;">Linux【Vi】<sup>1</sup></a><a href="/tags/python%E3%80%90%E7%88%AC%E8%99%AB%E3%80%91/" style="font-size: 1.05rem;">python【爬虫】<sup>2</sup></a><a href="/tags/%E3%80%90JavaScript%E3%80%91/" style="font-size: 1.05rem;">【JavaScript】<sup>1</sup></a><a href="/tags/%E3%80%90Python%E3%80%91/" style="font-size: 1.05rem;">【Python】<sup>1</sup></a><a href="/tags/%E3%80%90Typora%E3%80%91/" style="font-size: 1.05rem;">【Typora】<sup>1</sup></a><a href="/tags/%E3%80%90%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E3%80%91/" style="font-size: 1.05rem;">【青龙面板】<sup>1</sup></a><a href="/tags/%E5%86%9B%E5%93%A5%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 1.05rem;">军哥面试题<sup>14</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF%E3%80%90CSS%E3%80%91/" style="font-size: 1.05rem;">前端【CSS】<sup>2</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF%E3%80%90JavaScript%E3%80%91/" style="font-size: 1.05rem;">前端【JavaScript】<sup>6</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF%E3%80%90JaveScript%E3%80%91/" style="font-size: 1.05rem;">前端【JaveScript】<sup>1</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF%E3%80%90Layui%E3%80%91/" style="font-size: 1.05rem;">前端【Layui】<sup>2</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF%E3%80%90Vue%E3%80%91/" style="font-size: 1.05rem;">前端【Vue】<sup>4</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 1.05rem;">博客<sup>1</sup></a><a href="/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/" style="font-size: 1.05rem;">学习日常<sup>4</sup></a><a href="/tags/%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">模拟面试<sup>1</sup></a><a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 1.05rem;">笔记<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">九月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">五月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/04/"><span class="card-archive-list-date">四月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/03/"><span class="card-archive-list-date">三月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%86%9B%E5%93%A5%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url">军哥面试题</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E5%86%9B%E5%93%A5%E9%9D%A2%E8%AF%95%E9%A2%98/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>军哥面试题</span></a></span></div></div><h1 class="post-title" itemprop="name headline">军哥面试题-8.计算机网络篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2022-08-18T04:19:03.000Z" title="发表于 2022-08-18 12:19:03">2022-08-18</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2022-08-18T04:19:03.000Z" title="更新于 2022-08-18 12:19:03">2022-08-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="军哥面试题-8.计算机网络篇"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为山东"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>山东</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://source.fomal.cc/img/default_cover_8.webp"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://blog.xiaoadai.com/2022/08/18/8%20offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87/"><header><a class="post-meta-categories" href="/categories/%E5%86%9B%E5%93%A5%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url">军哥面试题</a><a href="/tags/%E5%86%9B%E5%93%A5%E9%9D%A2%E8%AF%95%E9%A2%98/" tabindex="-1" itemprop="url">军哥面试题</a><h1 id="CrawlerTitle" itemprop="name headline">军哥面试题-8.计算机网络篇</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Tiamo</span><time itemprop="dateCreated datePublished" datetime="2022-08-18T04:19:03.000Z" title="发表于 2022-08-18 12:19:03">2022-08-18</time><time itemprop="dateCreated datePublished" datetime="2022-08-18T04:19:03.000Z" title="更新于 2022-08-18 12:19:03">2022-08-18</time></header><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1621606395878-ec50f847-ec2c-451b-885a-0baac77777e0.png?x-oss-process=image/resize,w_746" alt="计算机网络面试题.png"></p>
<h2 id="一、HTTP协议"><a href="#一、HTTP协议" class="headerlink" title="一、HTTP协议"></a>一、HTTP协议</h2><h3 id="1-GET和POST的请求的区别"><a href="#1-GET和POST的请求的区别" class="headerlink" title="1. GET和POST的请求的区别"></a>1. GET和POST的请求的区别</h3><p>Post 和 Get 是 HTTP 请求的两种方法，其区别如下：</p>
<ul>
<li><strong>应用场景：</strong>GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。</li>
<li><strong>是否缓存：</strong>因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。</li>
<li><strong>发送的报文格式：</strong>Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。</li>
<li><strong>安全性：</strong>Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。</li>
<li><strong>请求长度：</strong>浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。</li>
<li><strong>参数类型：</strong>post 的参数传递支持更多的数据类型。</li>
</ul>
<h3 id="2-POST和PUT请求的区别"><a href="#2-POST和PUT请求的区别" class="headerlink" title="2. POST和PUT请求的区别"></a>2. POST和PUT请求的区别</h3><ul>
<li>PUT请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。（可以理解为是<strong>更新数据</strong>）</li>
<li>POST请求是向服务器端发送数据，该请求会改变数据的种类等资源，它会创建新的内容。（可以理解为是<strong>创建数据</strong>）</li>
</ul>
<h3 id="3-常见的HTTP请求头和响应头"><a href="#3-常见的HTTP请求头和响应头" class="headerlink" title="3. 常见的HTTP请求头和响应头"></a>3. 常见的HTTP请求头和响应头</h3><p><strong>HTTP Request Header 常见的请求头：</strong></p>
<ul>
<li>Accept:浏览器能够处理的内容类型</li>
<li>Accept-Charset:浏览器能够显示的字符集</li>
<li>Accept-Encoding：浏览器能够处理的压缩编码</li>
<li>Accept-Language：浏览器当前设置的语言</li>
<li>Connection：浏览器与服务器之间连接的类型</li>
<li>Cookie：当前页面设置的任何Cookie</li>
<li>Host：发出请求的页面所在的域</li>
<li>Referer：发出请求的页面的URL</li>
<li>User-Agent：浏览器的用户代理字符串</li>
</ul>
<p><strong>HTTP Responses Header 常见的响应头：</strong></p>
<ul>
<li>Date：表示消息发送的时间，时间的描述格式由rfc822定义</li>
<li>server:服务器名称</li>
<li>Connection：浏览器与服务器之间连接的类型</li>
<li>Cache-Control：控制HTTP缓存</li>
<li>content-type:表示后面的文档属于什么MIME类型</li>
</ul>
<p>常见的 Content-Type 属性值有以下四种：</p>
<p>（1）application/x-www-form-urlencoded：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。</p>
<p>（2）multipart/form-data：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。</p>
<p>（3）application/json：服务器消息主体是序列化后的 JSON 字符串。</p>
<p>（4）text/xml：该种方式主要用来提交 XML 格式的数据。</p>
<h3 id="4-HTTP状态码304是多好还是少好"><a href="#4-HTTP状态码304是多好还是少好" class="headerlink" title="4. HTTP状态码304是多好还是少好"></a>4. HTTP状态码304是多好还是少好</h3><p>服务器为了提高网站访问速度，对之前访问的部分页面指定缓存机制，当客户端在此对这些页面进行请求，服务器会根据缓存内容判断页面与之前是否相同，若相同便直接返回304，此时客户端调用缓存内容，不必进行二次下载。</p>
<p>状态码304不应该认为是一种错误，而是对客户端<strong>有缓存情况下</strong>服务端的一种响应。</p>
<p>搜索引擎蜘蛛会更加青睐内容源更新频繁的网站。通过特定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。若网站在一定时间内一直处于304的状态，那么蜘蛛可能会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么日积月累，的回访率也会提高。</p>
<p><strong>产生较多304状态码的原因：</strong></p>
<ul>
<li>页面更新周期长或不更新</li>
<li>纯静态页面或强制生成静态html</li>
</ul>
<p><strong>304状态码出现过多会造成以下问题：</strong></p>
<ul>
<li>网站快照停止；</li>
<li>收录减少；</li>
<li>权重下降。</li>
</ul>
<h3 id="5-常见的HTTP请求方法"><a href="#5-常见的HTTP请求方法" class="headerlink" title="5. 常见的HTTP请求方法"></a>5. 常见的HTTP请求方法</h3><ul>
<li>GET: 向服务器获取数据；</li>
<li>POST：将实体提交到指定的资源，通常会造成服务器资源的修改；</li>
<li>PUT：上传文件，更新数据；</li>
<li>DELETE：删除服务器上的对象；</li>
<li>HEAD：获取报文首部，与GET相比，不返回报文主体部分；</li>
<li>OPTIONS：询问支持的请求方法，用来跨域请求；</li>
<li>CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信；</li>
<li>TRACE: 回显服务器收到的请求，主要⽤于测试或诊断。</li>
</ul>
<h3 id="6-OPTIONS请求方法及使用场景"><a href="#6-OPTIONS请求方法及使用场景" class="headerlink" title="6. OPTIONS请求方法及使用场景"></a>6. OPTIONS请求方法及使用场景</h3><p>OPTIONS是除了GET和POST之外的其中一种 HTTP请求方法。</p>
<p>OPTIONS方法是用于请求获得由<code>Request-URI</code>标识的资源在请求/响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以<strong>在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能</strong>。该请求方法的响应不能缓存。</p>
<p>OPTIONS请求方法的<strong>主要用途</strong>有两个：</p>
<ul>
<li>获取服务器支持的所有HTTP请求方法；</li>
<li>用来检查访问权限。例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。</li>
</ul>
<h3 id="7-HTTP-1-0-和-HTTP-1-1-之间有哪些区别？"><a href="#7-HTTP-1-0-和-HTTP-1-1-之间有哪些区别？" class="headerlink" title="7. HTTP 1.0 和 HTTP 1.1 之间有哪些区别？"></a>7. HTTP 1.0 和 HTTP 1.1 之间有哪些区别？</h3><p><strong>HTTP 1.0和 HTTP 1.1</strong> <strong>有以下区别</strong>：</p>
<ul>
<li><strong>连接方面</strong>，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。</li>
<li><strong>资源请求方面</strong>，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
<li><strong>缓存方面</strong>，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li>
<li>http1.1 中<strong>新增了 host 字段</strong>，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。</li>
<li>http1.1 相对于 http1.0 还新增了很多<strong>请求方法</strong>，如 PUT、HEAD、OPTIONS 等。</li>
</ul>
<h3 id="8-HTTP-1-1-和-HTTP-2-0-的区别"><a href="#8-HTTP-1-1-和-HTTP-2-0-的区别" class="headerlink" title="8. HTTP 1.1 和 HTTP 2.0 的区别"></a>8. HTTP 1.1 和 HTTP 2.0 的区别</h3><ul>
<li><strong>二进制协议</strong>：HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。</li>
<li><strong>多路复用：</strong>HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了”队头堵塞”【1】的问题。</li>
<li><strong>数据流：</strong>HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。</li>
<li><strong>头信息压缩：</strong>HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。</li>
<li><strong>服务器推送：</strong>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。</li>
</ul>
<p><strong>【1】队头堵塞：</strong></p>
<blockquote>
<p>队头阻塞是由 HTTP 基本的“请求 - 应答”模型所导致的。HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。</p>
</blockquote>
<h3 id="9-HTTP和HTTPS协议的区别"><a href="#9-HTTP和HTTPS协议的区别" class="headerlink" title="9. HTTP和HTTPS协议的区别"></a>9. HTTP和HTTPS协议的区别</h3><p>HTTP和HTTPS协议的主要区别如下：</p>
<ul>
<li>HTTPS协议需要CA证书，费用较高；而HTTP协议不需要；</li>
<li>HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议；</li>
<li>使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443；</li>
<li>HTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全。</li>
</ul>
<h3 id="10-GET方法URL长度限制的原因"><a href="#10-GET方法URL长度限制的原因" class="headerlink" title="10. GET方法URL长度限制的原因"></a>10. GET方法URL长度限制的原因</h3><p>实际上HTTP协议规范并没有对get方法请求的url长度进行限制，这个限制是特定的浏览器及服务器对它的限制。</p>
<p>IE对URL长度的限制是2083字节(2K+35)。由于IE浏览器对URL长度的允许值是最小的，所以开发过程中，只要URL不超过2083字节，那么在所有浏览器中工作都不会有问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET的长度值 = URL（2083）- （你的Domain+Path）-2（2是get请求中?=两个字符的长度）</span><br></pre></td></tr></table></figure>

<p>下面看一下主流浏览器对get方法中url的长度限制范围：</p>
<ul>
<li>Microsoft Internet Explorer (Browser)：IE浏览器对URL的最大限制为2083个字符，如果超过这个数字，提交按钮没有任何反应。</li>
<li>Firefox (Browser)：对于Firefox浏览器URL的长度限制为 65,536 个字符。</li>
<li>Safari (Browser)：URL最大长度限制为 80,000 个字符。</li>
<li>Opera (Browser)：URL最大长度限制为 190,000 个字符。</li>
<li>Google (chrome)：URL最大长度限制为 8182 个字符。</li>
</ul>
<p>主流的服务器对get方法中url的长度限制范围：</p>
<ul>
<li>Apache (Server)：能接受最大url长度为8192个字符。</li>
<li>Microsoft Internet Information Server(IIS)：能接受最大url的长度为16384个字符。</li>
</ul>
<p>根据上面的数据，可以知道，get方法中的URL长度最长不超过2083个字符，这样所有的浏览器和服务器都可能正常工作。</p>
<h3 id="11-当在浏览器中输入-Google-com-并且按下回车之后发生了什么？"><a href="#11-当在浏览器中输入-Google-com-并且按下回车之后发生了什么？" class="headerlink" title="11. 当在浏览器中输入 Google.com 并且按下回车之后发生了什么？"></a>11. 当在浏览器中输入 Google.com 并且按下回车之后发生了什么？</h3><p>（1）<strong>解析URL：</strong>首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。</p>
<p>（2）<strong>缓存判断：</strong>浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。</p>
<p>（3）<strong>DNS解析：</strong>下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。</p>
<p>（4）<strong>获取MAC地址：</strong>当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。</p>
<p>（5）<strong>TCP三次握手：</strong>下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。</p>
<p>（6）<strong>HTTPS握手：</strong>如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。</p>
<p>（7）<strong>返回数据：</strong>当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。</p>
<p>（8）<strong>页面渲染：</strong>浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。</p>
<p>（9）<strong>TCP四次挥手：</strong>最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。</p>
<h3 id="12-对keep-alive的理解"><a href="#12-对keep-alive的理解" class="headerlink" title="12. 对keep-alive的理解"></a>12. 对keep-alive的理解</h3><p>HTTP1.0 中默认是在每次请求/应答，客户端和服务器都要新建一个连接，完成之后立即断开连接，这就是<strong>短连接</strong>。当使用Keep-Alive模式时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接，这就是<strong>长连接</strong>。其使用方法如下：</p>
<ul>
<li>HTTP1.0版本是默认没有Keep-alive的（也就是默认会发送keep-alive），所以要想连接得到保持，必须手动配置发送<code>Connection: keep-alive</code>字段。若想断开keep-alive连接，需发送<code>Connection:close</code>字段；</li>
<li>HTTP1.1规定了默认保持长连接，数据传输完成了保持TCP连接不断开，等待在同域名下继续用这个通道传输数据。如果需要关闭，需要客户端发送<code>Connection：close</code>首部字段。</li>
</ul>
<p>Keep-Alive的<strong>建立过程</strong>：</p>
<ul>
<li>客户端向服务器在发送请求报文同时在首部添加发送Connection字段</li>
<li>服务器收到请求并处理 Connection字段</li>
<li>服务器回送Connection:Keep-Alive字段给客户端</li>
<li>客户端接收到Connection字段</li>
<li>Keep-Alive连接建立成功</li>
</ul>
<p><strong>服务端自动断开过程（也就是没有keep-alive）</strong>：</p>
<ul>
<li>客户端向服务器只是发送内容报文（不包含Connection字段）</li>
<li>服务器收到请求并处理</li>
<li>服务器返回客户端请求的资源并关闭连接</li>
<li>客户端接收资源，发现没有Connection字段，断开连接</li>
</ul>
<p><strong>客户端请求断开连接过程</strong>：</p>
<ul>
<li>客户端向服务器发送Connection:close字段</li>
<li>服务器收到请求并处理connection字段</li>
<li>服务器回送响应资源并断开连接</li>
<li>客户端接收资源并断开连接</li>
</ul>
<p>开启Keep-Alive的<strong>优点：</strong></p>
<ul>
<li>较少的CPU和内存的使⽤（由于同时打开的连接的减少了）；</li>
<li>允许请求和应答的HTTP管线化； </li>
<li>降低拥塞控制 （TCP连接减少了）； </li>
<li>减少了后续请求的延迟（⽆需再进⾏握⼿）； </li>
<li>报告错误⽆需关闭TCP连；</li>
</ul>
<p>开启Keep-Alive的<strong>缺点</strong>：</p>
<ul>
<li>长时间的Tcp连接容易导致系统资源无效占用，浪费系统资源。</li>
</ul>
<h3 id="13-页面有多张图片，HTTP是怎样的加载表现？"><a href="#13-页面有多张图片，HTTP是怎样的加载表现？" class="headerlink" title="13. 页面有多张图片，HTTP是怎样的加载表现？"></a>13. 页面有多张图片，HTTP是怎样的加载表现？</h3><ul>
<li>在<code>HTTP 1</code>下，浏览器对一个域名下最大TCP连接数为6，所以会请求多次。可以用<strong>多域名部署</strong>解决。这样可以提高同时请求的数目，加快页面图片的获取速度。</li>
<li>在<code>HTTP 2</code>下，可以一瞬间加载出来很多资源，因为，HTTP2支持多路复用，可以在一个TCP连接中发送多个HTTP请求。</li>
</ul>
<h3 id="14-HTTP2的头部压缩算法是怎样的？"><a href="#14-HTTP2的头部压缩算法是怎样的？" class="headerlink" title="14. HTTP2的头部压缩算法是怎样的？"></a>14. HTTP2的头部压缩算法是怎样的？</h3><p>HTTP2的头部压缩是HPACK算法。在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。</p>
<p>具体来说:</p>
<ul>
<li>在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送；</li>
<li>首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新；</li>
<li>每个新的首部键值对要么被追加到当前表的末尾，要么替换表中之前的值。</li>
</ul>
<p>例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1604070508591-32d79893-7e98-40c8-b779-ffb6da42cd1b.png" alt="image"></p>
<h3 id="15-HTTP请求报文的是什么样的？"><a href="#15-HTTP请求报文的是什么样的？" class="headerlink" title="15. HTTP请求报文的是什么样的？"></a>15. HTTP请求报文的是什么样的？</h3><p>请求报⽂有4部分组成: </p>
<ul>
<li>请求⾏ </li>
<li>请求头部 </li>
<li>空⾏</li>
<li>请求体 </li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1615907508156-a82d09e4-00bf-4dc7-a3a3-1ae75481754e.png" alt="image.png"></p>
<p><strong>其中：</strong></p>
<p>（1）请求⾏包括：请求⽅法字段、URL字段、HTTP协议版本字段。它们⽤空格分隔。例如，GET /index.html HTTP/1.1。 </p>
<p>（2）请求头部:请求头部由关键字/值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分隔  </p>
<ul>
<li>User-Agent：产⽣请求的浏览器类型。 </li>
<li>Accept：客户端可识别的内容类型列表。 </li>
<li>Host：请求的主机名，允许多个域名同处⼀个IP地址，即虚拟主机。 </li>
</ul>
<p>（3）请求体: post put等请求携带的数据 </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1615907573585-6651540d-9dee-4b33-a97f-dee1b31f231c.png" alt="image.png"></p>
<h3 id="16-HTTP响应报文的是什么样的？"><a href="#16-HTTP响应报文的是什么样的？" class="headerlink" title="16. HTTP响应报文的是什么样的？"></a>16. HTTP响应报文的是什么样的？</h3><p>请求报⽂有4部分组成: </p>
<ul>
<li>响应⾏ </li>
<li>响应头 </li>
<li>空⾏</li>
<li>响应体 </li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1615907658281-b3a51c98-db27-45be-9b0c-fb2c7665b015.png" alt="image.png"></p>
<ul>
<li>响应⾏：由网络协议版本，状态码和状态码的原因短语组成，例如 HTTP/1.1 200 OK 。 </li>
<li>响应头：响应部⾸组成 </li>
<li>响应体：服务器响应的数据 </li>
</ul>
<h3 id="17-HTTP协议的优点和缺点"><a href="#17-HTTP协议的优点和缺点" class="headerlink" title="17. HTTP协议的优点和缺点"></a>17. HTTP协议的优点和缺点</h3><p>HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性。</p>
<p>HTTP协议具有以下<strong>优点</strong>：</p>
<ul>
<li>支持客户端/服务器模式</li>
<li><strong>简单快速</strong>：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。</li>
<li><strong>无连接</strong>：无连接就是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。</li>
<li><strong>无状态</strong>：HTTP 协议是无状态协议，这里的状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快。</li>
<li><strong>灵活</strong>：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。</li>
</ul>
<p>HTTP协议具有以下<strong>缺点</strong>：</p>
<ul>
<li><strong>无状态：</strong>HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。</li>
<li><strong>明文传输：</strong>协议中的报文使用的是文本形式，这就直接暴露给外界，不安全。</li>
<li><strong>不安全</strong></li>
</ul>
<p>（1）通信使用明文（不加密），内容可能会被窃听；</p>
<p>（2）不验证通信方的身份，因此有可能遭遇伪装；</p>
<p>（3）无法证明报文的完整性，所以有可能已遭篡改；</p>
<h3 id="18-说一下HTTP-3-0"><a href="#18-说一下HTTP-3-0" class="headerlink" title="18. 说一下HTTP 3.0"></a>18. 说一下HTTP 3.0</h3><p>HTTP/3基于UDP协议实现了类似于TCP的多路复用数据流、传输可靠性等功能，这套功能被称为QUIC协议。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/webp/1500604/1604068246276-9b0f553d-3c6e-43a3-8185-8565f9fa1fb4.webp" alt="image"></p>
<ol>
<li>流量控制、传输可靠性功能：QUIC在UDP的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些TCP中的特性。</li>
<li>集成TLS加密功能：目前QUIC使用TLS1.3，减少了握手所花费的RTT数。</li>
<li>多路复用：同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了TCP的队头阻塞问题。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/webp/1500604/1604068246276-5d0a5de2-00db-425e-8b21-0cc4bbb54b24.webp" alt="image"></p>
<ol>
<li>快速握手：由于基于UDP，可以实现使用0 ~ 1个RTT来建立连接。</li>
</ol>
<h3 id="19-HTTP协议的性能怎么样"><a href="#19-HTTP协议的性能怎么样" class="headerlink" title="19. HTTP协议的性能怎么样"></a>19. HTTP协议的性能怎么样</h3><p>HTTP 协议是基于 TCP/IP，并且使用了<strong>请求-应答</strong>的通信模式，所以性能的关键就在这两点里。</p>
<ul>
<li><strong>长连接</strong></li>
</ul>
<p>HTTP协议有两种连接模式，一种是持续连接，一种非持续连接。</p>
<p>（1）非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接。</p>
<p>（2）持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP 连接三次握手时所花费的时间。</p>
<p>对于不同版本的采用不同的连接方式：</p>
<ul>
<li>在HTTP/1.0 每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无畏的 TCP 连接建立和断开，增加了通信开销。该版本使用的非持续的连接，但是可以在请求时，加上 Connection: keep-a live 来要求服务器不要关闭 TCP 连接。</li>
<li>在HTTP/1.1 提出了<strong>长连接</strong>的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。该版本及以后版本默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持同时建立 6 个持久连接。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1604065902281-b98a486c-5442-4d0b-b58d-00aab296ce1a.png" alt="image"></p>
<ul>
<li><strong>管道网络传输</strong></li>
</ul>
<p>HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。</p>
<p>管道（pipeline）网络传输是指：可以在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。但是服务器还是按照顺序回应请求。如果前面的回应特别慢，后面就会有许多请求排队等着。这称为队头堵塞。</p>
<ul>
<li><strong>队头堵塞</strong></li>
</ul>
<p>HTTP 传输的报文必须是一发一收，但是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是HTTP队头阻塞问题。</p>
<p><strong>队头阻塞的解决方案：</strong></p>
<p>（1）并发连接：对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。</p>
<p>（2）域名分片：将域名分出很多二级域名，它们都指向同样的一台服务器，能够并发的长连接数变多，解决了队头阻塞的问题。</p>
<h3 id="20-URL有哪些组成部分"><a href="#20-URL有哪些组成部分" class="headerlink" title="20. URL有哪些组成部分"></a>20. URL有哪些组成部分</h3><p>以下面的URL为例：<strong><a target="_blank" rel="noopener" href="http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name">http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</a></strong></p>
<p>从上面的URL可以看出，一个完整的URL包括以下几部分：</p>
<ul>
<li><strong>协议部分</strong>：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符；</li>
<li><strong>域名部分</strong>：该URL的域名部分为“<a target="_blank" rel="noopener" href="http://www.aspxfans.com”.一个url中,也可以使用ip地址作为域名使用/">www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用</a></li>
<li><strong>端口部分</strong>：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口（HTTP协议默认端口是80，HTTPS协议默认端口是443）；</li>
<li><strong>虚拟目录部分</strong>：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”；</li>
<li><strong>文件名部分</strong>：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名；</li>
<li><strong>锚部分</strong>：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分；</li>
<li><strong>参数部分</strong>：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</li>
</ul>
<h3 id="21-与缓存相关的HTTP请求头有哪些"><a href="#21-与缓存相关的HTTP请求头有哪些" class="headerlink" title="21. 与缓存相关的HTTP请求头有哪些"></a>21. 与缓存相关的HTTP请求头有哪些</h3><p>强缓存：</p>
<ul>
<li>Expires</li>
<li>Cache-Control</li>
</ul>
<p>协商缓存：</p>
<ul>
<li>Etag、If-None-Match</li>
<li>Last-Modified、If-Modified-Since</li>
</ul>
<h2 id="二、HTTPS协议"><a href="#二、HTTPS协议" class="headerlink" title="二、HTTPS协议"></a>二、HTTPS协议</h2><h3 id="1-什么是HTTPS协议？"><a href="#1-什么是HTTPS协议？" class="headerlink" title="1. 什么是HTTPS协议？"></a>1. 什么是HTTPS协议？</h3><p>超文本传输安全协议（Hypertext Transfer Protocol Secure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，利用SSL/TLS来加密数据包。HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603965685749-8cc21a1b-4277-42b1-aeed-18978c1cdb95.png?x-oss-process=image/resize,w_1500" alt="image"></p>
<p>HTTP协议采用<strong>明文传输</strong>信息，存在<strong>信息窃听</strong>、<strong>信息篡改</strong>和<strong>信息劫持</strong>的风险，而协议TLS/SSL具有<strong>身份验证</strong>、<strong>信息加密</strong>和<strong>完整性校验</strong>的功能，可以避免此类问题发生。</p>
<p>安全层的主要职责就是<strong>对发起的HTTP请求的数据进行加密操作</strong> 和 <strong>对接收到的HTTP的内容进行解密操作</strong>。</p>
<h3 id="2-TLS-SSL的工作原理"><a href="#2-TLS-SSL的工作原理" class="headerlink" title="2. TLS/SSL的工作原理"></a>2. TLS/SSL的工作原理</h3><p><strong>TLS/SSL</strong>全称<strong>安全传输层协议</strong>（Transport Layer Security）, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。</p>
<p>TLS/SSL的功能实现主要依赖三类基本算法：<strong>散列函数hash</strong>、<strong>对称加密</strong>、<strong>非对称加密</strong>。这三类算法的作用如下：</p>
<ul>
<li>基于散列函数验证信息的完整性</li>
<li>对称加密算法采用协商的秘钥对数据加密</li>
<li>非对称加密实现身份认证和秘钥协商</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603965685769-63a91dae-936d-42d3-8571-577cefa11e33.png" alt="image"></p>
<h4 id="（1）散列函数hash"><a href="#（1）散列函数hash" class="headerlink" title="（1）散列函数hash"></a>（1）散列函数hash</h4><p>常见的散列函数有MD5、SHA1、SHA256。该函数的特点是单向不可逆，对输入数据非常敏感，输出的长度固定，任何数据的修改都会改变散列函数的结果，可以用于防止信息篡改并验证数据的完整性。</p>
<p><strong>特点：</strong>在信息传输过程中，散列函数不能三都实现信息防篡改，由于传输是明文传输，中间人可以修改信息后重新计算信息的摘要，所以需要对传输的信息和信息摘要进行加密。</p>
<h4 id="（2）对称加密"><a href="#（2）对称加密" class="headerlink" title="（2）对称加密"></a>（2）对称加密</h4><p>对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。</p>
<p>常见的对称加密算法有AES-CBC、DES、3DES、AES-GCM等。相同的秘钥可以用于信息的加密和解密。掌握秘钥才能获取信息，防止信息窃听，其通讯方式是一对一。</p>
<p><strong>特点：</strong>对称加密的优势就是信息传输使用一对一，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和N个客户端通信，需要维持N个密码记录且不能修改密码。</p>
<h4 id="（3）非对称加密"><a href="#（3）非对称加密" class="headerlink" title="（3）非对称加密"></a>（3）非对称加密</h4><p>非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。</p>
<p>常见的非对称加密算法有RSA、ECC、DH等。秘钥成对出现，一般称为公钥（公开）和私钥（保密）。公钥加密的信息只有私钥可以解开，私钥加密的信息只能公钥解开，因此掌握公钥的不同客户端之间不能相互解密信息，只能和服务器进行加密通信，服务器可以实现一对多的的通信，客户端也可以用来验证掌握私钥的服务器的身份。</p>
<p><strong>特点：</strong>非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密的速度慢。</p>
<p>综合上述算法特点，TLS/SSL的工作方式就是客户端使用非对称加密与服务器进行通信，实现身份的验证并协商对称加密使用的秘钥。对称加密算法采用协商秘钥对信息以及信息摘要进行加密通信，不同节点之间采用的对称秘钥不同，从而保证信息只能通信双方获取。这样就解决了两个方法各自存在的问题。</p>
<h3 id="3-数字证书是什么？"><a href="#3-数字证书是什么？" class="headerlink" title="3. 数字证书是什么？"></a>3. 数字证书是什么？</h3><p>现在的方法也不一定是安全的，因为没有办法确定得到的公钥就一定是安全的公钥。可能存在一个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而自己还不知道。为了解决这样的问题，可以使用数字证书。</p>
<p>首先使用一种 Hash 算法来对公钥和其他信息进行加密，生成一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和生成的摘要进行对比，就能发现得到的信息是否被更改了。</p>
<p>这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样才能保证数据的安全。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603965685765-ffc9a525-ccad-43f0-bb25-8e17281d68fe.png" alt="image"></p>
<h3 id="4-HTTPS通信（握手）过程"><a href="#4-HTTPS通信（握手）过程" class="headerlink" title="4. HTTPS通信（握手）过程"></a>4. HTTPS通信（握手）过程</h3><p>HTTPS的通信过程如下：</p>
<ol>
<li>客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。</li>
<li>服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。</li>
<li>客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服 务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。</li>
<li>服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。</li>
<li>客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。</li>
</ol>
<h3 id="5-HTTPS的特点"><a href="#5-HTTPS的特点" class="headerlink" title="5. HTTPS的特点"></a>5. HTTPS的特点</h3><p>HTTPS的<strong>优点</strong>如下：</p>
<ul>
<li>使用HTTPS协议可以认证用户和服务器，确保数据发送到正确的客户端和服务器；</li>
<li>使用HTTPS协议可以进行加密传输、身份认证，通信更加安全，防止数据在传输过程中被窃取、修改，确保数据安全性；</li>
<li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对的安全，但是大幅增加了中间人攻击的成本；</li>
</ul>
<p>HTTPS的<strong>缺点</strong>如下：</p>
<ul>
<li>HTTPS需要做服务器和客户端双方的加密个解密处理，耗费更多服务器资源，过程复杂；</li>
<li>HTTPS协议握手阶段比较费时，增加页面的加载时间；</li>
<li>SSL证书是收费的，功能越强大的证书费用越高；</li>
<li>HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本；</li>
<li>SSL证书需要绑定IP，不能再同一个IP上绑定多个域名。</li>
</ul>
<h3 id="6-HTTPS是如何保证安全的？"><a href="#6-HTTPS是如何保证安全的？" class="headerlink" title="6. HTTPS是如何保证安全的？"></a>6. <strong>HTTPS</strong>是如何保证安全的？</h3><p>先理解两个概念：</p>
<ul>
<li>对称加密：即通信的双⽅都使⽤同⼀个秘钥进⾏加解密，对称加密虽然很简单性能也好，但是⽆法解决⾸次把秘钥发给对⽅的问题，很容易被⿊客拦截秘钥。 </li>
<li>⾮对称加密： </li>
</ul>
<p>\1. 私钥 + 公钥= 密钥对 </p>
<p>\2. 即⽤私钥加密的数据,只有对应的公钥才能解密,⽤公钥加密的数据,只有对应的私钥才能解密 </p>
<p>\3. 因为通信双⽅的⼿⾥都有⼀套⾃⼰的密钥对,通信之前双⽅会先把⾃⼰的公钥都先发给对⽅ </p>
<p>\4. 然后对⽅再拿着这个公钥来加密数据响应给对⽅,等到到了对⽅那⾥,对⽅再⽤⾃⼰的私钥进⾏解密 </p>
<p>⾮对称加密虽然安全性更⾼，但是带来的问题就是速度很慢，影响性能。 </p>
<p><strong>解决⽅案：</strong> </p>
<p>结合两种加密⽅式，将对称加密的密钥使⽤⾮对称加密的公钥进⾏加密，然后发送出去，接收⽅使⽤私钥进⾏解密得到对称加密的密钥，然后双⽅可以使⽤对称加密来进⾏沟通。 </p>
<p>此时⼜带来⼀个问题，中间⼈问题： </p>
<p>如果此时在客户端和服务器之间存在⼀个中间⼈,这个中间⼈只需要把原本双⽅通信互发的公钥,换成⾃⼰的公钥,这样中间⼈就可以轻松解密通信双⽅所发送的所有数据。 </p>
<p>所以这个时候需要⼀个安全的第三⽅颁发证书（CA），证明身份的身份，防⽌被中间⼈攻击。 证书中包括：签发者、证书⽤途、使⽤者公钥、使⽤者私钥、使⽤者的HASH算法、证书到期时间等。</p>
<p>但是问题来了，如果中间⼈篡改了证书，那么身份证明是不是就⽆效了？这个证明就⽩买了，这个时候需要⼀个新的技术，数字签名。 </p>
<p>数字签名就是⽤CA⾃带的HASH算法对证书的内容进⾏HASH得到⼀个摘要，再⽤CA的私钥加密，最终组成数字签名。当别⼈把他的证书发过来的时候,我再⽤同样的Hash算法,再次⽣成消息摘要，然后⽤CA的公钥对数字签名解密,得到CA创建的消息摘要,两者⼀⽐,就知道中间有没有被⼈篡改了。这个时候就能最⼤程度保证通信的安全了。 </p>
<h2 id="三、HTTP状态码"><a href="#三、HTTP状态码" class="headerlink" title="三、HTTP状态码"></a>三、HTTP状态码</h2><p>状态码的类别：</p>
<table>
<thead>
<tr>
<th><strong>类别</strong></th>
<th><strong>原因</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1xx</td>
<td>Informational(信息性状态码)</td>
<td>接受的请求正在处理</td>
</tr>
<tr>
<td>2xx</td>
<td>Success(成功状态码)</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3xx</td>
<td>Redirection(重定向状态码)</td>
<td>需要进行附加操作一完成请求</td>
</tr>
<tr>
<td>4xx</td>
<td>Client Error (客户端错误状态码)</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5xx</td>
<td>Server Error(服务器错误状态码)</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
<h3 id="1-2XX-Success-成功状态码"><a href="#1-2XX-Success-成功状态码" class="headerlink" title="1. 2XX (Success 成功状态码)"></a>1. 2XX (Success 成功状态码)</h3><p>状态码2XX表示请求被正常处理了。</p>
<h4 id="（1）200-OK"><a href="#（1）200-OK" class="headerlink" title="（1）200 OK"></a>（1）200 OK</h4><p>200 OK表示客户端发来的请求被服务器端正常处理了。</p>
<h4 id="（2）204-No-Content"><a href="#（2）204-No-Content" class="headerlink" title="（2）204 No Content"></a>（2）204 No Content</h4><p>该状态码表示客户端发送的请求已经在服务器端正常处理了，但是没有返回的内容，响应报文中不包含实体的主体部分。一般在只需要从客户端往服务器端发送信息，而服务器端不需要往客户端发送内容时使用。</p>
<h4 id="（3）206-Partial-Content"><a href="#（3）206-Partial-Content" class="headerlink" title="（3）206 Partial Content"></a>（3）206 Partial Content</h4><p>该状态码表示客户端进行了范围请求，而服务器端执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。</p>
<h3 id="2-3XX-Redirection-重定向状态码"><a href="#2-3XX-Redirection-重定向状态码" class="headerlink" title="2. 3XX (Redirection 重定向状态码)"></a>2. 3XX (Redirection 重定向状态码)</h3><p>3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。</p>
<h4 id="（1）301-Moved-Permanently"><a href="#（1）301-Moved-Permanently" class="headerlink" title="（1）301 Moved Permanently"></a>（1）301 Moved Permanently</h4><p><strong>永久重定向。</strong></p>
<p>该状态码表示请求的资源已经被分配了新的 URI，以后应使用资源指定的 URI。新的 URI 会在 HTTP 响应头中的 Location 首部字段指定。若用户已经把原来的URI保存为书签，此时会按照 Location 中新的URI重新保存该书签。同时，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>当我们想换个域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名。其实也是告诉搜索引擎收录的域名需要对新的域名进行收录。</li>
<li>在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。</li>
</ul>
<h4 id="（2）302-Found"><a href="#（2）302-Found" class="headerlink" title="（2）302 Found"></a>（2）302 Found</h4><p><strong>临时重定向。</strong></p>
<p>该状态码表示请求的资源被分配到了新的 URI，希望用户（本次）能使用新的 URI 访问资源。和 301 Moved Permanently 状态码相似，但是 302 代表的资源不是被永久重定向，只是临时性质的。也就是说已移动的资源对应的 URI 将来还有可能发生改变。若用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。同时，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>当我们在做活动时，登录到首页自动重定向，进入活动页面。</li>
<li>未登陆的用户访问用户中心重定向到登录页面。</li>
<li>访问404页面重新定向到首页。</li>
</ul>
<h4 id="（3）303-See-Other"><a href="#（3）303-See-Other" class="headerlink" title="（3）303 See Other"></a>（3）303 See Other</h4><p>该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。</p>
<p>303 状态码和 302 Found 状态码有着相似的功能，但是 303 状态码明确表示客户端应当采用 GET 方法获取资源。</p>
<p>303 状态码通常作为 PUT 或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 GET。</p>
<p>注意：</p>
<ul>
<li>当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成GET，并删除请求报文内的主体，之后请求会再次自动发送。</li>
<li>301、302 标准是禁止将 POST 方法变成 GET方法的，但实际大家都会这么做。</li>
</ul>
<h4 id="（4）304-Not-Modified"><a href="#（4）304-Not-Modified" class="headerlink" title="（4）304 Not Modified"></a>（4）304 Not Modified</h4><p><strong>浏览器缓存相关。</strong></p>
<p>该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。</p>
<p>带条件的请求（Http 条件请求）：使用 Get方法 请求，请求报文中包含（<code>if-match</code>、<code>if-none-match</code>、<code>if-modified-since</code>、<code>if-unmodified-since</code>、<code>if-range</code>）中任意首部。</p>
<p>状态码304并不是一种错误，而是告诉客户端有缓存，直接使用缓存中的数据。返回页面的只有头部信息，是没有内容部分的，这样在一定程度上提高了网页的性能。</p>
<h4 id="（5）307-Temporary-Redirect"><a href="#（5）307-Temporary-Redirect" class="headerlink" title="（5）307 Temporary Redirect"></a>（5）307 Temporary Redirect</h4><p><strong>307表示临时重定向。</strong>该状态码与 302 Found 有着相同含义，尽管 302 标准禁止 POST 变成 GET，但是实际使用时还是这样做了。</p>
<p>307 会遵守浏览器标准，<strong>不会从 POST 变成 GET</strong>。但是对于处理请求的行为时，不同浏览器还是会出现不同的情况。规范要求浏览器继续向 Location 的地址 POST 内容。规范要求浏览器继续向 Location 的地址 POST 内容。</p>
<h3 id="3-4XX-Client-Error-客户端错误状态码"><a href="#3-4XX-Client-Error-客户端错误状态码" class="headerlink" title="3. 4XX (Client Error 客户端错误状态码)"></a>3. 4XX (Client Error 客户端错误状态码)</h3><p>4XX 的响应结果表明客户端是发生错误的原因所在。</p>
<h4 id="（1）400-Bad-Request"><a href="#（1）400-Bad-Request" class="headerlink" title="（1）400 Bad Request"></a>（1）400 Bad Request</h4><p>该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。</p>
<h4 id="（2）401-Unauthorized"><a href="#（2）401-Unauthorized" class="headerlink" title="（2）401 Unauthorized"></a>（2）401 Unauthorized</h4><p>该状态码表示发送的请求需要有通过 HTTP 认证(BASIC 认证、DIGEST 认证)的认证信息。若之前已进行过一次请求，则表示用户认证失败</p>
<p>返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询(challenge)用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。</p>
<p>以下情况会出现401：</p>
<ul>
<li>401.1 - 登录失败。</li>
<li>401.2 - 服务器配置导致登录失败。</li>
<li>401.3 - 由于 ACL 对资源的限制而未获得授权。</li>
<li>401.4 - 筛选器授权失败。</li>
<li>401.5 - ISAPI/CGI 应用程序授权失败。</li>
<li>401.7 - 访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。</li>
</ul>
<h4 id="（3）403-Forbidden"><a href="#（3）403-Forbidden" class="headerlink" title="（3）403 Forbidden"></a>（3）403 Forbidden</h4><p>该状态码表明请求资源的访问被服务器拒绝了，服务器端没有必要给出详细理由，但是可以在响应报文实体的主体中进行说明。进入该状态后，不能再继续进行验证。该访问是永久禁止的，并且与应用逻辑密切相关。</p>
<p>IIS 定义了许多不同的 403 错误，它们指明更为具体的错误原因：</p>
<ul>
<li>403.1 - 执行访问被禁止。</li>
<li>403.2 - 读访问被禁止。</li>
<li>403.3 - 写访问被禁止。</li>
<li>403.4 - 要求 SSL。</li>
<li>403.5 - 要求 SSL 128。</li>
<li>403.6 - IP 地址被拒绝。</li>
<li>403.7 - 要求客户端证书。</li>
<li>403.8 - 站点访问被拒绝。</li>
<li>403.9 - 用户数过多。</li>
<li>403.10 - 配置无效。</li>
<li>403.11 - 密码更改。</li>
<li>403.12 - 拒绝访问映射表。</li>
<li>403.13 - 客户端证书被吊销。</li>
<li>403.14 - 拒绝目录列表。</li>
<li>403.15 - 超出客户端访问许可。</li>
<li>403.16 - 客户端证书不受信任或无效。</li>
<li>403.17 - 客户端证书已过期或尚未生效</li>
<li>403.18 - 在当前的应用程序池中不能执行所请求的 URL。这个错误代码为 IIS 6.0 所专用。</li>
<li>403.19 - 不能为这个应用程序池中的客户端执行 CGI。这个错误代码为 IIS 6.0 所专用。</li>
<li>403.20 - Passport 登录失败。这个错误代码为 IIS 6.0 所专用。</li>
</ul>
<h4 id="（4）404-Not-Found"><a href="#（4）404-Not-Found" class="headerlink" title="（4）404 Not Found"></a>（4）404 Not Found</h4><p>该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。</p>
<p>以下情况会出现404：</p>
<ul>
<li>404.0 -（无） – 没有找到文件或目录。</li>
<li>404.1 - 无法在所请求的端口上访问 Web 站点。</li>
<li>404.2 - Web 服务扩展锁定策略阻止本请求。</li>
<li>404.3 - MIME 映射策略阻止本请求。</li>
</ul>
<h4 id="（5）405-Method-Not-Allowed"><a href="#（5）405-Method-Not-Allowed" class="headerlink" title="（5）405 Method Not Allowed"></a>（5）405 Method Not Allowed</h4><p>该状态码表示客户端请求的方法虽然能被服务器识别，但是服务器禁止使用该方法。GET 和 HEAD 方法，服务器应该总是允许客户端进行访问。客户端可以通过 OPTIONS 方法（预检）来查看服务器允许的访问方法, 如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Methods: GET,HEAD,PUT,PATCH,POST,DELETE</span><br></pre></td></tr></table></figure>

<h3 id="4-5XX-Server-Error-服务器错误状态码"><a href="#4-5XX-Server-Error-服务器错误状态码" class="headerlink" title="4. 5XX (Server Error 服务器错误状态码)"></a>4. 5XX (Server Error 服务器错误状态码)</h3><p>5XX 的响应结果表明服务器本身发生错误.</p>
<h4 id="（1）500-Internal-Server-Error"><a href="#（1）500-Internal-Server-Error" class="headerlink" title="（1）500 Internal Server Error"></a>（1）500 Internal Server Error</h4><p>该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。</p>
<h4 id="（2）502-Bad-Gateway"><a href="#（2）502-Bad-Gateway" class="headerlink" title="（2）502 Bad Gateway"></a>（2）502 Bad Gateway</h4><p>该状态码表明扮演网关或代理角色的服务器，从上游服务器中接收到的响应是无效的。注意，502 错误通常不是客户端能够修复的，而是需要由途经的 Web 服务器或者代理服务器对其进行修复。以下情况会出现502：</p>
<ul>
<li>502.1 - CGI （通用网关接口）应用程序超时。</li>
<li>502.2 - CGI （通用网关接口）应用程序出错。</li>
</ul>
<h4 id="（3）503-Service-Unavailable"><a href="#（3）503-Service-Unavailable" class="headerlink" title="（3）503 Service Unavailable"></a>（3）503 Service Unavailable</h4><p>该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>服务器停机维护时，主动用503响应请求；</li>
<li>nginx 设置限速，超过限速，会返回503。</li>
</ul>
<h4 id="（4）504-Gateway-Timeout"><a href="#（4）504-Gateway-Timeout" class="headerlink" title="（4）504 Gateway Timeout"></a>（4）504 Gateway Timeout</h4><p>该状态码表示网关或者代理的服务器无法在规定的时间内获得想要的响应。他是HTTP 1.1中新加入的。</p>
<p>使用场景：代码执行时间超时，或者发生了死循环。</p>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p><strong>（1）2XX 成功</strong></p>
<ul>
<li>200 OK，表示从客户端发来的请求在服务器端被正确处理</li>
<li>204 No content，表示请求成功，但响应报文不含实体的主体部分</li>
<li>205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容</li>
<li>206 Partial Content，进行范围请求</li>
</ul>
<p><strong>（2）3XX 重定向</strong></p>
<ul>
<li>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL</li>
<li>302 found，临时性重定向，表示资源临时被分配了新的 URL</li>
<li>303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源</li>
<li>304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况</li>
<li>307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</li>
</ul>
<p><strong>（3）4XX 客户端错误</strong></p>
<ul>
<li>400 bad request，请求报文存在语法错误</li>
<li>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</li>
<li>403 forbidden，表示对请求资源的访问被服务器拒绝</li>
<li>404 not found，表示在服务器上没有找到请求的资源</li>
</ul>
<p><strong>（4）5XX 服务器错误</strong></p>
<ul>
<li>500 internal sever error，表示服务器端在执行请求时发生了错误</li>
<li>501 Not Implemented，表示服务器不支持当前请求所需要的某个功能</li>
<li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</li>
</ul>
<h3 id="6-同样是重定向，307，303，302的区别？"><a href="#6-同样是重定向，307，303，302的区别？" class="headerlink" title="6. 同样是重定向，307，303，302的区别？"></a>6. 同样是重定向，<strong>307</strong>，<strong>303</strong>，<strong>302</strong>的区别？</h3><p>302是http1.0的协议状态码，在http1.1版本的时候为了细化302状态码⼜出来了两个303和307。 303明确表示客户端应当采⽤get⽅法获取资源，他会把POST请求变为GET请求进⾏重定向。 307会遵照浏览器标准，不会从post变为get。 </p>
<h2 id="四、DNS协议介绍"><a href="#四、DNS协议介绍" class="headerlink" title="四、DNS协议介绍"></a>四、DNS协议介绍</h2><h3 id="1-DNS-协议是什么"><a href="#1-DNS-协议是什么" class="headerlink" title="1. DNS 协议是什么"></a>1. DNS 协议是什么</h3><p><strong>概念</strong>： DNS 是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p>
<p><strong>作用</strong>： 将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址。</p>
<h3 id="2-DNS同时使用TCP和UDP协议？"><a href="#2-DNS同时使用TCP和UDP协议？" class="headerlink" title="2. DNS同时使用TCP和UDP协议？"></a>2. DNS同时使用TCP和UDP协议？</h3><p><strong>DNS占用53号端口，同时使用TCP和UDP协议。</strong></p>
<p>（1）在区域传输的时候使用TCP协议</p>
<ul>
<li>辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。</li>
<li>TCP是一种可靠连接，保证了数据的准确性。</li>
</ul>
<p>（2）在域名解析的时候使用UDP协议</p>
<ul>
<li>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。</li>
</ul>
<h3 id="3-DNS完整的查询过程"><a href="#3-DNS完整的查询过程" class="headerlink" title="3. DNS完整的查询过程"></a>3. DNS完整的查询过程</h3><p>DNS服务器解析域名的过程：</p>
<ul>
<li>首先会在<strong>浏览器的缓存</strong>中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步</li>
<li>将请求发送给<strong>本地DNS服务器</strong>，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步</li>
<li>本地DNS服务器向<strong>根域名服务器</strong>发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址</li>
<li>本地DNS服务器向<strong>顶级域名服务器</strong>发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址</li>
<li>本地DNS服务器向<strong>权威域名服务器</strong>发送请求，域名服务器返回对应的结果</li>
<li>本地DNS服务器将返回结果保存在缓存中，便于下次使用</li>
<li>本地DNS服务器将返回结果返回给浏览器</li>
</ul>
<p>比如要查询 <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> 的 IP 地址，首先会在浏览器的缓存中查找是否有该域名的缓存，如果不存在就将请求发送到本地的 DNS 服务器中，本地DNS服务器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名服务器的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com 的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。然后本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表。</p>
<h3 id="4-迭代查询与递归查询"><a href="#4-迭代查询与递归查询" class="headerlink" title="4. 迭代查询与递归查询"></a>4. 迭代查询与递归查询</h3><p>实际上，DNS解析是一个包含迭代查询和递归查询的过程。</p>
<ul>
<li><strong>递归查询</strong>指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。</li>
<li><strong>迭代查询</strong>指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。</li>
</ul>
<p>一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我 们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次 查询的结果，下一级的查询由本地 DNS 服务器自己进行。</p>
<h3 id="5-DNS-记录和报文"><a href="#5-DNS-记录和报文" class="headerlink" title="5. DNS 记录和报文"></a>5. DNS 记录和报文</h3><p>DNS 服务器中以资源记录的形式存储信息，每一个 DNS 响应报文一般包含多条资源记录。一条资源记录的具体的格式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（Name，Value，Type，TTL）</span><br></pre></td></tr></table></figure>

<p>其中 TTL 是资源记录的生存时间，它定义了资源记录能够被其他的 DNS 服务器缓存多长时间。</p>
<p>常用的一共有四种 Type 的值，分别是 A、NS、CNAME 和 MX ，不同 Type 的值，对应资源记录代表的意义不同：</p>
<ul>
<li>如果 Type = A，则 Name 是主机名，Value 是主机名对应的 IP 地址。因此一条记录为 A 的资源记录，提供了标 准的主机名到 IP 地址的映射。</li>
<li>如果 Type = NS，则 Name 是个域名，Value 是负责该域名的 DNS 服务器的主机名。这个记录主要用于 DNS 链式 查询时，返回下一级需要查询的 DNS 服务器的信息。</li>
<li>如果 Type = CNAME，则 Name 为别名，Value 为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名 对应的规范主机名，从而告诉查询主机去查询这个主机名的 IP 地址。主机别名主要是为了通过给一些复杂的主机名提供 一个便于记忆的简单的别名。</li>
<li>如果 Type = MX，则 Name 为一个邮件服务器的别名，Value 为邮件服务器的规范主机名。它的作用和 CNAME 是一 样的，都是为了解决规范主机名不利于记忆的缺点。</li>
</ul>
<h2 id="五、网络模型"><a href="#五、网络模型" class="headerlink" title="五、网络模型"></a>五、网络模型</h2><h3 id="1-OSI七层模型"><a href="#1-OSI七层模型" class="headerlink" title="1. OSI七层模型"></a>1. OSI七层模型</h3><p><code>ISO</code>为了更好的使网络应用更为普及，推出了<code>OSI</code>参考模型。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/webp/1500604/1604024701811-7ac177bc-d649-45b8-8646-53af8f18a0de.webp" alt="image"></p>
<h4 id="（1）应用层"><a href="#（1）应用层" class="headerlink" title="（1）应用层"></a>（1）应用层</h4><p><code>OSI</code>参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：<code>HTTP</code>，<code>HTTPS</code>，<code>FTP</code>，<code>POP3</code>、<code>SMTP</code>等。</p>
<ul>
<li>在客户端与服务器中经常会有数据的请求，这个时候就是会用到<code>http(hyper text transfer protocol)(超文本传输协议)</code>或者<code>https</code>.在后端设计数据接口时，我们常常使用到这个协议。</li>
<li><code>FTP</code>是文件传输协议，在开发过程中，个人并没有涉及到，但是我想，在一些资源网站，比如<code>百度网盘``迅雷</code>应该是基于此协议的。</li>
<li><code>SMTP</code>是<code>simple mail transfer protocol（简单邮件传输协议）</code>。在一个项目中，在用户邮箱验证码登录的功能时，使用到了这个协议。</li>
</ul>
<h4 id="（2）表示层"><a href="#（2）表示层" class="headerlink" title="（2）表示层"></a>（2）表示层</h4><p>表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。</p>
<p>在项目开发中，为了方便数据传输，可以使用<code>base64</code>对数据进行编解码。如果按功能来划分，<code>base64</code>应该是工作在表示层。</p>
<h4 id="（3）会话层"><a href="#（3）会话层" class="headerlink" title="（3）会话层"></a>（3）会话层</h4><p>会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。</p>
<h4 id="（4）传输层"><a href="#（4）传输层" class="headerlink" title="（4）传输层"></a>（4）传输层</h4><p>传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，<code>TCP</code> <code>UDP</code>就是在这一层。端口号既是这里的“端”。</p>
<h4 id="（5）网络层"><a href="#（5）网络层" class="headerlink" title="（5）网络层"></a>（5）网络层</h4><p>本层通过<code>IP</code>寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的<code>IP</code>层。这一层就是我们经常说的<code>IP</code>协议层。<code>IP</code>协议是<code>Internet</code>的基础。我们可以这样理解，网络层规定了数据包的传输路线，而传输层则规定了数据包的传输方式。</p>
<h4 id="（6）数据链路层"><a href="#（6）数据链路层" class="headerlink" title="（6）数据链路层"></a>（6）数据链路层</h4><p>将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。</p>
<p>网络层与数据链路层的对比，通过上面的描述，我们或许可以这样理解，网络层是规划了数据包的传输路线，而数据链路层就是传输路线。不过，在数据链路层上还增加了差错控制的功能。</p>
<h4 id="（7）物理层"><a href="#（7）物理层" class="headerlink" title="（7）物理层"></a>（7）物理层</h4><p>实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。</p>
<p><strong>OSI七层模型通信特点：对等通信</strong></p>
<p>对等通信，为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信。</p>
<h3 id="2-TCP-IP五层协议"><a href="#2-TCP-IP五层协议" class="headerlink" title="2. TCP/IP五层协议"></a>2. TCP/IP五层协议</h3><p><code>TCP/IP</code>五层协议和<code>OSI</code>的七层协议对应关系如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1604025489154-966a96f5-1c8e-4d03-b9f9-f51250f63a22.png" alt="image"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1604025489154-966a96f5-1c8e-4d03-b9f9-f51250f63a22.png" alt="image"></p>
<ul>
<li><p>**应用层 (application layer)**：直接为应用进程提供服务。应用层协议定义的是应用进程间通讯和交互的规则，不同的应用有着不同的应用层协议，如 HTTP协议（万维网服务）、FTP协议（文件传输）、SMTP协议（电子邮件）、DNS（域名查询）等。</p>
</li>
<li><p>**传输层 (transport layer)**：有时也译为运输层，它负责为两台主机中的进程提供通信服务。该层主要有以下两种协议：</p>
</li>
<li><ul>
<li>传输控制协议 (Transmission Control Protocol，TCP)：提供面向连接的、可靠的数据传输服务，数据传输的基本单位是报文段（segment）；</li>
<li>用户数据报协议 (User Datagram Protocol，UDP)：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输的基本单位是用户数据报。</li>
</ul>
</li>
<li><p>**网络层 (internet layer)**：有时也译为网际层，它负责为两台主机提供通信服务，并通过选择合适的路由将数据传递到目标主机。</p>
</li>
<li><p>**数据链路层 (data link layer)**：负责将网络层交下来的 IP 数据报封装成帧，并在链路的两个相邻节点间传送帧，每一帧都包含数据和必要的控制信息（如同步信息、地址信息、差错控制等）。</p>
</li>
<li><p>**物理层 (physical Layer)**：确保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境。</p>
</li>
</ul>
<p>从上图中可以看出，<code>TCP/IP</code>模型比<code>OSI</code>模型更加简洁，它把<code>应用层/表示层/会话层</code>全部整合为了<code>应用层</code>。</p>
<p>在每一层都工作着不同的设备，比如我们常用的交换机就工作在数据链路层的，一般的路由器是工作在网络层的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/webp/1500604/1604025001463-47398363-0ab1-4bcf-b247-5d3d76ce117a.webp" alt="image"></p>
<p>在每一层实现的协议也各不同，即每一层的服务也不同，下图列出了每层主要的传输协议：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/webp/1500604/1604025001203-7b104c36-1453-475e-a282-ff2e9cb19e2c.webp" alt="image"></p>
<p>同样，<code>TCP/IP</code>五层协议的通信方式也是对等通信：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1604065635582-1a4e62ba-bdfa-45db-8a56-0302ff9a8020.png" alt="image.png"></p>
<h2 id="六、TCP与UDP"><a href="#六、TCP与UDP" class="headerlink" title="六、TCP与UDP"></a>六、TCP与UDP</h2><h3 id="1-TCP-和-UDP的概念及特点"><a href="#1-TCP-和-UDP的概念及特点" class="headerlink" title="1. TCP 和 UDP的概念及特点"></a>1. TCP 和 UDP的概念及特点</h3><p>TCP 和 UDP都是传输层协议，他们都属于TCP/IP协议族：</p>
<p><strong>（1）UDP</strong></p>
<p>UDP的全称是<strong>用户数据报协议</strong>，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p>
<p>它的特点如下：</p>
<p><strong>1）面向无连接</strong></p>
<p>首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。</p>
<p>具体来说就是：</p>
<ul>
<li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li>
<li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li>
</ul>
<p><strong>2）有单播，多播，广播的功能</strong></p>
<p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p>
<p><strong>3）面向报文</strong></p>
<p>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p>
<p><strong>4）不可靠性</strong></p>
<p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。</p>
<p>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p>
<p>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p>
<p><strong>5）头部开销小，传输数据报文时是很高效的。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1604023358917-72134998-53bd-4d9c-b71f-7a762dff31a9.png" alt="image"></p>
<p>UDP 头部包含了以下几个数据：</p>
<ul>
<li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li>
<li>整个数据报文的长度</li>
<li>整个数据报文的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误</li>
</ul>
<p>因此 UDP 的头部开销小，只有8字节，相比 TCP 的至少20字节要少得多，在传输数据报文时是很高效的。</p>
<p><strong>（2）TCP</strong></p>
<p>TCP的全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP 是面向连接的、可靠的流协议（流就是指不间断的数据结构）。</p>
<p>它有以下几个特点：</p>
<p><strong>1）面向连接</strong></p>
<p>面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</p>
<p><strong>2）仅支持单播传输</strong></p>
<p>每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</p>
<p><strong>3）面向字节流</strong></p>
<p>TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</p>
<p><strong>4）可靠传输</strong></p>
<p>对于可靠传输，判断丢包、误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p>
<p><strong>5）提供拥塞控制</strong></p>
<p>当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞。</p>
<p><strong>6）提供全双工通信</strong></p>
<p>TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）</p>
<h3 id="2-TCP和UDP的区别"><a href="#2-TCP和UDP的区别" class="headerlink" title="2. TCP和UDP的区别"></a>2. TCP和UDP的区别</h3><table>
<thead>
<tr>
<th></th>
<th>UDP</th>
<th>TCP</th>
</tr>
</thead>
<tbody><tr>
<td>是否连接</td>
<td>无连接</td>
<td>面向连接</td>
</tr>
<tr>
<td>是否可靠</td>
<td>不可靠传输，不使用流量控制和拥塞控制</td>
<td>可靠传输（数据顺序和正确性），使用流量控制和拥塞控制</td>
</tr>
<tr>
<td>连接对象个数</td>
<td>支持一对一，一对多，多对一和多对多交互通信</td>
<td>只能是一对一通信</td>
</tr>
<tr>
<td>传输方式</td>
<td>面向报文</td>
<td>面向字节流</td>
</tr>
<tr>
<td>首部开销</td>
<td>首部开销小，仅8字节</td>
<td>首部最小20字节，最大60字节</td>
</tr>
<tr>
<td>适用场景</td>
<td>适用于实时应用，例如视频会议、直播</td>
<td>适用于要求可靠传输的应用，例如文件传输</td>
</tr>
</tbody></table>
<h3 id="3-TCP和UDP的使用场景"><a href="#3-TCP和UDP的使用场景" class="headerlink" title="3. TCP和UDP的使用场景"></a>3. TCP和UDP的使用场景</h3><ul>
<li><strong>TCP应用场景：</strong> 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。例如：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。</li>
<li><strong>UDP应用场景：</strong> 效率要求相对高，对准确性要求相对低的场景。例如：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。</li>
</ul>
<h3 id="4-UDP协议为什么不可靠？"><a href="#4-UDP协议为什么不可靠？" class="headerlink" title="4. UDP协议为什么不可靠？"></a>4. UDP协议为什么不可靠？</h3><p>UDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认，提供不可靠交付。总结就以下四点：</p>
<ul>
<li>不保证消息交付：不确认，不重传，无超时</li>
<li>不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞</li>
<li>不跟踪连接状态：不必建立连接或重启状态机</li>
<li>不进行拥塞控制：不内置客户端或网络反馈机制</li>
</ul>
<h3 id="5-TCP的重传机制"><a href="#5-TCP的重传机制" class="headerlink" title="5. TCP的重传机制"></a>5. TCP的重传机制</h3><p>由于TCP的下层网络（网络层）可能出现<strong>丢失、重复或失序</strong>的情况，TCP协议提供可靠数据传输服务。为保证数据传输的正确性，TCP会重传其认为已丢失（包括报文中的比特错误）的包。TCP使用两套独立的机制来完成重传，一是<strong>基于时间</strong>，二是<strong>基于确认信息</strong>。</p>
<p>TCP在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。</p>
<h3 id="6-TCP的拥塞控制机制"><a href="#6-TCP的拥塞控制机制" class="headerlink" title="6. TCP的拥塞控制机制"></a>6. TCP的拥塞控制机制</h3><p>TCP的拥塞控制机制主要是以下四种机制：</p>
<ul>
<li>慢启动（慢开始）</li>
<li>拥塞避免</li>
<li>快速重传</li>
<li>快速恢复</li>
</ul>
<p><strong>（1）慢启动（慢开始）</strong></p>
<ul>
<li><p>在开始发送的时候设置cwnd = 1（cwnd指的是拥塞窗口）</p>
</li>
<li><p>思路：开始的时候不要发送大量数据，而是先测试一下网络的拥塞程度，由小到大增加拥塞窗口的大小。</p>
</li>
<li><p>为了防止cwnd增长过大引起网络拥塞，设置一个慢开始门限(ssthresh 状态变量)</p>
</li>
<li><ul>
<li>当cnwd &lt; ssthresh，使用慢开始算法</li>
<li>当cnwd = ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法</li>
<li>当cnwd &gt; ssthresh，使用拥塞避免算法</li>
</ul>
</li>
</ul>
<p><strong>（2）拥塞避免</strong></p>
<ul>
<li><p>拥塞避免未必能够完全避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性增长，使网络不容易出现阻塞。</p>
</li>
<li><p>思路： 让拥塞窗口cwnd缓慢的增大，即每经过一个返回时间RTT就把发送方的拥塞控制窗口加一</p>
</li>
<li><p>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。如图所示:<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1604022952123-62276cba-d882-46c9-8a1c-70655dc501af.png" alt="image"></p>
</li>
<li><p>其中，判断网络出现拥塞的根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理。</p>
</li>
</ul>
<p><strong>（3）快速重传</strong></p>
<ul>
<li>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)。发送方只要连续收到三个重复确认就立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</li>
<li>由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量</li>
</ul>
<p><strong>（4）快速恢复</strong></p>
<ul>
<li>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。</li>
<li>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1604022952153-a7106d22-225d-4081-9b0a-56b0d1876bc2.png" alt="image"></li>
</ul>
<h3 id="7-TCP的流量控制机制"><a href="#7-TCP的流量控制机制" class="headerlink" title="7. TCP的流量控制机制"></a>7. TCP的流量控制机制</h3><p>一般来说，流量控制就是为了让发送方发送数据的速度不要太快，要让接收方来得及接收。TCP采用大小可变的<strong>滑动窗口</strong>进行流量控制，窗口大小的单位是字节。这里说的窗口大小其实就是每次传输的数据大小。</p>
<ul>
<li>当一个连接建立时，连接的每一端分配一个缓冲区来保存输入的数据，并将缓冲区的大小发送给另一端。</li>
<li>当数据到达时，接收方发送确认，其中包含了自己剩余的缓冲区大小。（剩余的缓冲区空间的大小被称为窗口，指出窗口大小的通知称为窗口通告 。接收方在发送的每一确认中都含有一个窗口通告。）</li>
<li>如果接收方应用程序读数据的速度能够与数据到达的速度一样快，接收方将在每一确认中发送一个正的窗口通告。</li>
<li>如果发送方操作的速度快于接收方，接收到的数据最终将充满接收方的缓冲区，导致接收方通告一个零窗口 。发送方收到一个零窗口通告时，必须停止发送，直到接收方重新通告一个正的窗口。</li>
</ul>
<h3 id="8-TCP的可靠传输机制"><a href="#8-TCP的可靠传输机制" class="headerlink" title="8. TCP的可靠传输机制"></a>8. TCP的可靠传输机制</h3><p>TCP 的可靠传输机制是基于连续 ARQ 协议和滑动窗口协议的。</p>
<p>TCP 协议在发送方维持了一个发送窗口，发送窗口以前的报文段是已经发送并确认了的报文段，发送窗口中包含了已经发送但 未确认的报文段和允许发送但还未发送的报文段，发送窗口以后的报文段是缓存中还不允许发送的报文段。当发送方向接收方发 送报文时，会依次发送窗口内的所有报文段，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的报文段。 如果在定时器的时间内收到某一个报文段的确认回答，则滑动窗口，将窗口的首部向后滑动到确认报文段的后一个位置，此时如 果还有已发送但没有确认的报文段，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送 但还未收到确认的报文段，并将超时的间隔设置为以前的两倍。当发送方收到接收方的三个冗余的确认应答后，这是一种指示， 说明该报文段以后的报文段很有可能发生丢失了，那么发送方会启用快速重传的机制，就是当前定时器结束前，发送所有的已发 送但确认的报文段。</p>
<p>接收方使用的是累计确认的机制，对于所有按序到达的报文段，接收方返回一个报文段的肯定回答。如果收到了一个乱序的报文 段，那么接方会直接丢弃，并返回一个最近的按序到达的报文段的肯定回答。使用累计确认保证了返回的确认号之前的报文段都 已经按序到达了，所以发送窗口可以移动到已确认报文段的后面。</p>
<p>发送窗口的大小是变化的，它是由接收窗口剩余大小和网络中拥塞程度来决定的，TCP 就是通过控制发送窗口的长度来控制报文 段的发送速率。</p>
<p>但是 TCP 协议并不完全和滑动窗口协议相同，因为许多的 TCP 实现会将失序的报文段给缓存起来，并且发生重传时，只会重 传一个报文段，因此 TCP 协议的可靠传输机制更像是窗口滑动协议和选择重传协议的一个混合体。</p>
<h3 id="9-TCP的三次握手和四次挥手"><a href="#9-TCP的三次握手和四次挥手" class="headerlink" title="9. TCP的三次握手和四次挥手"></a>9. TCP的三次握手和四次挥手</h3><h4 id="（1）三次握手"><a href="#（1）三次握手" class="headerlink" title="（1）三次握手"></a>（1）三次握手</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1604023663256-5eb6dcdf-fdb6-4b67-a3da-da15c1d396fb.png" alt="image"></p>
<p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p>
<p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。</p>
<ul>
<li>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN，此时客户端处于 SYN_SEND 状态。</li>
</ul>
<blockquote>
<p>首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。</p>
</blockquote>
<ul>
<li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</li>
</ul>
<blockquote>
<p>在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y</p>
</blockquote>
<ul>
<li>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。</li>
</ul>
<blockquote>
<p>确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p>
</blockquote>
<p><strong>那为什么要三次握手呢？两次不行吗？</strong></p>
<ul>
<li>为了确认双方的接收能力和发送能力都正常</li>
<li>如果是用两次握手，则会出现下面这种情况：</li>
</ul>
<blockquote>
<p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p>
</blockquote>
<p><strong>简单来说就是以下三步：</strong></p>
<ul>
<li><strong>第一次握手：</strong>客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。</li>
<li><strong>第二次握手：</strong>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。</li>
<li><strong>第三次握手：</strong>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</li>
</ul>
<p>TCP 三次握手的建立连接的过程就是相互确认初始序号的过程，告诉对方，什么样序号的报文段能够被正确接收。 第三次握手的作用是客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否 已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。</p>
<h4 id="（2）四次挥手"><a href="#（2）四次挥手" class="headerlink" title="（2）四次挥手"></a>（2）四次挥手</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1604023663279-0ea063ba-a06b-4f57-9aa9-0e2d1c8d373c.png" alt="image"></p>
<p>刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p>
<ul>
<li>第一次挥手： 客户端会发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。</li>
</ul>
<blockquote>
<p>即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</p>
</blockquote>
<ul>
<li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。</li>
</ul>
<blockquote>
<p>即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</p>
</blockquote>
<ul>
<li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</li>
</ul>
<blockquote>
<p>即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</p>
</blockquote>
<ul>
<li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li>
</ul>
<blockquote>
<p>即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</p>
</blockquote>
<p><strong>那为什么需要四次挥手呢？</strong></p>
<blockquote>
<p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四次挥手。</p>
</blockquote>
<p><strong>简单来说就是以下四步：</strong></p>
<ul>
<li><strong>第一次<strong><strong>挥手</strong></strong>：</strong>若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。</li>
<li><strong>第二次****挥手</strong>：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。</li>
<li><strong>第三次挥手</strong>：服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。</li>
<li><strong>第四次<strong><strong>挥手</strong></strong>：</strong>客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。</li>
</ul>
<p>TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代 表不能再向对方发送数据，连接处于的是半释放的状态。</p>
<p>最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器 端不能正常关闭。</p>
<h3 id="10-TCP粘包是怎么回事，如何处理"><a href="#10-TCP粘包是怎么回事，如何处理" class="headerlink" title="10. TCP粘包是怎么回事，如何处理**?**"></a>10. <strong>TCP</strong>粘包是怎么回事，如何处理**?**</h3><p>默认情况下, TCP 连接会启⽤延迟传送算法 (Nagle 算法), 在数据发送之前缓存他们. 如果短时间有多个数据发送, 会缓冲到⼀起作⼀次发送 (缓冲⼤⼩⻅ socket.bufferSize ), 这样可以减少 IO 消耗提⾼性能. </p>
<p>如果是传输⽂件的话, 那么根本不⽤处理粘包的问题, 来⼀个包拼⼀个包就好了。但是如果是多条消息, 或者是别的⽤途的数据那么就需要处理粘包. </p>
<p>下面看⼀个例⼦, 连续调⽤两次 send 分别发送两段数据 data1 和 data2, 在接收端有以下⼏种常⻅的情况: </p>
<p>A. 先接收到 data1, 然后接收到 data2 . </p>
<p>B. 先接收到 data1 的部分数据, 然后接收到 data1 余下的部分以及 data2 的全部. </p>
<p>C. 先接收到了 data1 的全部数据和 data2 的部分数据, 然后接收到了 data2 的余下的数据. </p>
<p>D. ⼀次性接收到了 data1 和 data2 的全部数据. </p>
<p>其中的 BCD 就是我们常⻅的粘包的情况. ⽽对于处理粘包的问题, 常⻅的解决⽅案有: </p>
<ul>
<li><strong>多次发送之前间隔⼀个等待时间</strong>：只需要等上⼀段时间再进⾏下⼀次 send 就好, 适⽤于交互频率特别低的场景. 缺点也很明显, 对于⽐较频繁的场景⽽⾔传输效率实在太低，不过⼏乎不⽤做什么处理. </li>
<li><strong>关闭</strong> <strong>Nagle</strong> <strong>算法</strong>：关闭 Nagle 算法, 在 Node.js 中你可以通过 socket.setNoDelay() ⽅法来关闭 Nagle 算法, 让每⼀次 send 都不缓冲直接发送。该⽅法⽐较适⽤于每次发送的数据都⽐较⼤ (但不是⽂件那么⼤), 并且频率不是特别⾼的场景。如果是每次发送的数据量⽐较⼩, 并且频率特别⾼的, 关闭 Nagle 纯属⾃废武功。另外, 该⽅法不适⽤于⽹络较差的情况, 因为 Nagle 算法是在服务端进⾏的包合并情况, 但是如果短时间内客户端的⽹络情况不好, 或者应⽤层由于某些原因不能及时将 TCP 的数据 recv, 就会造成多个包在客户端缓冲从⽽粘包的情况。 (如果是在稳定的机房内部通信那么这个概率是⽐较⼩可以选择忽略的)  </li>
<li><strong>进⾏封包</strong><strong>/拆包：</strong>封包/拆包是⽬前业内常⻅的解决⽅案了。即给每个数据包在发送之前, 于其前/后放⼀些有特征的数据, 然后收到数据的时 候根据特征数据分割出来各个数据包。</li>
</ul>
<h3 id="11-为什么udp不会粘包？"><a href="#11-为什么udp不会粘包？" class="headerlink" title="11. 为什么udp不会粘包？"></a>11. 为什么<strong>udp</strong>不会粘包？</h3><ul>
<li>TCP协议是⾯向流的协议，UDP是⾯向消息的协议。UDP段都是⼀条消息，应⽤程序必须以消息为单位提取数据，不能⼀次提取任意字节的数据 </li>
<li>UDP具有保护消息边界，在每个UDP包中就有了消息头（消息来源地址，端⼝等信息），这样对于接收端来说就容易进⾏区分处理了。传输协议把数据当作⼀条独⽴的消息在⽹上传输，接收端只能接收独⽴的消息。接收端⼀次只能接收发送端发出的⼀个数据包,如果⼀次接受数据的⼤⼩⼩于发送端⼀次发送的数据⼤⼩，就会丢失⼀部分数据，即使丢失，接受端也不会分两次去接收。</li>
</ul>
<h2 id="七、WebSocket"><a href="#七、WebSocket" class="headerlink" title="七、WebSocket"></a>七、WebSocket</h2><h3 id="1-对-WebSocket-的理解"><a href="#1-对-WebSocket-的理解" class="headerlink" title="1. 对 WebSocket 的理解"></a>1. 对 WebSocket 的理解</h3><p>WebSocket是HTML5提供的一种浏览器与服务器进行<strong>全双工通讯</strong>的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。</p>
<p>WebSocket 的出现就解决了半双工通信的弊端。它最大的特点是：<strong>服务器可以向客户端主动推动消息，客户端也可以主动向服务器推送消息。</strong></p>
<p><strong>WebSocket原理</strong>：客户端向 WebSocket 服务器通知（notify）一个带有所有接收者ID（recipients IDs）的事件（event），服务器接收后立即通知所有活跃的（active）客户端，只有ID在接收者ID序列中的客户端才会处理这个事件。</p>
<p><strong>WebSocket 特点的如下：</strong></p>
<ul>
<li>支持双向通信，实时性更强</li>
<li>可以发送文本，也可以发送二进制数据‘’</li>
<li>建立在TCP协议之上，服务端的实现比较容易</li>
<li>数据格式比较轻量，性能开销小，通信高效</li>
<li>没有同源限制，客户端可以与任意服务器通信</li>
<li>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL</li>
<li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li>
</ul>
<p><strong>Websocket的使用方法如下：</strong></p>
<p>在客户端中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 在index.html中直接写WebSocket，设置服务端的端口号为 9999</span><br><span class="line">let ws = new WebSocket(&#x27;ws://localhost:9999&#x27;);</span><br><span class="line">// 在客户端与服务端建立连接后触发</span><br><span class="line">ws.onopen = function() &#123;</span><br><span class="line">    console.log(&quot;Connection open.&quot;); </span><br><span class="line">    ws.send(&#x27;hello&#x27;);</span><br><span class="line">&#125;;</span><br><span class="line">// 在服务端给客户端发来消息的时候触发</span><br><span class="line">ws.onmessage = function(res) &#123;</span><br><span class="line">    console.log(res);       // 打印的是MessageEvent对象</span><br><span class="line">    console.log(res.data);  // 打印的是收到的消息</span><br><span class="line">&#125;;</span><br><span class="line">// 在客户端与服务端建立关闭后触发</span><br><span class="line">ws.onclose = function(evt) &#123;</span><br><span class="line">  console.log(&quot;Connection closed.&quot;);</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<h3 id="2-即时通讯的实现：短轮询、长轮询、SSE-和-WebSocket-间的区别？"><a href="#2-即时通讯的实现：短轮询、长轮询、SSE-和-WebSocket-间的区别？" class="headerlink" title="2. 即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？"></a>2. 即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？</h3><p>短轮询和长轮询的目的都是用于实现客户端和服务器端的一个即时通讯。</p>
<p><strong>短轮询的基本思路：</strong>浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。这种方式的优点是比较简单，易于理解。缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。</p>
<p><strong>长轮询的基本思路：</strong>首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，它的优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。</p>
<p><strong>SSE 的基本思想：</strong>服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 IE/Edge，其他浏览器都支持。它相对于前面两种方式来说，不需要建立过多的 http 请求，相比之下节约了资源。</p>
<p><strong>WebSocket</strong> 是 HTML5 定义的一个新协议议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息，而 SSE 的方式是单向通信的，只能由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个 http 请求了。</p>
<p><strong>上面的四个通信协议，前三个都是基于HTTP协议的。</strong></p>
<p>对于这四种即使通信协议，从性能的角度来看：</p>
<p><strong>WebSocket &gt; 长连接（SEE） &gt; 长轮询 &gt; 短轮询</strong></p>
<p>但是，我们如果考虑浏览器的兼容性问题，顺序就恰恰相反了：</p>
<p><strong>短轮询 &gt; 长轮询 &gt; 长连接（SEE） &gt; WebSocket</strong></p>
<p>所以，还是要根据具体的使用场景来判断使用哪种方式。</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://z1.ax1x.com/2023/09/24/pPToDgg.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://z1.ax1x.com/2023/09/24/pPToDgg.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Tiamo</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://blog.xiaoadai.com/2022/08/18/8%20offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://blog.xiaoadai.com/2022/08/18/8%20offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87/')">军哥面试题-8.计算机网络篇</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://blog.xiaoadai.com/2022/08/18/8%20offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=军哥面试题-8.计算机网络篇&amp;url=https://blog.xiaoadai.com/2022/08/18/8%20offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87/&amp;pic=https://source.fomal.cc/img/default_cover_8.webp" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.xiaoadai.com" target="_blank">By Wang</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E5%86%9B%E5%93%A5%E9%9D%A2%E8%AF%95%E9%A2%98/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>军哥面试题<span class="tagsPageCount">14</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://source.fomal.cc/img/default_cover_7.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/08/17/7%20offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%AF%87/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://source.fomal.cc/img/default_cover_7.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">军哥面试题-7.前端工程化篇</div></div></a></div><div class="next-post pull-right"><a href="/2022/08/19/9%20offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E7%AF%87/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://source.fomal.cc/img/default_cover_9.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">军哥面试题-9.浏览器原理篇</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2022/08/10/1%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/" title="军哥面试题--1.前端面试准备"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://source.fomal.cc/img/default_cover_1.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-08-10</div><div class="title">军哥面试题--1.前端面试准备</div></div></a></div><div><a href="/2022/08/21/11%20offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%AF%87/" title="军哥面试题-11.代码输出篇"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://source.fomal.cc/img/default_cover_11.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-08-21</div><div class="title">军哥面试题-11.代码输出篇</div></div></a></div><div><a href="/2022/08/20/10%20offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%AF%87/" title="军哥面试题-10.手写代码篇"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://source.fomal.cc/img/default_cover_10.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-08-20</div><div class="title">军哥面试题-10.手写代码篇</div></div></a></div><div><a href="/2022/08/23/13%20offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8BVue%E7%AF%87/" title="军哥面试题-13.Vue篇"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://source.fomal.cc/img/default_cover_13.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-08-23</div><div class="title">军哥面试题-13.Vue篇</div></div></a></div><div><a href="/2022/08/22/12LeetCode%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83%E9%A2%98%E7%9B%AE/" title="军哥面试题-12.LeetCode面试常考题目"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://source.fomal.cc/img/default_cover_12.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-08-22</div><div class="title">军哥面试题-12.LeetCode面试常考题目</div></div></a></div><div><a href="/2022/08/11/2%20%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E8%BD%AF%E6%8A%80%E8%83%BD/" title="军哥面试题--2.程序员面试软技能"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://source.fomal.cc/img/default_cover_2.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-08-11</div><div class="title">军哥面试题--2.程序员面试软技能</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://z1.ax1x.com/2023/09/24/pPToDgg.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://github.githubassets.com/images/icons/emoji/unicode/270d.png" ait="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">前端、Python、开发</b>相关的问题和看法，还有<b style="color:#fff">文章翻译</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来看我的博客鸭~</div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(null) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81HTTP%E5%8D%8F%E8%AE%AE"><span class="toc-text">一、HTTP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-GET%E5%92%8CPOST%E7%9A%84%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1. GET和POST的请求的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-POST%E5%92%8CPUT%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2. POST和PUT请求的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%92%8C%E5%93%8D%E5%BA%94%E5%A4%B4"><span class="toc-text">3. 常见的HTTP请求头和响应头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-HTTP%E7%8A%B6%E6%80%81%E7%A0%81304%E6%98%AF%E5%A4%9A%E5%A5%BD%E8%BF%98%E6%98%AF%E5%B0%91%E5%A5%BD"><span class="toc-text">4. HTTP状态码304是多好还是少好</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="toc-text">5. 常见的HTTP请求方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-OPTIONS%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">6. OPTIONS请求方法及使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-HTTP-1-0-%E5%92%8C-HTTP-1-1-%E4%B9%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">7. HTTP 1.0 和 HTTP 1.1 之间有哪些区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-HTTP-1-1-%E5%92%8C-HTTP-2-0-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">8. HTTP 1.1 和 HTTP 2.0 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-HTTP%E5%92%8CHTTPS%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">9. HTTP和HTTPS协议的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-GET%E6%96%B9%E6%B3%95URL%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-text">10. GET方法URL长度限制的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%BD%93%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5-Google-com-%E5%B9%B6%E4%B8%94%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">11. 当在浏览器中输入 Google.com 并且按下回车之后发生了什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%AF%B9keep-alive%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">12. 对keep-alive的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E9%A1%B5%E9%9D%A2%E6%9C%89%E5%A4%9A%E5%BC%A0%E5%9B%BE%E7%89%87%EF%BC%8CHTTP%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%A1%A8%E7%8E%B0%EF%BC%9F"><span class="toc-text">13. 页面有多张图片，HTTP是怎样的加载表现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-HTTP2%E7%9A%84%E5%A4%B4%E9%83%A8%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">14. HTTP2的头部压缩算法是怎样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">15. HTTP请求报文的是什么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-HTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">16. HTTP响应报文的是什么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-text">17. HTTP协议的优点和缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E8%AF%B4%E4%B8%80%E4%B8%8BHTTP-3-0"><span class="toc-text">18. 说一下HTTP 3.0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%80%A7%E8%83%BD%E6%80%8E%E4%B9%88%E6%A0%B7"><span class="toc-text">19. HTTP协议的性能怎么样</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-URL%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-text">20. URL有哪些组成部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E4%B8%8E%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">21. 与缓存相关的HTTP请求头有哪些</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81HTTPS%E5%8D%8F%E8%AE%AE"><span class="toc-text">二、HTTPS协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFHTTPS%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-text">1. 什么是HTTPS协议？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-TLS-SSL%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">2. TLS&#x2F;SSL的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0hash"><span class="toc-text">（1）散列函数hash</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-text">（2）对称加密</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-text">（3）非对称加密</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">3. 数字证书是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-HTTPS%E9%80%9A%E4%BF%A1%EF%BC%88%E6%8F%A1%E6%89%8B%EF%BC%89%E8%BF%87%E7%A8%8B"><span class="toc-text">4. HTTPS通信（握手）过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-HTTPS%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">5. HTTPS的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-HTTPS%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="toc-text">6. HTTPS是如何保证安全的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">三、HTTP状态码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2XX-Success-%E6%88%90%E5%8A%9F%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">1. 2XX (Success 成功状态码)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89200-OK"><span class="toc-text">（1）200 OK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89204-No-Content"><span class="toc-text">（2）204 No Content</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89206-Partial-Content"><span class="toc-text">（3）206 Partial Content</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3XX-Redirection-%E9%87%8D%E5%AE%9A%E5%90%91%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">2. 3XX (Redirection 重定向状态码)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89301-Moved-Permanently"><span class="toc-text">（1）301 Moved Permanently</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89302-Found"><span class="toc-text">（2）302 Found</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89303-See-Other"><span class="toc-text">（3）303 See Other</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89304-Not-Modified"><span class="toc-text">（4）304 Not Modified</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89307-Temporary-Redirect"><span class="toc-text">（5）307 Temporary Redirect</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4XX-Client-Error-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%94%99%E8%AF%AF%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">3. 4XX (Client Error 客户端错误状态码)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89400-Bad-Request"><span class="toc-text">（1）400 Bad Request</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89401-Unauthorized"><span class="toc-text">（2）401 Unauthorized</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89403-Forbidden"><span class="toc-text">（3）403 Forbidden</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89404-Not-Found"><span class="toc-text">（4）404 Not Found</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89405-Method-Not-Allowed"><span class="toc-text">（5）405 Method Not Allowed</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5XX-Server-Error-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%94%99%E8%AF%AF%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">4. 5XX (Server Error 服务器错误状态码)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89500-Internal-Server-Error"><span class="toc-text">（1）500 Internal Server Error</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89502-Bad-Gateway"><span class="toc-text">（2）502 Bad Gateway</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89503-Service-Unavailable"><span class="toc-text">（3）503 Service Unavailable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89504-Gateway-Timeout"><span class="toc-text">（4）504 Gateway Timeout</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%80%BB%E7%BB%93"><span class="toc-text">5. 总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%90%8C%E6%A0%B7%E6%98%AF%E9%87%8D%E5%AE%9A%E5%90%91%EF%BC%8C307%EF%BC%8C303%EF%BC%8C302%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">6. 同样是重定向，307，303，302的区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81DNS%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D"><span class="toc-text">四、DNS协议介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-DNS-%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">1. DNS 协议是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-DNS%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8TCP%E5%92%8CUDP%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-text">2. DNS同时使用TCP和UDP协议？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-DNS%E5%AE%8C%E6%95%B4%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B"><span class="toc-text">3. DNS完整的查询过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%BF%AD%E4%BB%A3%E6%9F%A5%E8%AF%A2%E4%B8%8E%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2"><span class="toc-text">4. 迭代查询与递归查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-DNS-%E8%AE%B0%E5%BD%95%E5%92%8C%E6%8A%A5%E6%96%87"><span class="toc-text">5. DNS 记录和报文</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-text">五、网络模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-text">1. OSI七层模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-text">（1）应用层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E8%A1%A8%E7%A4%BA%E5%B1%82"><span class="toc-text">（2）表示层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E4%BC%9A%E8%AF%9D%E5%B1%82"><span class="toc-text">（3）会话层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-text">（4）传输层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-text">（5）网络层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="toc-text">（6）数据链路层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%887%EF%BC%89%E7%89%A9%E7%90%86%E5%B1%82"><span class="toc-text">（7）物理层</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-TCP-IP%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="toc-text">2. TCP&#x2F;IP五层协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81TCP%E4%B8%8EUDP"><span class="toc-text">六、TCP与UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-TCP-%E5%92%8C-UDP%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%89%B9%E7%82%B9"><span class="toc-text">1. TCP 和 UDP的概念及特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2. TCP和UDP的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-TCP%E5%92%8CUDP%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">3. TCP和UDP的使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-UDP%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%8F%AF%E9%9D%A0%EF%BC%9F"><span class="toc-text">4. UDP协议为什么不可靠？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-TCP%E7%9A%84%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6"><span class="toc-text">5. TCP的重传机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">6. TCP的拥塞控制机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">7. TCP的流量控制机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E6%9C%BA%E5%88%B6"><span class="toc-text">8. TCP的可靠传输机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">9. TCP的三次握手和四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">（1）三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">（2）四次挥手</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-TCP%E7%B2%98%E5%8C%85%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="toc-text">10. TCP粘包是怎么回事，如何处理**?**</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E4%B8%BA%E4%BB%80%E4%B9%88udp%E4%B8%8D%E4%BC%9A%E7%B2%98%E5%8C%85%EF%BC%9F"><span class="toc-text">11. 为什么udp不会粘包？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81WebSocket"><span class="toc-text">七、WebSocket</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AF%B9-WebSocket-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">1. 对 WebSocket 的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A%E7%9F%AD%E8%BD%AE%E8%AF%A2%E3%80%81%E9%95%BF%E8%BD%AE%E8%AF%A2%E3%80%81SSE-%E5%92%8C-WebSocket-%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">2. 即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/01/09/%E3%80%90Typora%E3%80%91Typora%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/" title="【Typora】Typora破解教程"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://source.fomal.cc/img/default_cover_7.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Typora】Typora破解教程"/></a><div class="content"><a class="title" href="/2024/01/09/%E3%80%90Typora%E3%80%91Typora%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/" title="【Typora】Typora破解教程">【Typora】Typora破解教程</a><time datetime="2024-01-08T16:00:00.000Z" title="发表于 2024-01-09 00:00:00">2024-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/13/%E3%80%90JavaScript%E3%80%91JavaScript%20%E5%86%85%E7%9A%84%20this%20%E6%8C%87%E5%90%91/" title="前端【JavaScript】JavaScript 内的 this 指向"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://source.fomal.cc/img/default_cover_10.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端【JavaScript】JavaScript 内的 this 指向"/></a><div class="content"><a class="title" href="/2023/11/13/%E3%80%90JavaScript%E3%80%91JavaScript%20%E5%86%85%E7%9A%84%20this%20%E6%8C%87%E5%90%91/" title="前端【JavaScript】JavaScript 内的 this 指向">前端【JavaScript】JavaScript 内的 this 指向</a><time datetime="2023-11-13T13:31:28.000Z" title="发表于 2023-11-13 21:31:28">2023-11-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/13/%E3%80%90Vue%E3%80%91%E5%88%86%E4%BA%AB%E4%B8%8B%E5%A6%82%E4%BD%95%E5%9C%A8Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80/" title="【Vue】分享下如何在Vue项目中进行网页布局"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://source.fomal.cc/img/default_cover_15.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Vue】分享下如何在Vue项目中进行网页布局"/></a><div class="content"><a class="title" href="/2023/11/13/%E3%80%90Vue%E3%80%91%E5%88%86%E4%BA%AB%E4%B8%8B%E5%A6%82%E4%BD%95%E5%9C%A8Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80/" title="【Vue】分享下如何在Vue项目中进行网页布局">【Vue】分享下如何在Vue项目中进行网页布局</a><time datetime="2023-11-13T13:31:28.000Z" title="发表于 2023-11-13 21:31:28">2023-11-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/12/%E3%80%90Css%E3%80%91CSS%E3%80%81LESS%E3%80%81SASS%E3%80%81SCSS%20%E7%9A%84%E5%8C%BA%E5%88%AB/" title="【Css】CSS、LESS、SASS、SCSS 的区别"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://source.fomal.cc/img/default_cover_6.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Css】CSS、LESS、SASS、SCSS 的区别"/></a><div class="content"><a class="title" href="/2023/11/12/%E3%80%90Css%E3%80%91CSS%E3%80%81LESS%E3%80%81SASS%E3%80%81SCSS%20%E7%9A%84%E5%8C%BA%E5%88%AB/" title="【Css】CSS、LESS、SASS、SCSS 的区别">【Css】CSS、LESS、SASS、SCSS 的区别</a><time datetime="2023-11-11T16:00:00.000Z" title="发表于 2023-11-12 00:00:00">2023-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/09/%E3%80%90Python%E3%80%9157box%E8%87%AA%E5%8A%A8%E4%BB%BB%E5%8A%A1%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/" title="【Python】57Box自动任务脚本学习"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://source.fomal.cc/img/default_cover_6.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Python】57Box自动任务脚本学习"/></a><div class="content"><a class="title" href="/2023/11/09/%E3%80%90Python%E3%80%9157box%E8%87%AA%E5%8A%A8%E4%BB%BB%E5%8A%A1%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/" title="【Python】57Box自动任务脚本学习">【Python】57Box自动任务脚本学习</a><time datetime="2023-11-08T16:00:00.000Z" title="发表于 2023-11-09 00:00:00">2023-11-09</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="Tiamo" target="_blank">Tiamo</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">13</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://blog.xiaoadai.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Chat-GPT/" style="font-size: 0.88rem;">Chat GPT<sup>1</sup></a><a href="/tags/Linux%E3%80%90Vi%E3%80%91/" style="font-size: 0.88rem;">Linux【Vi】<sup>1</sup></a><a href="/tags/python%E3%80%90%E7%88%AC%E8%99%AB%E3%80%91/" style="font-size: 0.88rem;">python【爬虫】<sup>2</sup></a><a href="/tags/%E3%80%90JavaScript%E3%80%91/" style="font-size: 0.88rem;">【JavaScript】<sup>1</sup></a><a href="/tags/%E3%80%90Python%E3%80%91/" style="font-size: 0.88rem;">【Python】<sup>1</sup></a><a href="/tags/%E3%80%90Typora%E3%80%91/" style="font-size: 0.88rem;">【Typora】<sup>1</sup></a><a href="/tags/%E3%80%90%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E3%80%91/" style="font-size: 0.88rem;">【青龙面板】<sup>1</sup></a><a href="/tags/%E5%86%9B%E5%93%A5%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 0.88rem;">军哥面试题<sup>14</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF%E3%80%90CSS%E3%80%91/" style="font-size: 0.88rem;">前端【CSS】<sup>2</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF%E3%80%90JavaScript%E3%80%91/" style="font-size: 0.88rem;">前端【JavaScript】<sup>6</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF%E3%80%90JaveScript%E3%80%91/" style="font-size: 0.88rem;">前端【JaveScript】<sup>1</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF%E3%80%90Layui%E3%80%91/" style="font-size: 0.88rem;">前端【Layui】<sup>2</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF%E3%80%90Vue%E3%80%91/" style="font-size: 0.88rem;">前端【Vue】<sup>4</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 0.88rem;">博客<sup>1</sup></a><a href="/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/" style="font-size: 0.88rem;">学习日常<sup>4</sup></a><a href="/tags/%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">模拟面试<sup>1</sup></a><a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 0.88rem;">笔记<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://comment.xiaoadai.com/',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.18/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://comment.xiaoadai.com/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://comment.xiaoadai.com/',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.18/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>