<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>军哥面试题-9.浏览器原理篇 | By Wang</title><meta name="keywords" content="面试题"><meta name="author" content="Tiamo"><meta name="copyright" content="Tiamo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="军哥面试题-9.浏览器原理篇"><meta name="application-name" content="军哥面试题-9.浏览器原理篇"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="军哥面试题-9.浏览器原理篇"><meta property="og:url" content="https://blog.xiaoadai.com/2022/08/19/9%20offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E7%AF%87/index.html"><meta property="og:site_name" content="By Wang"><meta property="og:description" content="🥧军哥面试题-9.浏览器原理篇"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://source.fomal.cc/img/default_cover_9.webp"><meta property="article:author" content="Tiamo"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://source.fomal.cc/img/default_cover_9.webp"><meta name="description" content="🥧军哥面试题-9.浏览器原理篇"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.xiaoadai.com/2022/08/19/9%20offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E7%AF%87/"><link rel="preconnect" href="//npm.elemecdn.com"/><link rel="preconnect" href="//npm.onmicrosoft.cn"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"Tiamo","mode":"tianli","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":6,"basicWordCount":1999,"key":"207d044fe5f22c1dc77b","Referer":"https://blog.xiaoadai.com/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://comment.xiaoadai.com/',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Tiamo","link":"链接: ","source":"来源: By Wang","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'By Wang',
  title: '军哥面试题-9.浏览器原理篇',
  postAI: '',
  pageFillDescription: '一、浏览器安全, 1.  什么是 XSS 攻击？, （1）概念, （2）攻击类型, 2. 如何防御 XSS 攻击？, 3. 什么是 CSRF 攻击？, （1）概念, （2）攻击类型, 4. 如何防御 CSRF 攻击？, 5. 什么是中间人攻击？如何防范中间人攻击？, 6. 有哪些可能引起前端安全的问题**?**, 7. 网络劫持有哪几种如何防范？, 二、进程与线程, 1. 进程与线程的概念, 2. 进程和线程的区别, 3. 浏览器渲染进程的线程有哪些, 4. 进程之前的通信方式, 5. 僵尸进程和孤儿进程是什么？, 6. 死锁产生的原因？ 如果解决死锁的问题？, 7. 如何实现浏览器内多个标签页之间的通信?, 8. 对Service Worker的理解, 三、浏览器缓存, 1. 对浏览器的缓存机制的理解, 2. 浏览器资源缓存的位置有哪些？, 3. 协商缓存和强缓存的区别, （1）强缓存, （2）协商缓存, 4. 为什么需要浏览器缓存？, 5. 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？, 四、浏览器组成, 1. 对浏览器的理解, 2. 对浏览器内核的理解, 3. 常见的浏览器内核比较, 4. 常见浏览器所用内核, 5. 浏览器的主要组成部分, 五、浏览器渲染原理, 1. 浏览器的渲染过程, 2. 浏览器渲染优化, 3. 渲染过程中遇到 JS 文件如何处理？, 4. 什么是文档的预解析？, 5. CSS 如何阻塞文档解析？, 6. 如何优化关键渲染路径？, 7. 什么情况会阻塞渲染？, 六、浏览器本地存储, 1. 浏览器本地存储方式及使用场景, （1）Cookie, （2）LocalStorage, （3）SessionStorage, 2. Cookie有哪些字段作用分别是什么, 3. Cookie、LocalStorage、SessionStorage区别, 4. 前端储存的⽅式有哪些？, 5. IndexedDB有哪些特点？, 七、浏览器同源策略, 1. 什么是同源策略, 2. 如何解决跨越问题, （1）CORS, 减少OPTIONS请求次数：, , CORS中Cookie相关问题：, （2）JSONP, （3）postMessage 跨域, （4）nginx代理跨域, （5）nodejs 中间件代理跨域, （6）document.domain + iframe跨域, （7）location.hash + iframe跨域, （8）window.name + iframe跨域, （9）WebSocket协议跨域, 3. 正向代理和反向代理的区别, 4. Nginx的概念及其工作原理, 八、浏览器事件机制, 1. 事件是什么？事件模型？, 2. 如何阻止事件冒泡, 3. 对事件委托的理解, （1）事件委托的概念, （2）事件委托的特点, （3）局限性, 4. 事件委托的使用场景, 5. 同步和异步的区别, 6. 对事件循环的理解, 7. 宏任务和微任务分别有哪些, 8. 什么是执行栈, 9. Node 中的 Event Loop 和浏览器中的有什么区别？process.nextTick 执行顺序？, 10. 事件触发的过程是怎样的, 九、浏览器垃圾回收机制, 1. V8的垃圾回收机制是怎样的, 2. 哪些操作会造成内存泄漏？一浏览器安全什么是攻击概念攻击指的是跨站脚本攻击是一种代码注入攻击攻击者通过在网站注入恶意脚本使之在用户的浏览器上运行从而盗取用户的信息如等的本质是因为网站没有对恶意代码进行过滤与正常的代码混合在一起了浏览器没有办法分辨哪些脚本是可信的从而导致了恶意代码的执行攻击者可以通过这种攻击方式可以进行以下操作获取页面的数据如攻击发送合理请求占用服务器资源从而使用户无法访问服务器破坏页面结构流量劫持将链接指向某网站攻击类型可以分为存储型反射型和型存储型指的是恶意脚本会存储在目标服务器上当浏览器请求数据时脚本从服务器传回并执行反射型指的是攻击者诱导用户访问一个带有恶意代码的后服务器端接收数据后处理然后把带有恶意代码的数据发送到浏览器端浏览器端解析这段带有代码的数据后当做脚本执行最终完成攻击型指的通过修改页面的节点形成的存储型的攻击步骤攻击者将恶意代码提交到标站的数据库中户打开标站时站服务端将恶意代码从数据库取出拼接在中返回给浏览器户浏览器接收到响应后解析执混在其中的恶意代码也被执恶意代码窃取户数据并发送到攻击者的站或者冒充户的为调标站接执攻击者指定的操作这种攻击常于带有户保存数据的站功能如论坛发帖商品评论户私信等反射型的攻击步骤攻击者构造出特殊的其中包含恶意代码户打开带有恶意代码的时站服务端将恶意代码从中取出拼接在中返回给浏览器户浏览器接收到响应后解析执混在其中的恶意代码也被执恶意代码窃取户数据并发送到攻击者的站或者冒充户的为调标站接执攻击者指定的操作反射型跟存储型的区别是存储型的恶意代码存在数据库反射型的恶意代码存在反射型漏洞常于通过传递参数的功能如站搜索跳转等由于需要户主动打开恶意的才能效攻击者往往会结合多种段诱导户点击型的攻击步骤攻击者构造出特殊的其中包含恶意代码户打开带有恶意代码的户浏览器接收到响应后解析执前端取出中的恶意代码并执恶意代码窃取户数据并发送到攻击者的站或者冒充户的为调标站接执攻击者指定的操作型跟前两种的区别型攻击中取出和执恶意代码由浏览器端完成属于前端身的安全漏洞其他两种都属于服务端的安全漏洞如何防御攻击可以看到危害如此之大那么在开发网站时就要做好防御措施具体措施如下可以从浏览器的执行来进行预防一种是使用纯前端的方式不用服务器端拼接后返回不使用服务端渲染另一种是对需要插入到中的代码做好充分的转义对于型的攻击主要是前端脚本的不可靠而造成的对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断使用的本质是建立一个白名单告诉浏览器哪些外部资源可以加载和执行从而防止恶意代码的注入攻击指的是内容安全策略它的本质是建立一个白名单告诉浏览器哪些外部资源可以加载和执行我们只需要配置规则如何拦截由浏览器自己来实现通常有两种方式来开启一种是设置首部中的一种是设置标签的方式对一些敏感信息进行保护比如使用使得脚本无法获取也可以使用验证码避免脚本伪装成用户执行一些操作什么是攻击概念攻击指的是跨站请求伪造攻击攻击者诱导用户进入一个第三方网站然后该网站向被攻击网站发送跨站请求如果用户在被攻击网站中保存了登录状态那么攻击者就可以利用这个登录状态绕过后台的用户验证冒充用户向服务器执行一些操作攻击的本质是利用会在同源请求中携带发送给服务器的特点以此来实现用户的冒充攻击类型常见的攻击有三种类型的攻击比如在网站中的一个标签里构建一个请求当用户打开这个网站的时候就会自动发起提交类型的攻击比如构建一个表单然后隐藏它当用户进入页面时自动提交这个表单链接类型的攻击比如在标签的属性里构建一个请求然后诱导用户去点击如何防御攻击攻击可以使用以下方法来防护进行同源检测服务器根据请求头中或者信息来判断请求是否为允许访问的站点从而对请求进行过滤当或者信息都不存在的时候直接阻止请求这种方式的缺点是有些情况下可以被伪造同时还会把搜索引擎的链接也给屏蔽了所以一般网站会允许搜索引擎的页面请求但是相应的页面请求这种请求方式也可能被攻击者给利用字段会告诉服务器该网页是从哪个页面链接过来的使用进行验证服务器向用户返回一个随机数当网站再次发起请求时在请求参数中加入服务器端返回的然后服务器对这个进行验证这种方法解决了使用单一验证方式时可能会被冒用的问题但是这种方法存在一个缺点就是我们需要给网站中的所有请求都添加上这个操作比较繁琐还有一个问题是一般不会只有一台网站服务器如果请求经过负载平衡转移到了其他的服务器但是这个服务器的中没有保留这个的话就没有办法验证了这种情况可以通过改变的构建方式来解决对进行双重验证服务器在用户访问网站页面时向请求域名注入一个内容为随机字符串然后当用户再次向服务器发送请求的时候从中取出这个字符串添加到参数中然后服务器通过对中的数据和参数中的数据进行比较来进行验证使用这种方式是利用了攻击者只能利用但是不能访问获取的特点并且这种方法比的方法更加方便并且不涉及到分布式访问的问题这种方法的缺点是如果网站存在漏洞的那么这种方式会失效同时这种方式不能做到子域名的隔离在设置属性的时候设置限制不能作为被第三方使用从而可以避免被攻击者利用一共有两种模式一种是严格模式在严格模式下在任何情况下都不可能作为第三方使用在宽松模式下可以被请求是请求且会发生页面跳转的请求所使用什么是中间人攻击如何防范中间人攻击中间是指攻击者与通讯的两端分别创建独的联系并交换其所收到的数据使通讯的两端认为他们正在通过个私密的连接与对直接对话但事实上整个会话都被攻击者完全控制在中间攻击中攻击者可以拦截通讯双的通话并插新的内容攻击过程如下客户端发送请求到服务端请求被中间截获服务器向客户端发送公钥中间截获公钥保留在上然后成个伪造的公钥发给客户端客户端收到伪造的公钥后成加密值发给服务器中间获得加密值的私钥解密获得真秘钥同时成假的加密值发给服务器服务器私钥解密获得假密钥然后加密数据传输给客户端有哪些可能引起前端安全的问题跨站脚本种代码注式为了与区分所以被称作早期常于络论坛起因是站没有对户的输进严格的限制使得攻击者可以将脚本上传到帖让其他浏览到有恶意脚本的其注式很简单包括但不限于等的滥中的内容是由第三来提供的默认情况下他们不受控制他们可以在中运脚本插件弹出对话框等等这可能会破坏前端户体验跨站点请求伪造指攻击者通过设置好的陷阱强制对已完成认证的户进预期的个信息或设定信息等某些状态更新属于被动攻击恶意第三库论是后端服务器应还是前端应开发绝多数时候都是在借助开发框架和各种类库进快速开发旦第三库被植恶意代码很容易引起安全问题网络劫持有哪几种如何防范络劫持分为两种劫持输京东被强制跳转到淘宝这就属于劫持强制解析通过修改运营商的本地记录来引导户流量到缓存服务器跳转的式通过监控络出的流量分析判断哪些内容是可以进劫持处理的再对劫持的内存发起跳转的回复引导户获取内容劫持访问歌但是直有贪玩蓝的告由于明传输运营商会修改你的响应内容即加告劫持由于涉嫌违法已经被监管起来现在很少会有劫持劫持依然常盛最有效的办法就是全站将加密这使得运营商法获取明就法劫持你的响应内容二进程与线程进程与线程的概念从本质上说进程和线程都是工作时间片的一个描述进程描述了在运行指令及加载和保存上下文所需的时间放在应用上来说就代表了一个程序线程是进程中的更小单位描述了执行一段指令所需的时间进程是资源分配的最小单位线程是调度的最小单位一个进程就是一个程序的运行实例详细解释就是启动一个程序的时候操作系统会为该程序创建一块内存用来存放代码运行中的数据和一个执行任务的主线程我们把这样的一个运行环境叫进程进程是运行在虚拟内存上的虚拟内存是用来解决用户对硬件资源的无限需求和有限的硬件资源之间的矛盾的从操作系统角度来看虚拟内存即交换文件从处理器角度看虚拟内存即虚拟地址空间如果程序很多时内存可能会不够操作系统为每个进程提供一套独立的虚拟地址空间从而使得同一块物理内存在不同的进程中可以对应到不同或相同的虚拟地址变相的增加了程序可以使用的内存进程和线程之间的关系有以下四个特点进程中的任意一线程执行出错都会导致整个进程的崩溃线程之间共享进程中的数据当一个进程关闭之后操作系统会回收进程所占用的内存当一个进程退出时操作系统会回收该进程所申请的所有资源即使其中任意线程因为操作不当导致内存泄漏当进程退出时这些内存也会被正确回收进程之间的内容相互隔离进程隔离就是为了使操作系统中的进程互不干扰每一个进程只能访问自己占有的数据也就避免出现进程写入数据到进程的情况正是因为进程之间的数据是严格隔离的所以一个进程如果崩溃了或者挂起了是不会影响到其他进程的如果进程之间需要进行数据的通信这时候就需要使用用于进程间通信的机制了浏览器的架构图从图中可以看出最新的浏览器包括个浏览器主进程个进程个网络进程多个渲染进程多个插件进程这些进程的功能浏览器进程主要负责界面显示用户交互子进程管理同时提供存储等功能渲染进程核心任务是将和转换为用户可以与之交互的网页排版引擎和引擎都是运行在该进程中默认情况下会为每个标签创建一个渲染进程出于安全考虑渲染进程都是运行在沙箱模式下进程其实的使用初衷是为了实现的效果只是随后网页的界面都选择采用来绘制这使得成为浏览器普遍的需求最后在其多进程架构上也引入了进程网络进程主要负责页面的网络资源加载之前是作为一个模块运行在浏览器进程里面的直至最近才独立出来成为一个单独的进程插件进程主要是负责插件的运行因插件易崩溃所以需要通过插件进程来隔离以保证插件进程崩溃不会对浏览器和页面造成影响所以打开一个网页最少需要四个进程个网络进程个浏览器进程个进程以及个渲染进程如果打开的页面有运行插件的话还需要再加上个插件进程虽然多进程模型提升了浏览器的稳定性流畅性和安全性但同样不可避免地带来了一些问题更高的资源占用因为每个进程都会包含公共基础结构的副本如运行环境这就意味着浏览器会消耗更多的内存资源更复杂的体系架构浏览器各模块之间耦合性高扩展性差等问题会导致现在的架构已经很难适应新的需求了进程和线程的区别进程可以看做独立应用线程不能资源进程是资源分配的最小单位是能拥有资源和独立运行的最小单位线程是调度的最小单位线程是建立在进程的基础上的一次程序运行单位一个进程中可以有多个线程通信方面线程间可以通过直接共享同一进程中的资源而进程通信需要借助进程间通信调度进程切换比线程切换的开销要大线程是调度的基本单位线程的切换不会引起进程切换但某个进程中的线程切换到另一个进程中的线程时会引起进程切换系统开销由于创建或撤销进程时系统都要为之分配或回收资源如内存等其开销远大于创建或撤销线程时的开销同理在进行进程切换时涉及当前执行进程环境还有各种各样状态的保存及新调度进程状态的设置而线程切换时只需保存和设置少量寄存器内容开销较小浏览器渲染进程的线程有哪些浏览器的渲染进程的线程总共有五种渲染线程负责渲染浏览器页面解析构建树构建树构建渲染树和绘制页面当界面需要重绘或由于某种操作引发回流时该线程就会执行注意渲染线程和引擎线程是互斥的当引擎执行时线程会被挂起更新会被保存在一个队列中等到引擎空闲时立即被执行引擎线程引擎线程也称为内核负责处理脚本程序解析脚本运行代码引擎线程一直等待着任务队列中任务的到来然后加以处理一个页中无论什么时候都只有一个引擎线程在运行程序注意渲染线程与引擎线程的互斥关系所以如果执行的时间过长会造成页面的渲染不连贯导致页面渲染加载阻塞时间触发线程时间触发线程属于浏览器而不是引擎用来控制事件循环当引擎执行代码块如时也可是来自浏览器内核的其他线程如鼠标点击异步请求等会将对应任务添加到事件触发线程中当对应的事件符合触发条件被触发时该线程会把事件添加到待处理队列的队尾等待引擎的处理注意由于的单线程关系所以这些待处理队列中的事件都得排队等待引擎处理当引擎空闲时才会去执行定时器触发进程定时器触发进程即与所在线程浏览器定时计数器并不是由引擎计数的因为引擎是单线程的如果处于阻塞线程状态就会影响记计时的准确性因此使用单独线程来计时并触发定时器计时完毕后添加到事件队列中等待引擎空闲后执行所以定时器中的任务在设定的时间点不一定能够准时执行定时器只是在指定时间点将任务添加到事件队列中注意在标准中规定定时器的定时时间不能小于如果是小于则默认为异步请求线程连接后通过浏览器新开一个线程请求检测到状态变更时如果设置有回调函数异步线程就产生状态变更事件将回调函数放入事件队列中等待引擎空闲后执行进程之前的通信方式管道通信管道是一种最基本的进程间通信机制管道就是操作系统在内核中开辟的一段缓冲区进程可以将需要交互的数据拷贝到这段缓冲区进程就可以读取了管道的特点只能单向通信只能血缘关系的进程进行通信依赖于文件系统生命周期随进程面向字节流的服务管道内部提供了同步机制消息队列通信消息队列就是一个消息的列表用户可以在消息队列中添加消息读取消息等消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法每个数据块都被认为含有一个类型接收进程可以独立地接收含有不同类型的数据结构可以通过发送消息来避免命名管道的同步和阻塞问题但是消息队列与命名管道一样每个数据块都有一个最大长度的限制使用消息队列进行进程间通信可能会收到数据块最大长度的限制约束等这也是这种通信方式的缺点如果频繁的发生进程间的通信行为那么进程需要频繁地读取队列中的数据到内存相当于间接地从一个进程拷贝到另一个进程这需要花费时间信号量通信共享内存最大的问题就是多进程竞争内存的问题就像类似于线程安全问题我们可以使用信号量来解决这个问题信号量的本质就是一个计数器用来实现进程之间的互斥与同步例如信号量的初始值是然后进程来访问内存的时候我们就把信号量的值设为然后进程也要来访问内存的时候看到信号量的值为就知道已经有进程在访问内存了这个时候进程就会访问不了内存所以说信号量也是进程之间的一种通信方式信号通信信号是系统中使用的最古老的进程间通信的方法之一操作系统通过信号来通知进程系统中发生了某种预先规定好的事件一组事件中的一个它也是用户进程之间通信和同步的一种原始机制共享内存通信共享内存就是映射一段能被其他进程所访问的内存这段共享内存由一个进程创建但多个进程都可以访问使多个进程可以访问同一块内存空间共享内存是最快的方式它是针对其他进程间通信方式运行效率低而专门设计的它往往与其他通信机制如信号量配合使用来实现进程间的同步和通信套接字通信上面我们说的共享内存管道信号量消息队列他们都是多个进程在一台主机之间的通信那两个相隔几千里的进程能够进行通信吗答是必须的这个时候这家伙就派上用场了例如我们平时通过浏览器发起一个请求然后服务器给你返回对应的数据这种就是采用的通信方式了僵尸进程和孤儿进程是什么孤儿进程父进程退出了而它的一个或多个进程还在运行那这些子进程都会成为孤儿进程孤儿进程将被进程进程号为所收养并由进程对它们完成状态收集工作僵尸进程子进程比父进程先结束而父进程又没有释放子进程占用的资源那么子进程的进程描述符仍然保存在系统中这种进程称之为僵死进程死锁产生的原因如果解决死锁的问题所谓死锁是指多个进程在运行过程中因争夺资源而造成的一种僵局当进程处于这种僵持状态时若无外力作用它们都将无法再向前推进系统中的资源可以分为两类可剥夺资源是指某进程在获得这类资源后该资源可以再被其他进程或系统剥夺和主存均属于可剥夺性资源不可剥夺资源当系统把这类资源分配给某进程后再不能强行收回只能在进程用完后自行释放如磁带机打印机等产生死锁的原因竞争资源产生死锁中的竞争资源之一指的是竞争不可剥夺资源例如系统中只有一台打印机可供进程使用假定已占用了打印机若继续要求打印机打印将阻塞产生死锁中的竞争资源另外一种资源指的是竞争临时资源临时资源包括硬件中断信号消息缓冲区内的消息等通常消息通信顺序进行不当则会产生死锁进程间推进顺序非法若保持了资源保持了资源系统处于不安全状态因为这两个进程再向前推进便可能发生死锁例如当运行到时将因已被占用而阻塞当运行到时也将因已被占用而阻塞于是发生进程死锁产生死锁的必要条件互斥条件进程要求对所分配的资源进行排它性控制即在一段时间内某资源仅为一进程所占用请求和保持条件当进程因请求资源而阻塞时对已获得的资源保持不放不剥夺条件进程已获得的资源在未使用完之前不能剥夺只能在使用完时由自己释放环路等待条件在发生死锁时必然存在一个进程资源的环形链预防死锁的方法资源一次性分配一次性分配所有资源这样就不会再有请求了破坏请求条件只要有一个资源得不到分配也不给这个进程分配其他的资源破坏请保持条件可剥夺资源即当某进程获得了部分资源但得不到其它资源则释放已占有的资源破坏不可剥夺条件资源有序分配法系统给每类资源赋予一个编号每一个进程按编号递增的顺序请求资源释放则相反破坏环路等待条件如何实现浏览器内多个标签页之间的通信实现多个标签页之间的通信本质上都是通过中介者模式来实现的因为标签页之间没有办法直接通信因此我们可以找一个中介者让标签页和中介者进行通信然后让这个中介者来进行消息的转发通信方法如下使用协议因为协议可以实现服务器推送所以服务器就可以用来当做这个中介者标签页通过向服务器发送数据然后由服务器向其他标签页推送转发使用的方式会在页面存在的生命周期内创建一个唯一的线程并且开启多个页面也只会使用同一个线程这个时候共享线程就可以充当中介者的角色标签页间通过共享一个线程然后通过这个共享的线程来实现数据的交换使用的方式我们可以在一个标签页对的变化事件进行监听然后当另一个标签页修改数据的时候我们就可以通过这个监听事件来获取到数据这个时候对象就是充当的中介者的角色使用方法如果我们能够获得对应标签页的引用就可以使用方法进行通信对的理解是运行在浏览器背后的独立线程一般可以用来实现缓存功能使用的话传输协议必须为因为中涉及到请求拦截所以必须使用协议来保障安全实现缓存功能一般分为三个步骤首先需要先注册然后监听到事件以后就可以缓存需要的文件那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存存在缓存的话就可以直接读取缓存文件否则就去请求数据以下是这个步骤的实现注册成功注册失败监听事件回调中缓存所需文件拦截所有请求事件如果缓存中已经有请求的数据就直接用缓存否则去请求数据打开页面可以在开发者工具中的看到已经启动了在中也可以发现所需的文件已被缓存三浏览器缓存对浏览器的缓存机制的理解浏览器缓存的全过程浏览器第一次加载资源服务器返回浏览器从服务器下载资源文件并缓存资源文件与以供下次加载时对比使用下一次加载资源时由于强制缓存优先级较高先比较当前时间与上一次返回时的时间差如果没有超过设置的则没有过期并命中强缓存直接从本地读取资源如果浏览器不支持则使用头判断是否过期如果资源已过期则表明强制缓存没有被命中则开始协商缓存向服务器发送带有和的请求服务器收到请求后优先根据的值判断被请求的文件有没有做修改值一致则没有修改命中协商缓存返回如果不一致则有改动直接返回新的资源文件带上新的值并返回如果服务器收到的请求没有值则将和被请求文件的最后修改时间做比对一致则命中协商缓存返回不一致则返回新的和文件并返回很多网站的资源后面都加了版本号这样做的目的是每次升级了或文件后为了防止浏览器进行缓存强制改变版本号客户端浏览器就会重新下载新的或文件以保证用户能够及时获得网站的最新更新浏览器资源缓存的位置有哪些资源缓存的位置一共有种按优先级从高到低分别是运行在主线程之外虽然由于脱离了浏览器窗体无法直接访问但是它可以完成离线缓存消息推送网络代理等功能它可以让我们自由控制缓存哪些文件如何匹配缓存如何读取缓存并且缓存是持续性的当没有命中缓存的时候需要去调用函数获取数据也就是说如果没有在命中缓存会根据缓存查找优先级去查找数据但是不管是从中还是从网络请求中获取的数据浏览器都会显示是从中获取的内容就是内存缓存它的效率最快但是内存缓存虽然读取高效可是缓存持续性很短会随着进程的释放而释放一旦我们关闭页面内存中的缓存也就被释放了也就是存储在硬盘中的缓存读取速度慢点但是什么都能存储到磁盘中比之胜在容量和存储时效性上在所有浏览器缓存中覆盖面基本是最大的它会根据中的字段判断哪些资源需要缓存哪些资源可以不请求直接使用哪些资源已经过期需要重新请求并且即使在跨站点的情况下相同地址的资源一旦被硬盘缓存下来就不会再次去请求数据是中的内容当以上三种缓存都没有命中时它才会被使用并且缓存时间也很短暂只在会话中存在一旦会话结束就被释放其具有以下特点所有的资源都能被推送但是和浏览器兼容性不怎么好可以推送和的资源一旦连接被关闭就被释放多个页面可以使用相同的连接也就是说能使用同样的缓存中的缓存只能被使用一次浏览器可以拒绝接受已经存在的资源推送可以给其他域名推送资源协商缓存和强缓存的区别强缓存使用强缓存策略时如果缓存资源有效则直接使用缓存资源不必再向服务器发起请求强缓存策略可以通过两种方式来设置分别是头信息中的属性和属性服务器通过在响应头中添加属性来指定资源的过期时间在过期时间以内该资源可以被缓存使用不必再向服务器发送请求这个时间是一个绝对时间它是服务器的时间因此可能存在这样的问题就是客户端的时间和服务器端的时间不一致或者用户可以对客户端时间进行修改的情况这样就可能会影响缓存命中的结果是中的方式因为它的一些缺点在中提出了一个新的头部属性就是属性它提供了对资源的缓存的更精确的控制它有很多不同的值可设置的字段设置了该字段值的资源表示可以被任何对象包括发送请求的客户端代理服务器等等缓存这个字段值不常用一般还是使用来精确控制设置了该字段值的资源只能被用户浏览器缓存不允许任何代理服务器缓存在实际开发当中对于一些含有用户信息的通常都要设置这个字段值避免代理服务器缓存设置了该字段需要先和服务端确认返回的资源是否发生了变化如果资源未发生变化则直接使用缓存好的资源设置了该字段表示禁止任何缓存每次都会向服务端发起新的请求拉取最新的资源设置缓存的最大有效期单位为秒优先级高于仅适用于共享缓存优先级高于或者头设置了该字段表明客户端愿意接收已经过期的资源但是不能超过给定的时间限制一般来说只需要设置其中一种方式就可以实现强缓存策略当两种方式一起使用时的优先级要高于和很容易混淆是指先要和服务器确认是否有资源更新在进行判断也就是说没有强缓存但是会有协商缓存是指不使用任何缓存每次请求都直接从服务器获取资源协商缓存如果命中强制缓存我们无需发起新的请求直接使用缓存内容如果没有命中强制缓存如果设置了协商缓存这个时候协商缓存就会发挥作用了上面已经说到了命中协商缓存的条件有两个过期了值为使用协商缓存策略时会先向服务器发送一个请求如果资源没有发生修改则返回一个状态让浏览器使用本地的缓存副本如果资源发生了修改则返回修改后的资源协商缓存也可以通过两种方式来设置分别是头信息中的和属性服务器通过在响应头中添加属性来指出资源最后一次修改的时间当浏览器下一次发起请求时会在请求头中添加一个的属性属性值为上一次资源返回时的的值当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较以此来判断资源是否做了修改如果资源没有修改那么返回状态让客户端使用本地的缓存如果资源已经被修改了则返回修改后的资源使用这种方法有一个缺点就是标注的最后修改时间只能精确到秒级如果某些文件在秒钟以内被修改多次的话那么文件已将改变了但是却没有改变这样会造成缓存命中的不准确因为的这种可能发生的不准确性中提供了另外一种方式那就是属性服务器在返回资源的时候在头信息中添加了属性这个属性是资源生成的唯一标识符当资源发生改变的时候这个值也会发生改变在下一次资源请求时浏览器会在请求头中添加一个属性这个属性的值就是上次返回的资源的的值服务接收到请求后会根据这个值来和资源当前的的值来进行比较以此来判断资源是否发生改变是否需要返回资源通过这种方式比的方式更加精确当和属性同时出现的时候的优先级更高使用协商缓存的时候服务器需要考虑负载平衡的问题因此多个服务器上资源的应该保持一致因为每个服务器上的值都不一样因此在考虑负载平衡时最好不要设置属性总结强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本区别只在于协商缓存会向服务器发送一次请求它们缓存不命中时都会向服务器发送请求来获取资源在实际的缓存机制中强缓存策略和协商缓存策略是一起合作使用的浏览器首先会根据请求的信息判断强缓存是否命中如果命中则直接使用资源如果不命中则根据头信息向服务器发起请求使用协商缓存如果协商缓存命中的话则服务器不返回资源浏览器直接使用本地资源的副本如果协商缓存不命中则浏览器返回最新的资源给浏览器为什么需要浏览器缓存对于浏览器的缓存主要针对的是前端的静态资源最好的效果就是在发起请求之后拉取相应的静态资源并保存在本地如果服务器的静态资源没有更新那么在下次请求的时候就直接从本地读取即可如果服务器的静态资源已经更新那么我们再次请求的时候就到服务器拉取新的资源并保存在本地这样就大大的减少了请求的次数提高了网站的性能这就要用到浏览器的缓存策略了所谓的浏览器缓存指的是浏览器将用户请求过的静态资源存储到电脑本地磁盘中当浏览器再次访问时就可以直接从本地加载不需要再去服务端请求了使用浏览器缓存有以下优点减少了服务器的负担提高了网站的性能加快了客户端网页的加载速度减少了多余网络数据传输点击刷新按钮或者按按强制刷新地址栏回车有什么区别点击刷新按钮或者按浏览器直接对本地的缓存文件过期但是会带上这就意味着服务器会对文件检查新鲜度返回结果可能是也有可能是用户按强制刷新浏览器不仅会对本地文件过期而且不会带上相当于之前从来没有请求过返回结果是地址栏回车浏览器发起请求按照正常流程本地检查是否过期然后服务器检查新鲜度最后返回内容四浏览器组成对浏览器的理解浏览器的主要功能是将用户选择的资源呈现出来它需要从服务器请求资源并将其显示在浏览器窗口中资源的格式通常是也包括及其他格式用户用统一资源标识符来指定所请求资源的位置和规范中规定了浏览器解释文档的方式由组织对这些规范进行维护是负责制定标准的组织但是浏览器厂商纷纷开发自己的扩展对规范的遵循并不完善这为开发者带来了严重的兼容性问题浏览器可以分为两部分和内核其中的种类相对比较多内核则比较少也有一些浏览器并不区分外壳和内核从将独立出来后才有了外壳和内核的明确划分是指浏览器的外壳例如菜单工具栏等主要是提供给用户界面操作参数设置等等它是调用内核来实现各种功能的内核是浏览器的核心内核是基于标记语言显示内容的程序或模块对浏览器内核的理解浏览器内核主要分成两部分渲染引擎的职责就是渲染即在浏览器窗口中显示所请求的内容默认情况下渲染引擎可以显示文档及图片它也可以借助插件显示其他类型数据例如使用阅读器插件可以显示格式引擎解析和执行来实现网页的动态效果最开始渲染引擎和引擎并没有区分的很明确后来引擎越来越独立内核就倾向于只指渲染引擎常见的浏览器内核比较这种浏览器内核是浏览器用的内核因为在早期占有大量的市场份额所以这种内核比较流行以前有很多网页也是根据这个内核的标准来编写的但是实际上这个内核对真正的网页标准支持不是很好但是由于的高市场占有率微软也很长时间没有更新内核就导致了内核和标准脱节还有就是内核的大量等安全问题没有得到解决加上一些专家学者公开自己认为浏览器不安全的观点使很多用户开始转向其他浏览器这是和所采用的内核这个内核的优点就是功能强大丰富可以支持很多复杂网页效果和浏览器扩展接口但是代价是也显而易见就是要消耗很多的资源比如内存曾经采用的就是内核内核被称为公认的浏览网页速度最快的内核这得益于它在开发时的天生优势在处理脚本等脚本语言时会比其他的内核快倍左右缺点就是为了达到很快的速度而丢掉了一部分网页兼容性是采用的内核它的优点就是网页浏览速度较快虽然不及但是也胜于和缺点是对于网页代码的容错性不高也就是说对网页代码的兼容性较低会使一些编写不标准的网页无法正确显示前身是小组的引擎可以说是的一个开源的分支谷歌在上发表博客称将与苹果的开源浏览器核心分道扬镳在项目中研发渲染引擎即浏览器核心内置于浏览器之中其实引擎就是的一个分支就像是的分支一样引擎现在是谷歌公司与共同研发上面提到过的弃用了自己的内核加入阵营跟随谷歌一起研发常见浏览器所用内核浏览器内核内核也是俗称的内核浏览器内核统称为内核或内核以前是内核现在是内核浏览器内核内核俗称内核浏览器内核内核浏览器内核最初是自己的内核后来加入谷歌大军从又到了内核浏览器猎豹浏览器内核双内核搜狗遨游浏览器内核兼容模式高速模式百度浏览器世界之窗内核内核浏览器内核好像以前是内核现在也是双内核了浏览器内核这个众口不一说是他们自己研发的内核但好像还是基于和还有说是基于火狐内核浏览器的主要组成部分户界包括地址栏前进后退按钮书签菜单等除了浏览器主窗显示的您请求的外其他显示的各个部分都属于户界浏览器引擎在户界和呈现引擎之间传送指令呈现引擎负责显示请求的内容如果请求的内容是它就负责解析和内容并将解析后的内容显示在屏幕上络于络调如请求其接与平台关并为所有平台提供底层实现户界后端于绘制基本的窗部件如组合框和窗其公开了与平台关的通接在底层使操作系统的户界法解释器于解析和执代码数据存储这是持久层浏览器需要在硬盘上保存各种数据例如新的规范定义了络数据库这是个完整但是轻便的浏览器内数据库值得注意的是和多数浏览器不同浏览器的每个标签都分别对应个呈现引擎实例每个标签都是个独的进程五浏览器渲染原理浏览器的渲染过程浏览器渲染主要有以下步骤首先解析收到的文档根据文档定义构建一棵树树是由元素及属性节点组成的然后对进行解析生成规则树根据树和规则树构建渲染树渲染树的节点被称为渲染对象渲染对象是一个包含有颜色和大小等属性的矩形渲染对象和元素相对应但这种对应关系不是一对一的不可见的元素不会被插入渲染树还有一些元素对应几个可见对象它们一般是一些具有复杂结构的元素无法用一个矩形来描述当渲染对象被创建并添加到树中它们并没有位置和大小所以当浏览器生成渲染树以后就会根据渲染树来进行布局也可以叫做回流这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小通常这一行为也被称为自动重排布局阶段结束后是绘制阶段遍历渲染树并调用渲染对象的方法将它们的内容显示在屏幕上绘制使用基础组件大致过程如图所示注意这个过程是逐步完成的为了更好的用户体验渲染引擎将会尽可能早的将内容呈现到屏幕上并不会等到所有的都解析完成之后再去构建和布局树它是解析完一部分内容就显示一部分内容同时可能还在通过网络下载其余内容浏览器渲染优化针对既会阻塞的解析也会阻塞的解析因此我们可以对的加载方式进行改变来进行优化尽量将文件放在的最后中间尽量不要写标签标签的引入资源方式有三种有一种就是我们常用的直接引入还有两种就是使用属性和属性来异步引入两者都是去异步加载外部的文件不会阻塞的解析尽量使用异步加载三者的区别如下立即停止页面渲染去加载资源文件当资源加载完毕后立即执行代码代码执行完毕后继续渲染页面是在下载完成之后立即异步加载加载好后立即执行多个带属性的标签不能保证加载的顺序是在下载完成之后立即异步加载加载好后如果树还没构建好则先等树解析好再执行如果树已经准备好则立即执行多个带属性的标签按照顺序执行针对使用有三种方式使用内联样式其中和都是导入外部样式它们之间的区别浏览器会派发一个新等线程线程去加载资源文件与此同时渲染线程会继续向下渲染代码渲染线程会暂时停止渲染去服务器加载资源文件资源文件没有返回之前不会继续渲染阻碍浏览器渲染直接渲染外部样式如果长时间没有加载完毕浏览器为了用户体验会使用浏览器会默认样式确保首次渲染的速度所以一般写在中让浏览器尽快发送请求去获取样式所以在开发过程中导入外部样式使用而不用如果少尽可能采用内嵌样式直接写在标签中针对树树可以通过以下几种方式来减少渲染的时间文件的代码层级尽量不要太深使用语义化的标签来避免不标准语义化的特殊处理减少代码的层级因为选择器是从左向右进行解析的减少回流与重绘操作时尽量在低层级的节点进行操作不要使用布局一个小的改动可能会使整个进行重新布局使用的表达式不要频繁操作元素的样式对于静态页面可以修改类名而不是样式使用或者使元素脱离文档流这样他们发生变化就不会影响其他元素避免频繁操作可以创建一个文档片段在它上面应用所有操作最后再把它添加到文档中将元素先设置操作结束后再把它显示出来因为在属性为的元素上进行的操作不会引发回流和重绘将的多个读操作或者写操作放在一起而不是读写操作穿插着写这得益于浏览器的渲染队列机制浏览器针对页面的回流与重绘进行了自身的优化渲染队列浏览器会将所有的回流重绘的操作放在一个队列中当队列中的操作到了一定的数量或者到了一定的时间间隔浏览器就会对队列进行批处理这样就会让多次的回流重绘变成一次回流重绘将多个读操作或者写操作放在一起就会等所有的读操作进入队列之后执行这样原本应该是触发多次回流变成了只触发一次回流渲染过程中遇到文件如何处理的加载解析与执行会阻塞文档的解析也就是说在构建时解析器若遇到了那么它会暂停文档的解析将控制权移交给引擎等引擎运行完毕浏览器再从中断的地方恢复继续解析文档也就是说如果想要首屏渲染的越快就越不应该在首屏就加载文件这也是都建议将标签放在标签底部的原因当然在当下并不是说标签必须放在底部因为你可以给标签添加或者属性什么是文档的预解析和都做了这个优化当执行脚本时另一个线程解析剩下的文档并加载后面需要通过网络加载的资源这种方式可以使资源并行加载从而使整体速度更快需要注意的是预解析并不改变树它将这个工作留给主解析过程自己只解析外部资源的引用比如外部脚本样式表及图片如何阻塞文档解析理论上既然样式表不改变树也就没有必要停下文档的解析等待它们然而存在一个问题脚本执行时可能在文档的解析过程中请求样式信息如果样式还没有加载和解析脚本将得到错误的值显然这将会导致很多问题所以如果浏览器尚未完成的下载和构建而我们却想在此时运行脚本那么浏览器将延迟脚本执行和文档的解析直至其完成的下载和构建也就是说在这种情况下浏览器会先下载和构建然后再执行最后再继续文档的解析如何优化关键渲染路径为尽快完成首次渲染我们需要最大限度减小以下三种可变因素关键资源的数量关键路径长度关键字节的数量关键资源是可能阻止网页首次渲染的资源这些资源越少浏览器的工作量就越小对以及其他资源的占用也就越少同样关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响某些资源只能在上一资源处理完毕之后才能开始下载并且资源越大下载所需的往返次数就越多最后浏览器需要下载的关键字节越少处理内容并让其出现在屏幕上的速度就越快要减少字节数我们可以减少资源数将它们删除或设为非关键资源此外还要压缩和优化各项资源确保最大限度减小传送大小优化关键渲染路径的常规步骤如下对关键路径进行分析和特性描述资源数字节数长度最大限度减少关键资源的数量删除它们延迟它们的下载将它们标记为异步等优化关键字节数以缩短下载时间往返次数优化其余关键资源的加载顺序您需要尽早下载所有关键资产以缩短关键路径长度什么情况会阻塞渲染首先渲染的前提是生成渲染树所以和肯定会阻塞渲染如果你想渲染的越快你越应该降低一开始需要渲染的文件大小并且扁平层级优化选择器然后当浏览器在解析到标签时会暂停构建完成后才会从暂停的地方重新开始也就是说如果你想首屏渲染的越快就越不应该在首屏就加载文件这也是都建议将标签放在标签底部的原因当然在当下并不是说标签必须放在底部因为你可以给标签添加或者属性当标签加上属性以后表示该文件会并行下载但是会放到解析完成后顺序执行所以对于这种情况你可以把标签放在任意位置对于没有任何依赖的文件可以加上属性表示文件下载和解析不会阻塞渲染六浏览器本地存储浏览器本地存储方式及使用场景是最早被提出来的本地存储方式在此之前服务端是无法判断网络中的两个请求是否是同一用户发起的为解决这个问题就出现了的大小只有它是一种纯文本文件每次发起请求都会携带的特性一旦创建成功名称就无法修改是无法跨域名的也就是说域名和域名下的是无法共享的这也是由的隐私安全性决定的这样就能够阻止非法获取其他网站的每个域名下的数量不能超过个每个的大小不能超过有安全问题如果被拦截了那就可获得的所有信息即使加密也于事无补无需知道的意义只要转发就能达到目的在请求一个新的页面的时候都会被发送过去如果需要域名之间跨域共享有两种方法使用反向代理在一个站点登陆之后往其他网站写服务端的存储到一个节点存储的使用场景最常见的使用场景就是和结合使用我们将存储到中每次发请求都会携带这个这样服务端就知道是谁发起的请求从而响应相应的信息可以用来统计页面的点击次数是新引入的特性由于有的时候我们存储的信息较大就不能满足我们的需求这时候就派上用场了的优点在大小方面的大小一般为可以储存更多的信息是持久储存并不会随着页面的关闭而消失除非主动清理不然会永久存在仅储存在本地不像那样每次请求都会被携带的缺点存在浏览器兼容问题以下版本的浏览器不支持如果浏览器设置为隐私模式那我们将无法读取到受到同源策略的限制即端口协议主机地址有任何一个不相同都不会访问的常用保存数据到从获取数据从删除保存的数据从删除所有保存的数据获取某个索引的的使用场景有些网站有换肤的功能这时候就可以将换肤的信息存储在本地的中当需要换肤的时候直接操作即可在网站中的用户浏览信息也会存储在中还有网站的一些不常变动的个人信息等也可以存储在本地的中和都是在才提出来的存储方案主要用于临时保存同一窗口或标签页的数据刷新页面时不会删除关闭窗口或标签页之后将会删除这些数据与对比和都在本地进行数据存储也有同源策略的限制但是有一条更加严格的限制只有在同一浏览器的同一窗口下才能够共享和都不能被爬虫爬取的常用保存数据到从获取数据从删除保存的数据从删除所有保存的数据获取某个索引的的使用场景由于具有时效性所以可以用来存储一些网站的游客登录的信息还有临时的浏览记录的信息当关闭网站之后这些信息也就随之消除了有哪些字段作用分别是什么由以下字段组成的名称的值对于认证值包括服务器所提供的访问令牌的大小可以访问此的页面路径比如是是那么只有路径下的页面可以读取此指定是否使用安全协议发送使用安全协议可以保护在浏览器和服务器间的传输过程中不被窃取和篡改该方法也可用于站点的身份鉴别即在的连接建立阶段浏览器会检查网站的证书的有效性但是基于兼容性的原因比如有些网站使用自签署的证书在检测到证书无效时浏览器并不会立即终止用户的连接请求而是显示安全风险信息用户仍可以选择继续访问该站点可以访问该的域名机制并未遵循严格的同源策略允许一个子域可以设置或获取其父域的当需要实现单点登录方案时的上述特性非常有用然而也增加了受攻击的危险比如攻击者可以借此发动会话定置攻击因而浏览器禁止在属性中设置等通用顶级域名以及在国家及地区顶级域下注册的二级域名以减小攻击发生的范围该字段包含属性该属性用来设置能否通过脚本来访问默认为空即可以通过脚本访问在客户端是不能通过代码去设置一个类型的的这种类型的只能通过服务端来设置该属性用于防止客户端脚本通过属性访问有助于保护不被跨站脚本攻击窃取或篡改但是的应用仍存在局限性一些浏览器可以阻止客户端脚本对的读操作但允许写操作此外大多数浏览器仍允许通过对象读取响应中的头此的超时时间若设置其值为一个时间那么当到达此时间后此失效不设置的话默认值是意思是会和一起失效当浏览器关闭不是浏览器标签页而是整个浏览器后此失效总结服务器端可以使用的响应头部来配置信息一条包括了个属性值其中指定了失效的时间是域名是路径和一起限制了能够被哪些访问规定了只能在确保安全的情况下传输规定了这个只能被服务器访问不能使用脚本访问区别浏览器端常用的存储技术是和其实最开始是服务器端用于记录用户状态的一种方式由服务器设置在客户端存储然后每次发起同源请求时发送给服务器端最多能存储数据它的生存时间由属性指定并且只能被同源的页面访问共享提供的一种浏览器本地存储的方法它借鉴了服务器端的概念代表的是一次会话中所保存的数据它一般能够存储或者更大的数据它在当前窗口关闭后就失效了并且只能被同一个窗口的同源页面所访问共享提供的一种浏览器本地存储的方法它一般也能够存储或者更大的数据它和不同的是除非手动删除它否则它不会失效并且也只能被同源页面所访问共享上面几种方式都是存储少量数据的时候的存储方式当需要在本地存储大量数据的时候我们可以使用浏览器的这是浏览器提供的一种本地的数据库存储机制它不是关系型数据库它内部采用对象仓库的形式存储数据它更接近数据库前端储存的式有哪些在标准前本地储存的主要式优点是兼容性好请求头带便缺点是只有动请求头加浪费流量每个限制个使起来麻烦需要封装加的以键值对为标准的式优点是操作便永久性储存除动删除为兼容与基本类似区别是当关闭后会被清理且与不同他不能在所有同源窗中共享是会话级别的储存式年被废弃的本地数据库数据存储案但是主流浏览器狐除外都已经有了相关的实现类似于是真正意义上的关系型数据库进操作当我们时要进转换较为繁琐是被正式纳标准的数据库储存案它是数据库键值对进储存可以进快速读取操作常适合场景同时进操作会常便有哪些特点具有以下特点键值对储存内部采用对象仓库存放数据所有类型的数据都可以直接存入包括对象对象仓库中数据以键值对的形式保存每一个数据记录都有对应的主键主键是独一无二的不能有重复否则会抛出一个错误异步操作时不会锁死浏览器用户依然可以进行其他操作这与形成对比后者的操作是同步的异步设计是为了防止大量数据的读写拖慢网页的表现支持事务支持事务这意味着一系列操作步骤之中只要有一步失败整个事务就都取消数据库回滚到事务发生之前的状态不存在只改写一部分数据的情况同源限制受到同源限制每一个数据库对应创建它的域名网页只能访问自身域名下的数据库而不能访问跨域的数据库储存空间大的储存空间比大得多一般来说不少于甚至没有上限支持二进制储存不仅可以储存字符串还可以储存二进制数据对象和对象七浏览器同源策略什么是同源策略跨域问题其实就是浏览器的同源策略造成的同源策略限制了从同一个源加载的文档或脚本如何与另一个源的资源进行交互这是浏览器的一个用于隔离潜在恶意文件的重要的安全机制同源指的是协议端口号域名必须一致下表给出了与的源进行对比的示例是否跨域原因同源完全相同同源只有路径不同跨域协议不同跨域端口不同默认端口是跨域主机不同同源策略协议域名端口三者必须一致同源政策主要限制了三个方面当前域下的脚本不能够访问其他域下的和当前域下的脚本不能够操作访问操作其他域下的当前域下无法发送跨域请求同源政策的目的主要是为了保证用户的信息安全它只是对脚本的一种限制并不是对浏览器的限制对于一般的或者脚本请求都不会有跨域的限制这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作如何解决跨越问题下面是对于的定义跨域资源共享是一种机制它使用额外的头来告诉浏览器让运行在一个上的应用被准许访问来自不同源服务器上的指定的资源当一个资源从与该资源本身所在的服务器不同的域协议或端口请求一个资源时资源会发起一个跨域请求需要浏览器和服务器同时支持整个过程都是浏览器完成的无需用户参与因此实现的关键就是服务器只要服务器实现了请求就可以跨源通信了浏览器将分为简单请求和非简单请求简单请求不会触发预检请求若该请求满足以下两个条件就可以看作是简单请求请求方法是以下三种方法之一的头信息不超出以下几种字段只限于三个值若不满足以上条件就属于非简单请求了简单请求过程对于简单请求浏览器会直接发出请求它会在请求的头信息中增加一个字段该字段用来说明本次请求来自哪个源协议端口域名服务器会根据这个值来决定是否同意这次请求如果指定的域名在许可范围之内服务器返回的响应就会多出以下信息头和一直表示是否允许发送指定返回其他字段的值表示文档类型如果指定的域名不在许可范围之内服务器会返回一个正常的回应浏览器发现没有上面的头部信息就知道出错了这个错误无法通过状态码识别因为返回的状态码可能是在简单请求中在服务器内至少需要设置字段非简单请求过程非简单请求是对服务器有特殊要求的请求比如请求方法为或者等非简单请求的请求会在正式通信之前进行一次查询请求称为预检请求浏览器会询问服务器当前所在的网页是否在服务器允许访问的范围内以及可以使用哪些请求方式和头信息字段只有得到肯定的回复才会进行正式的请求否则就会报错预检请求使用的请求方法是表示这个请求是来询问的他的头信息中的关键字段是表示请求来自哪个源除此之外头信息中还包括两个字段该字段是必须的用来列出浏览器的请求会用到哪些方法该字段是一个逗号分隔的字符串指定浏览器请求会额外发送的头信息字段服务器在收到浏览器的预检请求之后会根据头信息的三个字段来进行判断如果返回的头信息在中有这个字段就是允许跨域请求如果没有就是不同意这个预检请求就会报错服务器回应的的字段如下允许跨域的源地址服务器支持的所有跨域请求的方法服务器支持的所有头信息字段表示是否允许发送用来指定本次预检请求的有效期单位为秒只要服务器通过了预检请求在以后每次的请求都会自带一个头信息字段服务器的回应也都会有一个头信息字段在非简单请求中至少需要设置以下字段减少请求次数请求次数过多就会损耗页面加载的性能降低用户体验度所以尽量要减少请求次数可以后端在请求的返回头部添加它表示预检请求的返回结果可以被缓存多久单位是秒该字段只对完全一样的的缓存设置生效所以设置了缓存时间在这个时间范围内再次发送请求就不需要进行预检请求了中相关问题在请求中如果想要传递就要满足以下三个条件在请求中设置默认情况下在跨域请求浏览器是不带的但是我们可以通过设置来进行传递原生的设置方式设置方式设置为设置为非的原理就是利用标签没有跨域限制通过标签属性发送带有参数的请求服务端将接口返回数据拼凑到函数中返回给浏览器浏览器解析执行从而前端拿到函数返回的数据原生实现传参一个回调函数名给后端方便后端返回时执行这个在前端定义的回调函数回调执行函数服务端返回如下返回时即执行全局函数实现后端代码返回设置的缺点具有局限性仅支持方法不安全可能会遭受攻击跨域是中的且是为数不多可以跨域操作的属性之一它可用于解决以下方面的问题页面和其打开的新窗口的数据传递多窗口之间消息传递页面与嵌套的消息传递上面三个场景的跨域数据传递用法方法接受两个参数规范支持任意基本类型或可复制的对象但部分浏览器只支持字符串所以传参时最好用序列化协议主机端口号也可以设置为表示可以传递给任意窗口如果要指定和当前窗口同源的话设置为向传送跨域数据接受返回数据接收的数据处理后再发回接收的数据处理后再发回代理跨域代理跨域实质和跨域原理一样通过配置文件设置请求响应头等字段配置解决跨域浏览器跨域访问等常规静态资源被同源策略许可但字体文件例外此时可在的静态资源服务器中加入以下配置反向代理接口跨域跨域问题同源策略仅是针对浏览器的安全策略服务器端调用接口只是使用协议不需要同源策略也就不存在跨域问题实现思路通过配置一个代理服务器域名与相同端口不同做跳板机反向代理访问接口并且可以顺便修改中信息方便当前域写入实现跨域访问具体配置服务器反向代理修改里域名当用等中间件代理接口访问时此时无浏览器参与故没有同源限制下面的跨域配置可不启用当前端只跨域不带时可为中间件代理跨域中间件实现跨域代理原理大致与相同都是通过启一个代理服务器实现数据的转发也可以通过设置参数修改响应头中中域名实现当前域的写入方便接口登录认证非框架的跨域使用搭建一个服务器前端代码前端开关浏览器是否读写访问代理服务器中间件服务器代码代理跨域目标接口修改响应头信息实现跨域并允许带修改响应信息中的域名可以为表示不修改框架的跨域搭建的项目跨域请求接口直接修改配置开发环境下渲染服务和接口代理服务都是同一个所以页面与代理接口之间不再跨域部分配置代理跨域目标接口当代理某些服务报错时用可以为表示不修改跨域此方案仅限主域相同子域不同的跨域应用场景实现原理两个页面都通过强制设置为基础主域就实现了同域父窗口子窗口获取父窗口中变量跨域实现原理欲与跨域相互通信通过中间页来实现三个页面不同域之间利用的传值相同域之间直接访问来通信具体实现域域域与不同域只能通过值单向通信与也不同域也只能单向通信但与同域所以可通过访问页面所有对象向传值开放给同域的回调方法监听传来的值再传给监听传来的值再通过操作同域的回调将结果传回跨域属性的独特之处值在不同的页面甚至不同域名加载后依旧存在并且可以支持非常长的值加载跨域页面事件会触发次第次加载跨域页并留存数据于第次同域页成功后读取同域中数据第次跨域页成功后切换到同域代理页面获取数据以后销毁这个释放内存这也保证了安全不被其他域访问请求跨域页面数据中间代理页与同域内容为空即可通过的属性由外域转向本地域跨域数据即由的从外域传递到本地域这个就巧妙地绕过了浏览器的跨域访问限制但同时它又是安全操作协议跨域是一种新的协议它实现了浏览器与服务器全双工通信同时允许跨域通讯是技术的一种很好的实现原生使用起来不太方便我们使用它很好地封装了接口提供了更简单灵活的接口也对不支持的浏览器提供了向下兼容前端代码连接成功处理监听服务端消息监听服务端关闭后台启服务监听连接接收信息断开处理正向代理和反向代理的区别正向代理客户端想获得一个服务器的数据但是因为种种原因无法直接获取于是客户端设置了一个代理服务器并且指定目标服务器之后代理服务器向目标服务器转交请求并将获得的内容发送给客户端这样本质上起到了对真实服务器隐藏真实客户端的目的实现正向代理需要修改客户端比如修改浏览器配置反向代理服务器为了能够将工作负载分不到多个服务器来提高网站性能负载均衡等目的当其受到请求后会首先根据转发规则来确定请求应该被转发到哪个服务器上然后将请求转发到对应的真实服务器上这样本质上起到了对客户端隐藏真实服务器的作用一般使用反向代理后需要通过修改让域名解析到代理服务器这时浏览器无法察觉到真正服务器的存在当然也就不需要修改配置了两者区别如图示正向代理和反向代理的结构是一样的都是的结构它们主要的区别就在于中间这个是哪一方设置的在正向代理中是设置的用来隐藏而在反向代理中是设置的用来隐藏的概念及其工作原理是一款轻量级的服务器也可以用于反向代理负载平衡和缓存等使用异步事件驱动的方法来处理请求是一款面向性能设计的服务器传统的服务器如是模型的而是基于模型的正是这个主要的区别带给了在性能上的优势架构的最顶层是一个这个用于产生其他的这一点和非常像但是的可以同时处理大量的请求而每个只能处理一个八浏览器事件机制事件是什么事件模型事件是用户操作网页时发生的交互动作比如事件除了用户触发的动作外还可以是文档加载窗口滚动和大小调整事件被封装成一个对象包含了该事件发生时的所有相关信息的属性以及可以对事件进行的操作的方法事件是用户操作网页时发生的交互动作或者网页本身的一些操作现代浏览器一共有三种事件模型级事件模型这种模型不会传播所以没有事件流的概念但是现在有的浏览器支持以冒泡的方式实现它可以在网页中直接定义监听函数也可以通过属性来指定监听函数所有浏览器都兼容这种方式直接在对象上注册事件名称就是写法事件模型在该事件模型中一次事件共有两个过程事件处理阶段和事件冒泡阶段事件处理阶段会首先执行目标元素绑定的监听事件然后是事件冒泡阶段冒泡指的是事件从目标元素冒泡到依次检查经过的节点是否绑定了事件监听函数如果有则执行这种模型通过来添加监听函数可以添加多个监听函数会按顺序依次执行级事件模型在该事件模型中一次事件共有三个过程第一个过程是事件捕获阶段捕获指的是事件从一直向下传播到目标元素依次检查经过的节点是否绑定了事件监听函数如果有则执行后面两个阶段和事件模型的两个阶段相同这种事件模型事件绑定的函数是其中第三个参数可以指定事件是否在捕获阶段执行如何阻止事件冒泡普通浏览器使用浏览器使用对事件委托的理解事件委托的概念事件委托本质上是利用了浏览器事件冒泡的机制因为事件在冒泡过程中会上传到父节点父节点可以通过事件对象获取到目标节点因此可以把子节点的监听函数定义在父节点上由父节点的监听函数统一处理多个子元素的事件这种方式称为事件委托事件代理使用事件委托可以不必要为每一个子元素都绑定一个监听事件这样减少了内存上的消耗并且使用事件代理还可以实现事件的动态绑定比如说新增了一个子节点并不需要单独地为它添加一个监听事件它绑定的事件会交给父元素中的监听函数来处理事件委托的特点减少内存消耗如果有一个列表列表之中有大量的列表项需要在点击列表项的时候响应一个事件如果给每个列表项一一都绑定一个函数那对于内存消耗是非常大的效率上需要消耗很多性能因此比较好的方法就是把这个点击事件绑定到他的父层也就是上然后在执行事件时再去匹配判断目标元素所以事件委托可以减少大量的内存消耗节约效率动态绑定事件给上述的例子中每个列表项都绑定事件在很多时候需要通过或者用户操作动态的增加或者去除列表项元素那么在每一次改变的时候都需要重新给新增的元素绑定事件给即将删去的元素解绑事件如果用了事件委托就没有这种麻烦了因为事件是绑定在父层的和目标元素的增减是没有关系的执行到目标元素是在真正响应执行事件函数的过程中去匹配的所以使用事件在动态绑定事件的情况下是可以减少很多重复工作的来实现把下的元素的事件代理委托到它的父层元素也就是上给父层元素绑定事件兼容性处理判断是否匹配目标元素在上述代码中元素则是在元素之下具体被点击的元素然后通过判断的一些属性比如等等可以更精确地匹配到某一类元素之上局限性当然事件委托也是有局限的比如之类的事件没有事件冒泡机制所以无法实现事件委托这样的事件虽然有事件冒泡但是只能不断通过位置去计算定位对性能消耗高因此也是不适合于事件委托的当然事件委托不是只有优点它也是有缺点的事件委托会影响页面性能主要影响因素有元素中绑定事件委托的次数点击的最底层元素到绑定事件元素之间的层数在必须使用事件委托的地方可以进行如下的处理只在必须的地方使用事件委托比如的局部刷新区域尽量的减少绑定的层级不在元素上进行绑定减少绑定的次数如果可以那么把多个事件的绑定合并到一次事件委托中去由这个事件委托的回调来进行分发事件委托的使用场景场景给页面的所有的标签添加事件代码如下但是这些标签可能包含一些像等元素如果点击到了这些标签中的元素就不会触发事件因为事件绑定上在标签元素上而触发这些内部的元素时指向的是触发事件的元素等其他元素这种情况下就可以使用事件委托来处理将事件绑定在标签的内部元素上当点击它的时候就会逐级向上查找知道找到标签为止代码如下同步和异步的区别同步指的是当一个进程在执行某个请求时如果这个请求需要等待一段时间才能返回那么这个进程会一直等待下去直到消息返回为止再继续向下执行异步指的是当一个进程在执行某个请求时如果这个请求需要等待一段时间才能返回这个时候进程会继续往下执行不会阻塞等待消息的返回当消息返回时系统再通知进程进行处理对事件循环的理解因为是单线程运行的在代码执行时通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行在执行同步代码时如果遇到异步事件引擎并不会一直等待其返回结果而是会将这个事件挂起继续执行执行栈中的其他任务当异步事件执行完毕后再将异步事件对应的回调加入到一个任务队列中等待执行任务队列可以分为宏任务队列和微任务队列当当前执行栈中的事件执行完毕后引擎首先会判断微任务队列中是否有任务可以执行如果有就将微任务队首的事件压入栈中执行当微任务队列中的任务都执行完成后再去执行宏任务队列中的任务执行顺序如下所示首先执行同步代码这属于宏任务当执行完所有同步代码后执行栈为空查询是否有异步代码需要执行执行所有微任务当执行完所有微任务后如有必要会渲染页面然后开始下一轮执行宏任务中的异步代码宏任务和微任务分别有哪些微任务包括的回调中的对变化监听的宏任务包括脚本的执行一类的定时事件还有如操作渲染等什么是执行栈可以把执行栈认为是一个存储函数调用的栈结构遵循先进后出的原则当开始执行代码时根据先进后出的原则后执行的函数会先弹出栈可以看到函数后执行当执行完毕后就从栈中弹出了平时在开发中可以在报错中找到执行栈的痕迹可以看到报错在函数函数又是在函数中调用的当使用递归时因为栈可存放的函数是有限制的一旦存放了过多的函数且没有得到释放的话就会出现爆栈的问题中的和浏览器中的有什么区别执行顺序中的和浏览器中的是完全不相同的东西的分为个阶段它们会按照顺序反复运行每当进入某一个阶段的时候都会从对应的回调队列中取出函数去执行当队列为空或者执行的回调函数数量到达系统设定的阈值就会进入下一阶段计时器阶段初次进入事件循环会从计时器阶段开始此阶段会判断是否存在过期的计时器回调包含和如果存在则会执行所有过期的计时器回调执行完毕后如果回调中触发了相应的微任务会接着执行所有微任务执行完微任务后再进入阶段执行推迟到下一个循环迭代的回调系统调用相关的回调仅供内部使用轮询阶段当回调队列不为空时会执行回调若回调中触发了相应的微任务这里的微任务执行时机和其他地方有所不同不会等到所有回调执行完毕后才执行而是针对每一个回调执行完毕后就执行相应微任务执行完所有的回调后变为下面的情况当回调队列为空时没有回调或所有回调执行完毕但如果存在有计时器和没有执行会结束轮询阶段进入阶段否则会阻塞并等待任何正在执行的操作完成并马上执行相应的回调直到所有回调执行完毕查询阶段会检查是否存在相关的回调如果存在则执行所有回调执行完毕后如果回调中触发了相应的微任务会接着执行所有微任务执行完微任务后再进入阶段执行一些关闭回调比如等下面来看一个例子首先在有些情况下定时器的执行顺序其实是随机的对于以上代码来说可能执行在前也可能执行在后首先这是由源码决定的进入事件循环也是需要成本的如果在准备时候花费了大于的时间那么在阶段就会直接执行回调那么如果准备时间花费小于那么就是回调先执行了当然在某些情况下他们的执行顺序一定是固定的比如以下代码在上述代码中永远先执行因为两个代码写在回调中回调是在阶段执行当回调执行完毕后队列为空发现存在回调所以就直接跳转到阶段去执行回调了上面都是的执行情况对于来说它会在以上每个阶段完成前清空队列下图中的就代表了对于以上代码来说其实和浏览器中的输出是一样的永远执行在前面最后来看中的这个函数其实是独立于之外的它有一个自己的队列当每个阶段完成后如果存在队列就会清空队列中的所有回调函数并且优先于其他执行对于以上代码永远都是先把全部打印出来事件触发的过程是怎样的事件触发有三个阶段往事件触发处传播遇到注册的捕获事件会触发传播到事件触发处时触发注册的事件从事件触发处往传播遇到注册的冒泡事件会触发事件触发一般来说会按照上面的顺序进行但是也有特例如果给一个中的子节点同时注册冒泡和捕获事件事件触发会按照注册的顺序执行以下会先打印冒泡然后是捕获冒泡捕获通常使用注册事件该函数的第三个参数可以是布尔值也可以是对象对于布尔值参数来说该参数默认值为决定了注册的事件是捕获事件还是冒泡事件对于对象参数来说可以使用以下几个属性布尔值和作用一样布尔值值为表示该回调只会调用一次调用后会移除监听布尔值表示永远不会调用一般来说如果只希望事件只触发在目标上这时候可以使用来阻止事件的进一步传播通常认为是用来阻止事件冒泡的其实该函数也可以阻止捕获事件同样也能实现阻止事件但是还能阻止该事件目标执行别的注册事件冒泡点击只会执行上面的函数该函数不会执行捕获九浏览器垃圾回收机制的垃圾回收机制是怎样的实现了准确式算法采用了分代式垃圾回收机制因此将内存堆分为新生代和老生代两部分新生代算法新生代中的对象一般存活时间较短使用算法在新生代空间中内存空间分为两部分分别为空间和空间在这两个空间中必定有一个空间是使用的另一个空间是空闲的新分配的对象会被放入空间中当空间被占满时新生代就会启动了算法会检查空间中存活的对象并复制到空间中如果有失活的对象就会销毁当复制完成后将空间和空间互换这样就结束了老生代算法老生代中的对象一般存活时间较长且数量也多使用了两个算法分别是标记清除算法和标记压缩算法先来说下什么情况下对象会出现在老生代空间中新生代中的对象是否已经经历过一次算法如果经历过的话会将对象从新生代空间移到老生代空间中空间的对象占比大小超过在这种情况下为了不影响到内存分配会将对象从新生代空间移到老生代空间中老生代中的空间很复杂有如下几个空间不变的对象空间新生代用于复制算法的空间老生代常驻对象空间老生代代码对象空间老生代对象老生代大空间对象新生代大空间对象在老生代中以下情况会先启动标记清除算法某一个空间没有分块的时候空间中被对象超过一定限制空间不能保证新生代中的对象移动到老生代中在这个阶段中会遍历堆中所有的对象然后标记活的对象在标记完成后销毁所有没有被标记的对象在标记大型对内存时可能需要几百毫秒才能完成一次标记这就会导致一些性能上的问题为了解决这个问题年从标记切换到增量标志在增量标记期间将标记工作分解为更小的模块可以让应用逻辑在模块间隙执行一会从而不至于让应用出现停顿情况但在年技术又有了一个重大突破这项技术名为并发标记该技术可以让扫描和标记对象时同时允许运行清除对象后会造成堆内存出现碎片的情况当碎片超过一定限制后会启动压缩算法在压缩过程中将活的对象向一端移动直到所有对象都移动完成然后清理掉不需要的内存哪些操作会造成内存泄漏第一种情况是由于使用未声明的变量而意外的创建了一个全局变量而使这个变量一直留在内存中无法被回收第二种情况是设置了定时器而忘记取消它如果循环函数有对外部变量的引用的话那么这个变量会被一直留在内存中而无法被回收第三种情况是获取一个元素的引用而后面这个元素被删除由于我们一直保留了对这个元素的引用所以它也无法被回收第四种情况是不合理的使用闭包从而导致某些变量一直被留在内存当中',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-08-19 12:19:03',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://z1.ax1x.com/2023/09/24/pPToDgg.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">By Wang</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Chat-GPT/" style="font-size: 1.05rem;">Chat GPT<sup>1</sup></a><a href="/tags/Linux%E3%80%90Vi%E3%80%91/" style="font-size: 1.05rem;">Linux【Vi】<sup>1</sup></a><a href="/tags/python%E3%80%90%E7%88%AC%E8%99%AB%E3%80%91/" style="font-size: 1.05rem;">python【爬虫】<sup>2</sup></a><a href="/tags/%E3%80%90JavaScript%E3%80%91/" style="font-size: 1.05rem;">【JavaScript】<sup>1</sup></a><a href="/tags/%E3%80%90Python%E3%80%91/" style="font-size: 1.05rem;">【Python】<sup>1</sup></a><a href="/tags/%E3%80%90Typora%E3%80%91/" style="font-size: 1.05rem;">【Typora】<sup>1</sup></a><a href="/tags/%E3%80%90%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E3%80%91/" style="font-size: 1.05rem;">【青龙面板】<sup>1</sup></a><a href="/tags/%E5%86%9B%E5%93%A5%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 1.05rem;">军哥面试题<sup>14</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF%E3%80%90CSS%E3%80%91/" style="font-size: 1.05rem;">前端【CSS】<sup>2</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF%E3%80%90JavaScript%E3%80%91/" style="font-size: 1.05rem;">前端【JavaScript】<sup>6</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF%E3%80%90JaveScript%E3%80%91/" style="font-size: 1.05rem;">前端【JaveScript】<sup>1</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF%E3%80%90Layui%E3%80%91/" style="font-size: 1.05rem;">前端【Layui】<sup>2</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF%E3%80%90Vue%E3%80%91/" style="font-size: 1.05rem;">前端【Vue】<sup>4</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 1.05rem;">博客<sup>1</sup></a><a href="/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/" style="font-size: 1.05rem;">学习日常<sup>4</sup></a><a href="/tags/%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">模拟面试<sup>1</sup></a><a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 1.05rem;">笔记<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">九月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">五月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/04/"><span class="card-archive-list-date">四月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/03/"><span class="card-archive-list-date">三月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%86%9B%E5%93%A5%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url">军哥面试题</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E5%86%9B%E5%93%A5%E9%9D%A2%E8%AF%95%E9%A2%98/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>军哥面试题</span></a></span></div></div><h1 class="post-title" itemprop="name headline">军哥面试题-9.浏览器原理篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2022-08-19T04:19:03.000Z" title="发表于 2022-08-19 12:19:03">2022-08-19</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2022-08-19T04:19:03.000Z" title="更新于 2022-08-19 12:19:03">2022-08-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="军哥面试题-9.浏览器原理篇"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为山东"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>山东</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://source.fomal.cc/img/default_cover_9.webp"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://blog.xiaoadai.com/2022/08/19/9%20offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E7%AF%87/"><header><a class="post-meta-categories" href="/categories/%E5%86%9B%E5%93%A5%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url">军哥面试题</a><a href="/tags/%E5%86%9B%E5%93%A5%E9%9D%A2%E8%AF%95%E9%A2%98/" tabindex="-1" itemprop="url">军哥面试题</a><h1 id="CrawlerTitle" itemprop="name headline">军哥面试题-9.浏览器原理篇</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Tiamo</span><time itemprop="dateCreated datePublished" datetime="2022-08-19T04:19:03.000Z" title="发表于 2022-08-19 12:19:03">2022-08-19</time><time itemprop="dateCreated datePublished" datetime="2022-08-19T04:19:03.000Z" title="更新于 2022-08-19 12:19:03">2022-08-19</time></header><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1621608379974-5f496e1b-b721-4317-bd17-c3bb0411a510.png?x-oss-process=image/resize,w_1038" alt="浏览器原理面试题.png"></p>
<h2 id="一、浏览器安全"><a href="#一、浏览器安全" class="headerlink" title="一、浏览器安全"></a>一、浏览器安全</h2><h3 id="1-什么是-XSS-攻击？"><a href="#1-什么是-XSS-攻击？" class="headerlink" title="1.  什么是 XSS 攻击？"></a>1.  什么是 XSS 攻击？</h3><h4 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h4><p>XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。</p>
<p>XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。</p>
<p>攻击者可以通过这种攻击方式可以进行以下操作：</p>
<ul>
<li>获取页面的数据，如DOM、cookie、localStorage；</li>
<li>DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；</li>
<li>破坏页面结构；</li>
<li>流量劫持（将链接指向某网站）；</li>
</ul>
<h4 id="（2）攻击类型"><a href="#（2）攻击类型" class="headerlink" title="（2）攻击类型"></a>（2）攻击类型</h4><p>XSS 可以分为存储型、反射型和 DOM 型：</p>
<ul>
<li>存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。</li>
<li>反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。 </li>
<li>DOM 型指的通过修改页面的 DOM 节点形成的 XSS。</li>
</ul>
<p><strong>1）存储型</strong> <strong>XSS</strong> <strong>的攻击步骤：</strong> </p>
<ol>
<li>攻击者将恶意代码提交到⽬标⽹站的数据库中。 </li>
<li>⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。 </li>
<li>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。 </li>
<li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。 </li>
</ol>
<p>这种攻击常⻅于带有⽤户保存数据的⽹站功能，如论坛发帖、商品评论、⽤户私信等。</p>
<p><strong>2）反射型</strong> <strong>XSS</strong> <strong>的攻击步骤：</strong> </p>
<ol>
<li>攻击者构造出特殊的 URL，其中包含恶意代码。 </li>
<li>⽤户打开带有恶意代码的 URL 时，⽹站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。 </li>
<li>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。 </li>
<li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。 </li>
</ol>
<p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥。 </p>
<p>反射型 XSS 漏洞常⻅于通过 URL 传递参数的功能，如⽹站搜索、跳转等。 由于需要⽤户主动打开恶意的 URL 才能⽣效，攻击者往往会结合多种⼿段诱导⽤户点击。  </p>
<p><strong>3）DOM</strong> <strong>型</strong> <strong>XSS</strong> <strong>的攻击步骤：</strong> </p>
<ol>
<li>攻击者构造出特殊的 URL，其中包含恶意代码。 </li>
<li>⽤户打开带有恶意代码的 URL。 </li>
<li>⽤户浏览器接收到响应后解析执⾏，前端 JavaScript 取出 URL 中的恶意代码并执⾏。 </li>
<li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。 </li>
</ol>
<p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执⾏恶意代码由浏览器端完成，属于前端JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。 </p>
<h3 id="2-如何防御-XSS-攻击？"><a href="#2-如何防御-XSS-攻击？" class="headerlink" title="2. 如何防御 XSS 攻击？"></a>2. 如何防御 XSS 攻击？</h3><p>可以看到XSS危害如此之大， 那么在开发网站时就要做好防御措施，具体措施如下：</p>
<ul>
<li>可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。</li>
<li>使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。</li>
</ul>
<blockquote>
<ol>
<li>CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。</li>
<li>通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式 <meta http-equiv="Content-Security-Policy"></li>
</ol>
</blockquote>
<ul>
<li>对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。</li>
</ul>
<h3 id="3-什么是-CSRF-攻击？"><a href="#3-什么是-CSRF-攻击？" class="headerlink" title="3. 什么是 CSRF 攻击？"></a>3. 什么是 CSRF 攻击？</h3><h4 id="（1）概念-1"><a href="#（1）概念-1" class="headerlink" title="（1）概念"></a>（1）概念</h4><p>CSRF 攻击指的是<strong>跨站请求伪造攻击</strong>，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。</p>
<p>CSRF 攻击的<strong>本质是****利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。</strong></p>
<h4 id="（2）攻击类型-1"><a href="#（2）攻击类型-1" class="headerlink" title="（2）攻击类型"></a>（2）攻击类型</h4><p>常见的 CSRF 攻击有三种：</p>
<ul>
<li> GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。</li>
<li> POST 类型的 CSRF 攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。</li>
<li>链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。</li>
</ul>
<h3 id="4-如何防御-CSRF-攻击？"><a href="#4-如何防御-CSRF-攻击？" class="headerlink" title="4. 如何防御 CSRF 攻击？"></a>4. 如何防御 CSRF 攻击？</h3><p><strong>CSRF 攻击可以使用以下方法来防护：</strong></p>
<ul>
<li><strong>进行同源检测</strong>，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止请求。这种方式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（Referer 字段会告诉服务器该网页是从哪个页面链接过来的）</li>
<li><strong>使用 CSRF Token 进行验证</strong>，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况可以通过改变 token 的构建方式来解决。</li>
<li><strong>对</strong> <strong>Cookie 进行****双重验证</strong>，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。</li>
<li><strong>在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用</strong>，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。</li>
</ul>
<h3 id="5-什么是中间人攻击？如何防范中间人攻击？"><a href="#5-什么是中间人攻击？如何防范中间人攻击？" class="headerlink" title="5. 什么是中间人攻击？如何防范中间人攻击？"></a>5. 什么是中间人攻击？如何防范中间人攻击？</h3><p>中间⼈ (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独⽴的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过⼀个私密的连接与对⽅直接对话, 但事实上整个会话都被攻击者完全控制。在中间⼈攻击中，攻击者可以拦截通讯双⽅的通话并插⼊新的内容。</p>
<p>攻击过程如下: </p>
<ul>
<li>客户端发送请求到服务端，请求被中间⼈截获 </li>
<li>服务器向客户端发送公钥 </li>
<li>中间⼈截获公钥，保留在⾃⼰⼿上。然后⾃⼰⽣成⼀个<strong>伪造的</strong>公钥，发给客户端 </li>
<li>客户端收到伪造的公钥后，⽣成加密hash值发给服务器 </li>
<li>中间⼈获得加密hash值，⽤⾃⼰的私钥解密获得真秘钥,同时⽣成假的加密hash值，发给服务器 </li>
<li>服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端 </li>
</ul>
<h3 id="6-有哪些可能引起前端安全的问题"><a href="#6-有哪些可能引起前端安全的问题" class="headerlink" title="6. 有哪些可能引起前端安全的问题**?**"></a>6. 有哪些可能引起前端安全的问题**?**</h3><ul>
<li>跨站脚本 (Cross-Site Scripting, XSS): ⼀种代码注⼊⽅式, 为了与 CSS 区分所以被称作 XSS。早期常⻅于⽹络论坛, 起因是⽹站没有对⽤户的输⼊进⾏严格的限制, 使得攻击者可以将脚本上传到帖⼦让其他⼈浏览到有恶意脚本的⻚⾯, 其注⼊⽅式很简单包括但不限于 JavaScript / CSS / Flash 等； </li>
<li>iframe的滥⽤: iframe中的内容是由第三⽅来提供的，默认情况下他们不受控制，他们可以在iframe中运⾏JavaScirpt脚本、Flash插件、弹出对话框等等，这可能会破坏前端⽤户体验；</li>
<li>跨站点请求伪造（Cross-Site Request Forgeries，CSRF）: 指攻击者通过设置好的陷阱，强制对已完成认证的⽤户进⾏⾮预期的个⼈信息或设定信息等某些状态更新，属于被动攻击 </li>
<li>恶意第三⽅库: ⽆论是后端服务器应⽤还是前端应⽤开发，绝⼤多数时候都是在借助开发框架和各种类库进⾏快速开发，⼀旦第三⽅库被植⼊恶意代码很容易引起安全问题。</li>
</ul>
<h3 id="7-网络劫持有哪几种，如何防范？"><a href="#7-网络劫持有哪几种，如何防范？" class="headerlink" title="7. 网络劫持有哪几种，如何防范？"></a>7. 网络劫持有哪几种，如何防范？</h3><p>⽹络劫持分为两种: </p>
<p>（1）<strong>DNS****劫持</strong>: (输⼊京东被强制跳转到淘宝这就属于dns劫持) </p>
<ul>
<li>DNS强制解析: 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器</li>
<li>302跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起302跳转的回复，引导⽤户获取内容 </li>
</ul>
<p>（2）<strong>HTTP****劫持</strong>: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告) </p>
<p>DNS劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS劫持，⽽http劫持依然⾮常盛⾏，最有效的办法就是全站HTTPS，将HTTP加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。 </p>
<h2 id="二、进程与线程"><a href="#二、进程与线程" class="headerlink" title="二、进程与线程"></a>二、进程与线程</h2><h3 id="1-进程与线程的概念"><a href="#1-进程与线程的概念" class="headerlink" title="1. 进程与线程的概念"></a>1. 进程与线程的概念</h3><p>从本质上说，进程和线程都是 CPU 工作时间片的一个描述：</p>
<ul>
<li>进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。</li>
<li>线程是进程中的更小单位，描述了执行一段指令所需的时间。</li>
</ul>
<p><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位。</strong></p>
<p>一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫<strong>进程</strong>。<strong>进程是运行在虚拟内存上的，虚拟内存是用来解决用户对硬件资源的无限需求和有限的硬件资源之间的矛盾的。从操作系统角度来看，虚拟内存即交换文件；从处理器角度看，虚拟内存即虚拟地址空间。</strong></p>
<p>如果程序很多时，内存可能会不够，操作系统为每个进程提供一套独立的虚拟地址空间，从而使得同一块物理内存在不同的进程中可以对应到不同或相同的虚拟地址，变相的增加了程序可以使用的内存。</p>
<p>进程和线程之间的关系有以下四个特点：</p>
<p><strong>（1）进程中的任意一线程执行出错，都会导致整个进程的崩溃。</strong></p>
<p><strong>（2）线程之间共享进程中的数据。</strong></p>
<p><strong>（3）当一个进程关闭之后，操作系统会回收进程所占用的内存，</strong>当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。</p>
<p><strong>（4）进程之间的内容相互隔离。</strong>进程隔离就是为了使操作系统中的进程互不干扰，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信的机制了。</p>
<p><strong>Chrome浏览器的架构图</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603803289911-191cabf3-e7e2-4354-a83d-858668cc116f.png" alt="image"></p>
<p>从图中可以看出，最新的 Chrome 浏览器包括：</p>
<ul>
<li>1 个浏览器主进程</li>
<li>1 个 GPU 进程</li>
<li>1 个网络进程</li>
<li>多个渲染进程</li>
<li>多个插件进程</li>
</ul>
<p>这些进程的功能：</p>
<ul>
<li><strong>浏览器进程</strong>：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li>
<li><strong>渲染进程</strong>：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li>
<li><strong>GPU 进程</strong>：其实， GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</li>
<li><strong>网络进程</strong>：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li>
<li><strong>插件进程</strong>：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li>
</ul>
<p>所以，<strong>打开一个网页，最少需要四个进程</strong>：1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程。如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。</p>
<p>虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：</p>
<ul>
<li><strong>更高的资源占用</strong>：因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。</li>
<li><strong>更复杂的体系架构</strong>：浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。</li>
</ul>
<h3 id="2-进程和线程的区别"><a href="#2-进程和线程的区别" class="headerlink" title="2. 进程和线程的区别"></a>2. 进程和线程的区别</h3><ul>
<li>进程可以看做独立应用，线程不能</li>
<li>资源：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。</li>
<li>通信方面：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助 进程间通信。</li>
<li>调度：进程切换比线程切换的开销要大。线程是CPU调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li>
<li>系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、I/O 等，其开销远大于创建或撤销线程时的开销。同理，在进行进程切换时，涉及当前执行进程 CPU 环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小。</li>
</ul>
<h3 id="3-浏览器渲染进程的线程有哪些"><a href="#3-浏览器渲染进程的线程有哪些" class="headerlink" title="3. 浏览器渲染进程的线程有哪些"></a>3. 浏览器渲染进程的线程有哪些</h3><p>浏览器的渲染进程的线程总共有五种：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603803289922-6462f252-aa33-4cf6-b541-d8bc2e285125.png" alt="image"></p>
<p><strong>（1）GUI渲染线程</strong></p>
<p>负责渲染浏览器页面，解析HTML、CSS，构建DOM树、构建CSSOM树、构建渲染树和绘制页面；当界面需要<strong>重绘</strong>或由于某种操作引发<strong>回流</strong>时，该线程就会执行。</p>
<p>注意：GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</p>
<p><strong>（2）JS引擎线程</strong></p>
<p>JS引擎线程也称为JS内核，负责处理Javascript脚本程序，解析Javascript脚本，运行代码；JS引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个JS引擎线程在运行JS程序；</p>
<p>注意：GUI渲染线程与JS引擎线程的互斥关系，所以如果JS执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p>
<p><strong>（3）时间触发线程</strong></p>
<p><strong>时间触发线程</strong>属于浏览器而不是JS引擎，用来控制事件循环；当JS引擎执行代码块如setTimeOut时（也可是来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件触发线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理；</p>
<p>注意：由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）；</p>
<p><strong>（4）定时器触发进程</strong></p>
<p><strong>定时器触发进程</strong>即setInterval与setTimeout所在线程；浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中；</p>
<p>注意：W3C在HTML标准中规定，定时器的定时时间不能小于4ms，如果是小于4ms，则默认为4ms。</p>
<p><strong>（5）异步http请求线程</strong></p>
<ul>
<li>XMLHttpRequest连接后通过浏览器新开一个线程请求；</li>
<li>检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行；</li>
</ul>
<h3 id="4-进程之前的通信方式"><a href="#4-进程之前的通信方式" class="headerlink" title="4. 进程之前的通信方式"></a>4. 进程之前的通信方式</h3><p><strong>（1）管道通信</strong></p>
<p>管道是一种最基本的进程间通信机制。<strong>管道就是操作系统在内核中开辟的一段缓冲区，进程1可以将需要交互的数据拷贝到这段缓冲区，进程2就可以读取了。</strong></p>
<p>管道的特点：</p>
<ul>
<li>只能单向通信</li>
<li>只能血缘关系的进程进行通信</li>
<li>依赖于文件系统</li>
<li>生命周期随进程</li>
<li>面向字节流的服务</li>
<li>管道内部提供了同步机制</li>
</ul>
<p><strong>（2）消息队列通信</strong></p>
<p>消息队列就是一个消息的列表。用户可以在消息队列中添加消息、读取消息等。消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。 每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。</p>
<p>使用消息队列进行进程间通信，可能会收到数据块最大长度的限制约束等，这也是这种通信方式的缺点。如果频繁的发生进程间的通信行为，那么进程需要频繁地读取队列中的数据到内存，相当于间接地从一个进程拷贝到另一个进程，这需要花费时间。</p>
<p><strong>（3）信号量通信</strong></p>
<p>共享内存最大的问题就是多进程竞争内存的问题，就像类似于线程安全问题。我们可以使用信号量来解决这个问题。信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。所以说，信号量也是进程之间的一种通信方式。</p>
<p><strong>（4）信号通信</strong></p>
<p>信号（Signals ）是Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。</p>
<p><strong>（5）共享内存通信</strong></p>
<p>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问（使多个进程可以访问同一块内存空间）。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p>
<p><strong>（6）套接字通信</strong></p>
<p>上面我们说的共享内存、管道、信号量、消息队列，他们都是多个进程在一台主机之间的通信，那两个相隔几千里的进程能够进行通信吗？答是必须的，这个时候 Socket 这家伙就派上用场了，例如我们平时通过浏览器发起一个 http 请求，然后服务器给你返回对应的数据，这种就是采用 Socket 的通信方式了。</p>
<h3 id="5-僵尸进程和孤儿进程是什么？"><a href="#5-僵尸进程和孤儿进程是什么？" class="headerlink" title="5. 僵尸进程和孤儿进程是什么？"></a>5. 僵尸进程和孤儿进程是什么？</h3><ul>
<li><strong>孤儿进程</strong>：父进程退出了，而它的一个或多个进程还在运行，那这些子进程都会成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</li>
<li><strong>僵尸进程</strong>：子进程比父进程先结束，而父进程又没有释放子进程占用的资源，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵死进程。</li>
</ul>
<h3 id="6-死锁产生的原因？-如果解决死锁的问题？"><a href="#6-死锁产生的原因？-如果解决死锁的问题？" class="headerlink" title="6. 死锁产生的原因？ 如果解决死锁的问题？"></a>6. 死锁产生的原因？ 如果解决死锁的问题？</h3><p>所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。</p>
<p>系统中的资源可以分为两类：</p>
<ul>
<li>可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；</li>
<li>不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。</li>
</ul>
<p><strong>产生死锁的原因：</strong></p>
<p><strong>（1）竞争资源</strong></p>
<ul>
<li>产生死锁中的竞争资源之一指的是<strong>竞争不可剥夺资源</strong>（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）</li>
<li>产生死锁中的竞争资源另外一种资源指的是<strong>竞争临时资源</strong>（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁</li>
</ul>
<p><strong>（2）进程间推进顺序非法</strong></p>
<p>若P1保持了资源R1，P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁</p>
<p><strong>产生死锁的必要条件：</strong></p>
<ul>
<li>互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</li>
<li>请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</li>
<li>环路等待条件：在发生死锁时，必然存在一个进程——资源的环形链。</li>
</ul>
<p><strong>预防死锁的方法：</strong></p>
<ul>
<li>资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）</li>
<li>只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请保持条件）</li>
<li>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</li>
<li>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</li>
</ul>
<h3 id="7-如何实现浏览器内多个标签页之间的通信"><a href="#7-如何实现浏览器内多个标签页之间的通信" class="headerlink" title="7. 如何实现浏览器内多个标签页之间的通信?"></a>7. 如何实现浏览器内多个标签页之间的通信?</h3><p>实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。通信方法如下：</p>
<ul>
<li><strong>使用 websocket 协议</strong>，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。</li>
<li><strong>使用 ShareWorker 的方式</strong>，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。</li>
<li><strong>使****用 localStorage 的方式</strong>，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。</li>
<li><strong>使用 postMessage 方法</strong>，如果我们能够获得对应标签页的引用，就可以使用postMessage 方法，进行通信。</li>
</ul>
<h3 id="8-对Service-Worker的理解"><a href="#8-对Service-Worker的理解" class="headerlink" title="8. 对Service Worker的理解"></a>8. 对Service Worker的理解</h3><p>Service Worker 是运行在浏览器背后的<strong>独立线程</strong>，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 <strong>HTTPS</strong>。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。</p>
<p>Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 <code>install</code> 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。以下是这个步骤的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// index.js</span><br><span class="line">if (navigator.serviceWorker) &#123;</span><br><span class="line">  navigator.serviceWorker</span><br><span class="line">    .register(&#x27;sw.js&#x27;)</span><br><span class="line">    .then(function(registration) &#123;</span><br><span class="line">      console.log(&#x27;service worker 注册成功&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(function(err) &#123;</span><br><span class="line">      console.log(&#x27;servcie worker 注册失败&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// sw.js</span><br><span class="line">// 监听 `install` 事件，回调中缓存所需文件</span><br><span class="line">self.addEventListener(&#x27;install&#x27;, e =&gt; &#123;</span><br><span class="line">  e.waitUntil(</span><br><span class="line">    caches.open(&#x27;my-cache&#x27;).then(function(cache) &#123;</span><br><span class="line">      return cache.addAll([&#x27;./index.html&#x27;, &#x27;./index.js&#x27;])</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line">// 拦截所有请求事件</span><br><span class="line">// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据</span><br><span class="line">self.addEventListener(&#x27;fetch&#x27;, e =&gt; &#123;</span><br><span class="line">  e.respondWith(</span><br><span class="line">    caches.match(e.request).then(function(response) &#123;</span><br><span class="line">      if (response) &#123;</span><br><span class="line">        return response</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(&#x27;fetch source&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>打开页面，可以在开发者工具中的 <code>Application</code> 看到 Service Worker 已经启动了：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1615478097248-5e3c9a93-5683-41de-8787-e87705d31fe1.png?x-oss-process=image/resize,w_1500" alt="image"></p>
<p>在 Cache 中也可以发现所需的文件已被缓存：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1615477994804-e7eaa2c7-91bf-406d-b024-5add76d37d5e.png" alt="image"></p>
<h2 id="三、浏览器缓存"><a href="#三、浏览器缓存" class="headerlink" title="三、浏览器缓存"></a>三、浏览器缓存</h2><h3 id="1-对浏览器的缓存机制的理解"><a href="#1-对浏览器的缓存机制的理解" class="headerlink" title="1. 对浏览器的缓存机制的理解"></a>1. 对浏览器的缓存机制的理解</h3><p><strong>浏览器缓存的全过程：</strong></p>
<ul>
<li>浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用；</li>
<li>下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持HTTP1.1，则使用 expires 头判断是否过期；</li>
<li>如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 If-None-Match 和 If-Modified-Since 的请求；</li>
<li>服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；</li>
<li>如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200；</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1618399660902-60a33dae-cedc-4bd0-9a5b-160c5da3f516.png" alt="业务流程图1.png"></p>
<p>很多网站的资源后面都加了版本号，这样做的目的是：每次升级了 JS 或 CSS 文件后，为了防止浏览器进行缓存，强制改变版本号，客户端浏览器就会重新下载新的 JS 或 CSS 文件 ，以保证用户能够及时获得网站的最新更新。</p>
<h3 id="2-浏览器资源缓存的位置有哪些？"><a href="#2-浏览器资源缓存的位置有哪些？" class="headerlink" title="2. 浏览器资源缓存的位置有哪些？"></a>2. 浏览器资源缓存的位置有哪些？</h3><p>资源缓存的位置一共有 3 种，按优先级从高到低分别是：</p>
<ol>
<li><strong>Service Worker：</strong>Service Worker 运行在 JavaScript 主线程之外，虽然由于脱离了浏览器窗体无法直接访问 DOM，但是它可以完成离线缓存、消息推送、网络代理等功能。它可以让我们<strong>自由控制</strong>缓存哪些文件、如何匹配缓存、如何读取缓存，并且<strong>缓存是持续性的</strong>。当 Service Worker 没有命中缓存的时候，需要去调用 <code>fetch</code> 函数获取  数据。也就是说，如果没有在 Service Worker 命中缓存，会根据缓存查找优先级去查找数据。<strong>但是不管是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示是从 Service Worker 中获取的内容。</strong></li>
<li><strong>Memory Cache：</strong>Memory Cache 就是内存缓存，它的效率最快，<strong>但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。</strong>一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。</li>
<li><strong>Disk Cache：</strong>Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache <strong>胜在容量和存储时效性上。</strong>在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。<strong>并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。</strong></li>
</ol>
<p><strong>Disk Cache：</strong>Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。<strong>并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。</strong>其具有以下特点：</p>
<ul>
<li>所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好</li>
<li>可以推送 <code>no-cache</code> 和 <code>no-store</code> 的资源</li>
<li>一旦连接被关闭，Push Cache 就被释放</li>
<li>多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存</li>
<li>Push Cache 中的缓存只能被使用一次</li>
<li>浏览器可以拒绝接受已经存在的资源推送</li>
<li>可以给其他域名推送资源</li>
</ul>
<h3 id="3-协商缓存和强缓存的区别"><a href="#3-协商缓存和强缓存的区别" class="headerlink" title="3. 协商缓存和强缓存的区别"></a>3. 协商缓存和强缓存的区别</h3><h4 id="（1）强缓存"><a href="#（1）强缓存" class="headerlink" title="（1）强缓存"></a>（1）强缓存</h4><p>使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。</p>
<p>强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。</p>
<p>（1）服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。</p>
<p>（2）Expires 是 http1.0 中的方式，因为它的一些缺点，在 HTTP 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，</p>
<p><code>Cache-Control</code>可设置的字段：</p>
<ul>
<li><code>public</code>：设置了该字段值的资源表示可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是使用max-age=来精确控制；</li>
<li><code>private</code>：设置了该字段值的资源只能被用户浏览器缓存，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的HTML，通常都要设置这个字段值，避免代理服务器(CDN)缓存；</li>
<li><code>no-cache</code>：设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源；</li>
<li><code>no-store</code>：设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源；</li>
<li><code>max-age=</code>：设置缓存的最大有效期，单位为秒；</li>
<li><code>s-maxage=</code>：优先级高于max-age=，仅适用于共享缓存(CDN)，优先级高于max-age或者Expires头；</li>
<li><code>max-stale[=]</code>：设置了该字段表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制。</li>
</ul>
<p>一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires。</p>
<p><strong>no-cache和no-store很容易混淆：</strong></p>
<ul>
<li>no-cache 是指先要和服务器确认是否有资源更新，在进行判断。也就是说没有强缓存，但是会有协商缓存；</li>
<li>no-store 是指不使用任何缓存，每次请求都直接从服务器获取资源。</li>
</ul>
<h4 id="（2）协商缓存"><a href="#（2）协商缓存" class="headerlink" title="（2）协商缓存"></a>（2）协商缓存</h4><p>如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了。</p>
<p>上面已经说到了，命中协商缓存的条件有两个：</p>
<ul>
<li><code>max-age=xxx</code> 过期了</li>
<li>值为<code>no-store</code></li>
</ul>
<p>使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。</p>
<p>协商缓存也可以通过两种方式来设置，分别是 http 头信息中的 <strong>Etag</strong> 和 <strong>Last-Modified</strong> 属性。</p>
<p>（1）服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。</p>
<p>（2）因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。</p>
<p>当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。</p>
<p><strong>总结：</strong></p>
<p>强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。</p>
<h3 id="4-为什么需要浏览器缓存？"><a href="#4-为什么需要浏览器缓存？" class="headerlink" title="4. 为什么需要浏览器缓存？"></a>4. 为什么需要浏览器缓存？</h3><p>对于浏览器的缓存，主要针对的是前端的静态资源，最好的效果就是，在发起请求之后，拉取相应的静态资源，并保存在本地。如果服务器的静态资源没有更新，那么在下次请求的时候，就直接从本地读取即可，如果服务器的静态资源已经更新，那么我们再次请求的时候，就到服务器拉取新的资源，并保存在本地。这样就大大的减少了请求的次数，提高了网站的性能。这就要用到浏览器的缓存策略了。</p>
<p>所谓的<strong>浏览器缓存</strong>指的是浏览器将用户请求过的静态资源，存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载，不需要再去服务端请求了。</p>
<p>使用浏览器缓存，有以下优点：</p>
<ul>
<li>减少了服务器的负担，提高了网站的性能</li>
<li>加快了客户端网页的加载速度</li>
<li>减少了多余网络数据传输</li>
</ul>
<h3 id="5-点击刷新按钮或者按-F5、按-Ctrl-F5-（强制刷新）、地址栏回车有什么区别？"><a href="#5-点击刷新按钮或者按-F5、按-Ctrl-F5-（强制刷新）、地址栏回车有什么区别？" class="headerlink" title="5. 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？"></a>5. 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？</h3><ul>
<li><strong>点击刷新按钮或者按 F5：</strong>浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。</li>
<li><strong>用户按 Ctrl+F5（强制刷新）：</strong>浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是 200。</li>
<li>地址栏回车： 浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。</li>
</ul>
<h2 id="四、浏览器组成"><a href="#四、浏览器组成" class="headerlink" title="四、浏览器组成"></a>四、浏览器组成</h2><h3 id="1-对浏览器的理解"><a href="#1-对浏览器的理解" class="headerlink" title="1. 对浏览器的理解"></a>1. 对浏览器的理解</h3><p>浏览器的主要功能是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是 HTML，也包括 PDF、image 及其他格式。用户用 URI（Uniform Resource Identifier 统一资源标识符）来指定所请求资源的位置。</p>
<p>HTML 和 CSS 规范中规定了浏览器解释 html 文档的方式，由 W3C 组织对这些规范进行维护，W3C 是负责制定 web 标准的组织。但是浏览器厂商纷纷开发自己的扩展，对规范的遵循并不完善，这为 web 开发者带来了严重的兼容性问题。</p>
<p>浏览器可以分为两部分，shell 和 内核。其中 shell 的种类相对比较多，内核则比较少。也有一些浏览器并不区分外壳和内核。从 Mozilla 将 Gecko 独立出来后，才有了外壳和内核的明确划分。</p>
<ul>
<li>shell 是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，参数设置等等。它是调用内核来实现各种功能的。</li>
<li>内核是浏览器的核心。内核是基于标记语言显示内容的程序或模块。</li>
</ul>
<h3 id="2-对浏览器内核的理解"><a href="#2-对浏览器内核的理解" class="headerlink" title="2. 对浏览器内核的理解"></a>2. 对浏览器内核的理解</h3><p>浏览器内核主要分成两部分：</p>
<ul>
<li>渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。</li>
<li>JS 引擎：解析和执行 javascript 来实现网页的动态效果。</li>
</ul>
<p>最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。</p>
<h3 id="3-常见的浏览器内核比较"><a href="#3-常见的浏览器内核比较" class="headerlink" title="3. 常见的浏览器内核比较"></a>3. 常见的浏览器内核比较</h3><ul>
<li><strong>Trident：</strong>这种浏览器内核是 IE 浏览器用的内核，因为在早期 IE 占有大量的市场份额，所以这种内核比较流行，以前有很多网页也是根据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好。但是由于 IE 的高市场占有率，微软也很长时间没有更新 Trident 内核，就导致了 Trident 内核和 W3C 标准脱节。还有就是 Trident 内核的大量 Bug 等安全问题没有得到解决，加上一些专家学者公开自己认为 IE 浏览器不安全的观点，使很多用户开始转向其他浏览器。</li>
<li><strong>Gecko：</strong>这是 Firefox 和 Flock 所采用的内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。</li>
<li><strong>Presto：</strong>Opera 曾经采用的就是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快3倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。</li>
<li><strong>Webkit：</strong>Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和 Trident，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。WebKit 前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。</li>
<li><strong>Blink：</strong>谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实 Blink 引擎就是 Webkit 的一个分支，就像 webkit 是KHTML 的分支一样。Blink 引擎现在是谷歌公司与 Opera Software 共同研发，上面提到过的，Opera 弃用了自己的 Presto 内核，加入 Google 阵营，跟随谷歌一起研发 Blink。</li>
</ul>
<h3 id="4-常见浏览器所用内核"><a href="#4-常见浏览器所用内核" class="headerlink" title="4. 常见浏览器所用内核"></a>4. 常见浏览器所用内核</h3><p>  （1） IE 浏览器内核：Trident 内核，也是俗称的 IE 内核；</p>
<p> （2） Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink内核；</p>
<p> （3） Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核；</p>
<p> （4） Safari 浏览器内核：Webkit 内核；</p>
<p> （5） Opera 浏览器内核：最初是自己的 Presto 内核，后来加入谷歌大军，从 Webkit 又到了 Blink 内核；</p>
<p> （6） 360浏览器、猎豹浏览器内核：IE + Chrome 双内核；</p>
<p> （7） 搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）；</p>
<p> （8） 百度浏览器、世界之窗内核：IE 内核；</p>
<p> （9） 2345浏览器内核：好像以前是 IE 内核，现在也是 IE + Chrome 双内核了；</p>
<p> （10）UC 浏览器内核：这个众口不一，UC 说是他们自己研发的 U3 内核，但好像还是基于 Webkit 和 Trident ，还有说是基于火狐内核。</p>
<h3 id="5-浏览器的主要组成部分"><a href="#5-浏览器的主要组成部分" class="headerlink" title="5. 浏览器的主要组成部分"></a>5. 浏览器的主要组成部分</h3><ul>
<li><strong>⽤户界⾯</strong> - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗⼝显示的您请求的⻚⾯外，其他显示的各个部分都属于⽤户界⾯。 </li>
<li><strong>浏览器引擎</strong> - 在⽤户界⾯和呈现引擎之间传送指令。 </li>
<li><strong>呈现引擎</strong> - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。 </li>
<li><strong>⽹络</strong> - ⽤于⽹络调⽤，⽐如 HTTP 请求。其接⼝与平台⽆关，并为所有平台提供底层实现。 </li>
<li><strong>⽤户界⾯后端</strong> - ⽤于绘制基本的窗⼝⼩部件，⽐如组合框和窗⼝。其公开了与平台⽆关的通⽤接⼝，⽽在底层使⽤操作系统的⽤户界⾯⽅法。 </li>
<li><strong>JavaScript</strong> <strong>解释器</strong>。⽤于解析和执⾏ JavaScript 代码。 </li>
<li><strong>数据存储</strong> - 这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“⽹络数据库”，这是⼀个完整（但是轻便）的浏览器内数据库。 </li>
</ul>
<p>值得注意的是，和⼤多数浏览器不同，Chrome 浏览器的每个标签⻚都分别对应⼀个呈现引擎实例。每个标签⻚都是⼀个独⽴的进程。</p>
<h2 id="五、浏览器渲染原理"><a href="#五、浏览器渲染原理" class="headerlink" title="五、浏览器渲染原理"></a>五、浏览器渲染原理</h2><h3 id="1-浏览器的渲染过程"><a href="#1-浏览器的渲染过程" class="headerlink" title="1. 浏览器的渲染过程"></a>1. 浏览器的渲染过程</h3><p>浏览器渲染主要有以下步骤：</p>
<ul>
<li>首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。</li>
<li>然后对 CSS 进行解析，生成 CSSOM 规则树。</li>
<li>根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</li>
<li>当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。</li>
<li>布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</li>
</ul>
<p>大致过程如图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603797939165-3bf54e28-5469-4093-a0e1-e0569cec1305.png" alt="image"></p>
<p><strong>注意：</strong>这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p>
<h3 id="2-浏览器渲染优化"><a href="#2-浏览器渲染优化" class="headerlink" title="2. 浏览器渲染优化"></a>2. 浏览器渲染优化</h3><p><strong>（1）针对JavaScript：</strong>JavaScript既会阻塞HTML的解析，也会阻塞CSS的解析。因此我们可以对JavaScript的加载方式进行改变，来进行优化：</p>
<p>（1）尽量将JavaScript文件放在body的最后</p>
<p>（2） body中间尽量不要写<code>&lt;script&gt;</code>标签</p>
<p>（3）<code>&lt;script&gt;</code>标签的引入资源方式有三种，有一种就是我们常用的直接引入，还有两种就是使用 async 属性和 defer 属性来异步引入，两者都是去异步加载外部的JS文件，不会阻塞DOM的解析（尽量使用异步加载）。三者的区别如下：</p>
<ul>
<li><strong>script</strong> 立即停止页面渲染去加载资源文件，当资源加载完毕后立即执行js代码，js代码执行完毕后继续渲染页面；</li>
<li><strong>async</strong> 是在下载完成之后，立即异步加载，加载好后立即执行，多个带async属性的标签，不能保证加载的顺序；</li>
<li><strong>defer</strong> 是在下载完成之后，立即异步加载。加载好后，如果 DOM 树还没构建好，则先等 DOM 树解析好再执行；如果DOM树已经准备好，则立即执行。多个带defer属性的标签，按照顺序执行。</li>
</ul>
<p><strong>（2）针对CSS：</strong>使用CSS有三种方式：使用<strong>link、@import、内联样式</strong>，其中link和@import都是导入外部样式。它们之间的区别：</p>
<ul>
<li><strong>link</strong>：浏览器会派发一个新等线程(HTTP线程)去加载资源文件，与此同时GUI渲染线程会继续向下渲染代码</li>
<li><strong>@import</strong>：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(阻碍浏览器渲染)</li>
<li><strong>style</strong>：GUI直接渲染</li>
</ul>
<p>外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器会默认样式，确保首次渲染的速度。所以CSS一般写在headr中，让浏览器尽快发送请求去获取css样式。</p>
<p>所以，在开发过程中，导入外部样式使用link，而不用@import。如果css少，尽可能采用内嵌样式，直接写在style标签中。</p>
<p><strong>（3）针对DOM树、CSSOM树：</strong></p>
<p>可以通过以下几种方式来减少渲染的时间：</p>
<ul>
<li>HTML文件的代码层级尽量不要太深</li>
<li>使用语义化的标签，来避免不标准语义化的特殊处理</li>
<li>减少CSSD代码的层级，因为选择器是从左向右进行解析的</li>
</ul>
<p><strong>（4）减少回流与重绘：</strong></p>
<ul>
<li>操作DOM时，尽量在低层级的DOM节点进行操作</li>
<li>不要使用<code>table</code>布局， 一个小的改动可能会使整个<code>table</code>进行重新布局</li>
<li>使用CSS的表达式</li>
<li>不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。</li>
<li>使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素</li>
<li>避免频繁操作DOM，可以创建一个文档片段<code>documentFragment</code>，在它上面应用所有DOM操作，最后再把它添加到文档中</li>
<li>将元素先设置<code>display: none</code>，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</li>
<li>将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于<strong>浏览器的渲染队列机制</strong>。</li>
</ul>
<p>浏览器针对页面的回流与重绘，进行了自身的优化——<strong>渲染队列</strong></p>
<p><strong>浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。</strong></p>
<p>将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。</p>
<h3 id="3-渲染过程中遇到-JS-文件如何处理？"><a href="#3-渲染过程中遇到-JS-文件如何处理？" class="headerlink" title="3. 渲染过程中遇到 JS 文件如何处理？"></a>3. 渲染过程中遇到 JS 文件如何处理？</h3><p>JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。也就是说，如果想要首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。</p>
<h3 id="4-什么是文档的预解析？"><a href="#4-什么是文档的预解析？" class="headerlink" title="4. 什么是文档的预解析？"></a>4. 什么是文档的预解析？</h3><p>Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</p>
<h3 id="5-CSS-如何阻塞文档解析？"><a href="#5-CSS-如何阻塞文档解析？" class="headerlink" title="5. CSS 如何阻塞文档解析？"></a>5. CSS 如何阻塞文档解析？</h3><p>理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们。然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析。</p>
<h3 id="6-如何优化关键渲染路径？"><a href="#6-如何优化关键渲染路径？" class="headerlink" title="6. 如何优化关键渲染路径？"></a>6. 如何优化关键渲染路径？</h3><p>为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：</p>
<p> （1）关键资源的数量。</p>
<p> （2）关键路径长度。</p>
<p> （3）关键字节的数量。</p>
<p>关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。</p>
<p>优化关键渲染路径的常规步骤如下：</p>
<p> （1）对关键路径进行分析和特性描述：资源数、字节数、长度。</p>
<p> （2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。</p>
<p> （3）优化关键字节数以缩短下载时间（往返次数）。</p>
<p> （4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度</p>
<h3 id="7-什么情况会阻塞渲染？"><a href="#7-什么情况会阻塞渲染？" class="headerlink" title="7. 什么情况会阻塞渲染？"></a>7. 什么情况会阻塞渲染？</h3><p>首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。然后当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。</p>
<p>当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。当 script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。</p>
<h2 id="六、浏览器本地存储"><a href="#六、浏览器本地存储" class="headerlink" title="六、浏览器本地存储"></a>六、浏览器本地存储</h2><h3 id="1-浏览器本地存储方式及使用场景"><a href="#1-浏览器本地存储方式及使用场景" class="headerlink" title="1. 浏览器本地存储方式及使用场景"></a>1. 浏览器本地存储方式及使用场景</h3><h4 id="（1）Cookie"><a href="#（1）Cookie" class="headerlink" title="（1）Cookie"></a>（1）Cookie</h4><p>Cookie是最早被提出来的本地存储方式，在此之前，服务端是无法判断网络中的两个请求是否是同一用户发起的，为解决这个问题，Cookie就出现了。Cookie的大小只有4kb，它是一种纯文本文件，每次发起HTTP请求都会携带Cookie。</p>
<p><strong>Cookie的特性：</strong></p>
<ul>
<li>Cookie一旦创建成功，名称就无法修改</li>
<li>Cookie是无法跨域名的，也就是说a域名和b域名下的cookie是无法共享的，这也是由Cookie的隐私安全性决定的，这样就能够阻止非法获取其他网站的Cookie</li>
<li>每个域名下Cookie的数量不能超过20个，每个Cookie的大小不能超过4kb</li>
<li>有安全问题，如果Cookie被拦截了，那就可获得session的所有信息，即使加密也于事无补，无需知道cookie的意义，只要转发cookie就能达到目的</li>
<li>Cookie在请求一个新的页面的时候都会被发送过去</li>
</ul>
<p>如果需要域名之间跨域共享Cookie，有两种方法：</p>
<ol>
<li>使用Nginx反向代理</li>
<li>在一个站点登陆之后，往其他网站写Cookie。服务端的Session存储到一个节点，Cookie存储sessionId</li>
</ol>
<p><strong>Cookie的使用场景：</strong></p>
<ul>
<li>最常见的使用场景就是Cookie和session结合使用，我们将sessionId存储到Cookie中，每次发请求都会携带这个sessionId，这样服务端就知道是谁发起的请求，从而响应相应的信息。</li>
<li>可以用来统计页面的点击次数</li>
</ul>
<h4 id="（2）LocalStorage"><a href="#（2）LocalStorage" class="headerlink" title="（2）LocalStorage"></a>（2）LocalStorage</h4><p>LocalStorage是HTML5新引入的特性，由于有的时候我们存储的信息较大，Cookie就不能满足我们的需求，这时候LocalStorage就派上用场了。</p>
<p><strong>LocalStorage的优点：</strong></p>
<ul>
<li>在大小方面，LocalStorage的大小一般为5MB，可以储存更多的信息</li>
<li>LocalStorage是持久储存，并不会随着页面的关闭而消失，除非主动清理，不然会永久存在</li>
<li>仅储存在本地，不像Cookie那样每次HTTP请求都会被携带</li>
</ul>
<p><strong>LocalStorage的缺点：</strong></p>
<ul>
<li>存在浏览器兼容问题，IE8以下版本的浏览器不支持</li>
<li>如果浏览器设置为隐私模式，那我们将无法读取到LocalStorage</li>
<li>LocalStorage受到同源策略的限制，即端口、协议、主机地址有任何一个不相同，都不会访问</li>
</ul>
<p><strong>LocalStorage的****常用API：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 保存数据到 localStorage</span><br><span class="line">localStorage.setItem(&#x27;key&#x27;, &#x27;value&#x27;);</span><br><span class="line"></span><br><span class="line">// 从 localStorage 获取数据</span><br><span class="line">let data = localStorage.getItem(&#x27;key&#x27;);</span><br><span class="line"></span><br><span class="line">// 从 localStorage 删除保存的数据</span><br><span class="line">localStorage.removeItem(&#x27;key&#x27;);</span><br><span class="line"></span><br><span class="line">// 从 localStorage 删除所有保存的数据</span><br><span class="line">localStorage.clear();</span><br><span class="line"></span><br><span class="line">// 获取某个索引的Key</span><br><span class="line">localStorage.key(index)</span><br></pre></td></tr></table></figure>

<p><strong>LocalStorage的****使用场景：</strong></p>
<ul>
<li>有些网站有换肤的功能，这时候就可以将换肤的信息存储在本地的LocalStorage中，当需要换肤的时候，直接操作LocalStorage即可</li>
<li>在网站中的用户浏览信息也会存储在LocalStorage中，还有网站的一些不常变动的个人信息等也可以存储在本地的LocalStorage中</li>
</ul>
<h4 id="（3）SessionStorage"><a href="#（3）SessionStorage" class="headerlink" title="（3）SessionStorage"></a>（3）SessionStorage</h4><p>SessionStorage和LocalStorage都是在HTML5才提出来的存储方案，SessionStorage 主要用于临时保存同一窗口(或标签页)的数据，刷新页面时不会删除，关闭窗口或标签页之后将会删除这些数据。</p>
<p><strong>SessionStorage****与LocalStorage对比：</strong></p>
<ul>
<li>SessionStorage和LocalStorage都在<strong>本地进行数据存储</strong>；</li>
<li>SessionStorage也有同源策略的限制，但是SessionStorage有一条更加严格的限制，SessionStorage<strong>只有在同一浏览器的同一窗口下才能够共享</strong>；</li>
<li>LocalStorage和SessionStorage<strong>都不能被爬虫爬取</strong>；</li>
</ul>
<p><strong>SessionStorage的****常用API：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 保存数据到 sessionStorage</span><br><span class="line">sessionStorage.setItem(&#x27;key&#x27;, &#x27;value&#x27;);</span><br><span class="line"></span><br><span class="line">// 从 sessionStorage 获取数据</span><br><span class="line">let data = sessionStorage.getItem(&#x27;key&#x27;);</span><br><span class="line"></span><br><span class="line">// 从 sessionStorage 删除保存的数据</span><br><span class="line">sessionStorage.removeItem(&#x27;key&#x27;);</span><br><span class="line"></span><br><span class="line">// 从 sessionStorage 删除所有保存的数据</span><br><span class="line">sessionStorage.clear();</span><br><span class="line"></span><br><span class="line">// 获取某个索引的Key</span><br><span class="line">sessionStorage.key(index)</span><br></pre></td></tr></table></figure>

<p><strong>SessionStorage的****使用场景</strong></p>
<ul>
<li>由于SessionStorage具有时效性，所以可以用来存储一些网站的游客登录的信息，还有临时的浏览记录的信息。当关闭网站之后，这些信息也就随之消除了。</li>
</ul>
<h3 id="2-Cookie有哪些字段，作用分别是什么"><a href="#2-Cookie有哪些字段，作用分别是什么" class="headerlink" title="2. Cookie有哪些字段，作用分别是什么"></a>2. Cookie有哪些字段，作用分别是什么</h3><p><strong>Cookie由以下字段组成：</strong></p>
<ul>
<li><strong>Name</strong>：cookie的名称</li>
<li><strong>Value</strong>：cookie的值，对于认证cookie，value值包括web服务器所提供的访问令牌；</li>
<li><strong>Size</strong>： cookie的大小</li>
<li><strong>Path</strong>：可以访问此cookie的页面路径。 比如domain是abc.com，path是<code>/test</code>，那么只有<code>/test</code>路径下的页面可以读取此cookie。</li>
<li><strong>Secure</strong>： 指定是否使用HTTPS安全协议发送Cookie。使用HTTPS安全协议，可以保护Cookie在浏览器和Web服务器间的传输过程中不被窃取和篡改。该方法也可用于Web站点的身份鉴别，即在HTTPS的连接建立阶段，浏览器会检查Web网站的SSL证书的有效性。但是基于兼容性的原因（比如有些网站使用自签署的证书）在检测到SSL证书无效时，浏览器并不会立即终止用户的连接请求，而是显示安全风险信息，用户仍可以选择继续访问该站点。</li>
<li><strong>Domain</strong>：可以访问该cookie的域名，Cookie 机制并未遵循严格的同源策略，允许一个子域可以设置或获取其父域的 Cookie。当需要实现单点登录方案时，Cookie 的上述特性非常有用，然而也增加了 Cookie受攻击的危险，比如攻击者可以借此发动会话定置攻击。因而，浏览器禁止在 Domain 属性中设置.org、.com 等通用顶级域名、以及在国家及地区顶级域下注册的二级域名，以减小攻击发生的范围。</li>
<li><strong>HTTP</strong>： 该字段包含<code>HTTPOnly</code> 属性 ，该属性用来设置cookie能否通过脚本来访问，默认为空，即可以通过脚本访问。在客户端是不能通过js代码去设置一个httpOnly类型的cookie的，这种类型的cookie只能通过服务端来设置。该属性用于防止客户端脚本通过<code>document.cookie</code>属性访问Cookie，有助于保护Cookie不被跨站脚本攻击窃取或篡改。但是，HTTPOnly的应用仍存在局限性，一些浏览器可以阻止客户端脚本对Cookie的读操作，但允许写操作；此外大多数浏览器仍允许通过XMLHTTP对象读取HTTP响应中的Set-Cookie头。</li>
<li><strong>Expires/Max-size</strong> ： 此cookie的超时时间。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话默认值是Session，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。</li>
</ul>
<p><strong>总结：</strong></p>
<p>服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了5个属性值 expires、domain、path、secure、HttpOnly。其中 expires 指定了 cookie 失效的时间，domain 是域名、path是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。</p>
<h3 id="3-Cookie、LocalStorage、SessionStorage区别"><a href="#3-Cookie、LocalStorage、SessionStorage区别" class="headerlink" title="3. Cookie、LocalStorage、SessionStorage区别"></a>3. Cookie、LocalStorage、SessionStorage区别</h3><p>浏览器端常用的存储技术是 cookie 、localStorage 和 sessionStorage。</p>
<ul>
<li><strong>cookie：</strong>其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。</li>
<li><strong>sessionStorage：</strong>html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源页面所访问共享。</li>
<li><strong>localStorage：</strong>html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。</li>
</ul>
<p>上面几种方式都是存储少量数据的时候的存储方式，当需要在本地存储大量数据的时候，我们可以使用浏览器的 indexDB 这是浏览器提供的一种本地的数据库存储机制。它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近 NoSQL 数据库。</p>
<h3 id="4-前端储存的⽅式有哪些？"><a href="#4-前端储存的⽅式有哪些？" class="headerlink" title="4. 前端储存的⽅式有哪些？"></a>4. 前端储存的⽅式有哪些？</h3><ul>
<li>cookies： 在HTML5标准前本地储存的主要⽅式，优点是兼容性好，请求头⾃带cookie⽅便，缺点是⼤⼩只有4k，⾃动请求头加⼊cookie浪费流量，每个domain限制20个cookie，使⽤起来麻烦，需要⾃⾏封装；</li>
<li>localStorage：HTML5加⼊的以键值对(Key-Value)为标准的⽅式，优点是操作⽅便，永久性储存（除⾮⼿动删除），⼤⼩为5M，兼容IE8+ ；</li>
<li>sessionStorage：与localStorage基本类似，区别是sessionStorage当⻚⾯关闭后会被清理，⽽且与cookie、localStorage不同，他不能在所有同源窗⼝中共享，是会话级别的储存⽅式； </li>
<li>Web SQL：2010年被W3C废弃的本地数据库数据存储⽅案，但是主流浏览器（⽕狐除外）都已经有了相关的实现，web sql类似于SQLite，是真正意义上的关系型数据库，⽤sql进⾏操作，当我们⽤JavaScript时要进⾏转换，较为繁琐； </li>
<li>IndexedDB： 是被正式纳⼊HTML5标准的数据库储存⽅案，它是NoSQL数据库，⽤键值对进⾏储存，可以进⾏快速读取操作，⾮常适合web场景，同时⽤JavaScript进⾏操作会⾮常便。 </li>
</ul>
<h3 id="5-IndexedDB有哪些特点？"><a href="#5-IndexedDB有哪些特点？" class="headerlink" title="5. IndexedDB有哪些特点？"></a>5. IndexedDB有哪些特点？</h3><p>IndexedDB 具有以下特点：</p>
<ul>
<li><strong>键值对储存</strong>：IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以”键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</li>
<li><strong>异步</strong>：IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。</li>
<li><strong>支持事务</strong>：IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</li>
<li><strong>同源限制：</strong>IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</li>
<li><strong>储存空间大</strong>：IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。</li>
<li><strong>支持二进制储存</strong>：IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。</li>
</ul>
<h2 id="七、浏览器同源策略"><a href="#七、浏览器同源策略" class="headerlink" title="七、浏览器同源策略"></a>七、浏览器同源策略</h2><h3 id="1-什么是同源策略"><a href="#1-什么是同源策略" class="headerlink" title="1. 什么是同源策略"></a>1. 什么是同源策略</h3><p>跨域问题其实就是浏览器的同源策略造成的。</p>
<blockquote>
<p>同源策略限制了从同一个源加载的文档或脚本如何与另一个源的资源进行交互。这是浏览器的一个用于隔离潜在恶意文件的重要的安全机制。同源指的是：<strong>协议</strong>、<strong>端口号</strong>、<strong>域名</strong>必须一致。</p>
</blockquote>
<p>下表给出了与 URL <a target="_blank" rel="noopener" href="http://store.company.com/dir/page.html">http://store.company.com/dir/page.html</a> 的源进行对比的示例:</p>
<table>
<thead>
<tr>
<th>URL</th>
<th>是否跨域</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="http://store.company.com/dir/page.html">http://store.company.com/dir/page.html</a></td>
<td>同源</td>
<td>完全相同</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://store.company.com/dir/inner/another.html">http://store.company.com/dir/inner/another.html</a></td>
<td>同源</td>
<td>只有路径不同</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://store.company.com/secure.html">https://store.company.com/secure.html</a></td>
<td>跨域</td>
<td>协议不同</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://store.company.com:81/dir/etc.html">http://store.company.com:81/dir/etc.html</a></td>
<td>跨域</td>
<td>端口不同 ( http:// 默认端口是80)</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://news.company.com/dir/other.html">http://news.company.com/dir/other.html</a></td>
<td>跨域</td>
<td>主机不同</td>
</tr>
</tbody></table>
<p><strong>同源策略：protocol（协议）、domain（域名）、port（端口）三者必须一致。</strong></p>
<p><strong>同源政策主要限制了三个方面：</strong></p>
<ul>
<li>当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。</li>
<li>当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。</li>
<li>当前域下 ajax 无法发送跨域请求。</li>
</ul>
<p>同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。</p>
<h3 id="2-如何解决跨越问题"><a href="#2-如何解决跨越问题" class="headerlink" title="2. 如何解决跨越问题"></a>2. 如何解决跨越问题</h3><h4 id="（1）CORS"><a href="#（1）CORS" class="headerlink" title="（1）CORS"></a>（1）CORS</h4><p>下面是MDN对于CORS的定义：</p>
<blockquote>
<p>跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器  让运行在一个 origin (domain)上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域HTTP 请求。</p>
</blockquote>
<p>CORS需要浏览器和服务器同时支持，整个CORS过程都是浏览器完成的，无需用户参与。因此实现<strong>CORS的关键就是服务器，只要服务器实现了CORS请求</strong>，就可以跨源通信了。</p>
<p>浏览器将CORS分为<strong>简单请求</strong>和<strong>非简单请求</strong>：</p>
<p>简单请求不会触发CORS预检请求。若该请求满足以下两个条件，就可以看作是简单请求：</p>
<p><strong>1）请求方法是以下三种方法之一：</strong></p>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<p><strong>2）HTTP的头信息不超出以下几种字段：</strong></p>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li>
</ul>
<p>若不满足以上条件，就属于非简单请求了。</p>
<p><strong>（1）简单请求过程：</strong></p>
<p>对于简单请求，浏览器会直接发出CORS请求，它会在请求的头信息中增加一个Orign字段，该字段用来说明本次请求来自哪个源（协议+端口+域名），服务器会根据这个值来决定是否同意这次请求。如果Orign指定的域名在许可范围之内，服务器返回的响应就会多出以下信息头：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com  // 和Orign一直</span><br><span class="line">Access-Control-Allow-Credentials: true   // 表示是否允许发送Cookie</span><br><span class="line">Access-Control-Expose-Headers: FooBar   // 指定返回其他字段的值</span><br><span class="line">Content-Type: text/html; charset=utf-8   // 表示文档类型</span><br></pre></td></tr></table></figure>

<p>如果Orign指定的域名不在许可范围之内，服务器会返回一个正常的HTTP回应，浏览器发现没有上面的Access-Control-Allow-Origin头部信息，就知道出错了。这个错误无法通过状态码识别，因为返回的状态码可能是200。</p>
<p><strong>在简单请求中，在服务器内，至少需要设置字段：</strong><code>**Access-Control-Allow-Origin**</code></p>
<p><strong>（2）非简单请求过程</strong></p>
<p>非简单请求是对服务器有特殊要求的请求，比如请求方法为DELETE或者PUT等。非简单请求的CORS请求会在正式通信之前进行一次HTTP查询请求，<strong>称为预检请求</strong>。</p>
<p>浏览器会询问服务器，当前所在的网页是否在服务器允许访问的范围内，以及可以使用哪些HTTP请求方式和头信息字段，只有得到肯定的回复，才会进行正式的HTTP请求，否则就会报错。</p>
<p>预检请求使用的<strong>请求方法是OPTIONS</strong>，表示这个请求是来询问的。他的头信息中的关键字段是Orign，表示请求来自哪个源。除此之外，头信息中还包括两个字段：</p>
<ul>
<li><strong>Access-Control-Request-Method</strong>：该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法。</li>
<li><strong>Access-Control-Request-Headers</strong>： 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段。</li>
</ul>
<p>服务器在收到浏览器的预检请求之后，会根据头信息的三个字段来进行判断，如果返回的头信息在中有Access-Control-Allow-Origin这个字段就是允许跨域请求，如果没有，就是不同意这个预检请求，就会报错。</p>
<p>服务器回应的CORS的字段如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com  // 允许跨域的源地址</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT // 服务器支持的所有跨域请求的方法</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header  // 服务器支持的所有头信息字段</span><br><span class="line">Access-Control-Allow-Credentials: true   // 表示是否允许发送Cookie</span><br><span class="line">Access-Control-Max-Age: 1728000  // 用来指定本次预检请求的有效期，单位为秒</span><br></pre></td></tr></table></figure>

<p>只要服务器通过了预检请求，在以后每次的CORS请求都会自带一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。</p>
<p><strong>在非简单请求中，至少需要设置以下字段：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x27;Access-Control-Allow-Origin&#x27;  </span><br><span class="line">&#x27;Access-Control-Allow-Methods&#x27;</span><br><span class="line">&#x27;Access-Control-Allow-Headers&#x27;</span><br></pre></td></tr></table></figure>

<h5 id="减少OPTIONS请求次数："><a href="#减少OPTIONS请求次数：" class="headerlink" title="减少OPTIONS请求次数："></a>减少OPTIONS请求次数：</h5><p>OPTIONS请求次数过多就会损耗页面加载的性能，降低用户体验度。所以尽量要减少OPTIONS请求次数，可以后端在请求的返回头部添加：Access-Control-Max-Age：number。它表示预检请求的返回结果可以被缓存多久，单位是秒。该字段只对完全一样的URL的缓存设置生效，所以设置了缓存时间，在这个时间范围内，再次发送请求就不需要进行预检请求了。</p>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="CORS中Cookie相关问题："><a href="#CORS中Cookie相关问题：" class="headerlink" title="CORS中Cookie相关问题："></a>CORS中Cookie相关问题：</h5><p>在CORS请求中，如果想要传递Cookie，就要满足以下三个条件：</p>
<ul>
<li><strong>在请求中设置</strong> <code>**withCredentials**</code></li>
</ul>
<p>默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 withCredentials 来进行传递 cookie.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 原生 xml 的设置方式</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = true;</span><br><span class="line">// axios 设置方式</span><br><span class="line">axios.defaults.withCredentials = true;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Access-Control-Allow-Credentials 设置为 true</strong></li>
<li><strong>Access-Control-Allow-Origin 设置为非</strong> <code>*****</code></li>
</ul>
<h4 id="（2）JSONP"><a href="#（2）JSONP" class="headerlink" title="（2）JSONP"></a>（2）JSONP</h4><p><strong>jsonp</strong>的原理就是利用<code>&lt;script&gt;</code>标签没有跨域限制，通过<code>&lt;script&gt;</code>标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。</p>
<p>1）原生JS实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var script = document.createElement(&#x27;script&#x27;);</span><br><span class="line">    script.type = &#x27;text/javascript&#x27;;</span><br><span class="line">    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数</span><br><span class="line">    script.src = &#x27;http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback&#x27;;</span><br><span class="line">    document.head.appendChild(script);</span><br><span class="line">    // 回调执行函数</span><br><span class="line">    function handleCallback(res) &#123;</span><br><span class="line">        alert(JSON.stringify(res));</span><br><span class="line">    &#125;</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>服务端返回如下（返回时即执行全局函数）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handleCallback(&#123;&quot;success&quot;: true, &quot;user&quot;: &quot;admin&quot;&#125;)</span><br></pre></td></tr></table></figure>

<p>2）Vue axios实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">this.$http = axios;</span><br><span class="line">this.$http.jsonp(&#x27;http://www.domain2.com:8080/login&#x27;, &#123;</span><br><span class="line">    params: &#123;&#125;,</span><br><span class="line">    jsonp: &#x27;handleCallback&#x27;</span><br><span class="line">&#125;).then((res) =&gt; &#123;</span><br><span class="line">    console.log(res); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>后端node.js代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var querystring = require(&#x27;querystring&#x27;);</span><br><span class="line">var http = require(&#x27;http&#x27;);</span><br><span class="line">var server = http.createServer();</span><br><span class="line">server.on(&#x27;request&#x27;, function(req, res) &#123;</span><br><span class="line">    var params = querystring.parse(req.url.split(&#x27;?&#x27;)[1]);</span><br><span class="line">    var fn = params.callback;</span><br><span class="line">    // jsonp返回设置</span><br><span class="line">    res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/javascript&#x27; &#125;);</span><br><span class="line">    res.write(fn + &#x27;(&#x27; + JSON.stringify(params) + &#x27;)&#x27;);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(&#x27;8080&#x27;);</span><br><span class="line">console.log(&#x27;Server is running at port 8080...&#x27;);</span><br></pre></td></tr></table></figure>

<p><strong>JSONP的缺点：</strong></p>
<ul>
<li>具有局限性， 仅支持get方法</li>
<li>不安全，可能会遭受XSS攻击</li>
</ul>
<h4 id="（3）postMessage-跨域"><a href="#（3）postMessage-跨域" class="headerlink" title="（3）postMessage 跨域"></a>（3）postMessage 跨域</h4><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p>
<ul>
<li>页面和其打开的新窗口的数据传递</li>
<li>多窗口之间消息传递</li>
<li>页面与嵌套的iframe消息传递</li>
<li>上面三个场景的跨域数据传递</li>
</ul>
<p>用法：postMessage(data,origin)方法接受两个参数：</p>
<ul>
<li><strong>data</strong>： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。</li>
<li><strong>origin</strong>： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。</li>
</ul>
<p>1）a.html：(domain1.com/a.html)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;       </span><br><span class="line">    var iframe = document.getElementById(&#x27;iframe&#x27;);</span><br><span class="line">    iframe.onload = function() &#123;</span><br><span class="line">        var data = &#123;</span><br><span class="line">            name: &#x27;aym&#x27;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 向domain2传送跨域数据</span><br><span class="line">        iframe.contentWindow.postMessage(JSON.stringify(data), &#x27;http://www.domain2.com&#x27;);</span><br><span class="line">    &#125;;</span><br><span class="line">    // 接受domain2返回数据</span><br><span class="line">    window.addEventListener(&#x27;message&#x27;, function(e) &#123;</span><br><span class="line">        alert(&#x27;data from domain2 ---&gt; &#x27; + e.data);</span><br><span class="line">    &#125;, false);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>2）b.html：(domain2.com/b.html)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 接收domain1的数据</span><br><span class="line">    window.addEventListener(&#x27;message&#x27;, function(e) &#123;</span><br><span class="line">        alert(&#x27;data from domain1 ---&gt; &#x27; + e.data);</span><br><span class="line">        var data = JSON.parse(e.data);</span><br><span class="line">        if (data) &#123;</span><br><span class="line">            data.number = 16;</span><br><span class="line">            // 处理后再发回domain1</span><br><span class="line">            window.parent.postMessage(JSON.stringify(data), &#x27;http://www.domain1.com&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, false);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 接收domain1的数据</span><br><span class="line">    window.addEventListener(&#x27;message&#x27;, function(e) &#123;</span><br><span class="line">        alert(&#x27;data from domain1 ---&gt; &#x27; + e.data);</span><br><span class="line">        var data = JSON.parse(e.data);</span><br><span class="line">        if (data) &#123;</span><br><span class="line">            data.number = 16;</span><br><span class="line">            // 处理后再发回domain1</span><br><span class="line">            window.parent.postMessage(JSON.stringify(data), &#x27;http://www.domain1.com&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, false);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="（4）nginx代理跨域"><a href="#（4）nginx代理跨域" class="headerlink" title="（4）nginx代理跨域"></a>（4）nginx代理跨域</h4><p>nginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段。</p>
<p>1）nginx配置解决iconfont跨域</p>
<p>浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  add_header Access-Control-Allow-Origin *;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）nginx反向代理接口跨域</p>
<p>跨域问题：同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。</p>
<p>实现思路：通过Nginx配置一个代理服务器域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域访问。</p>
<p>nginx具体配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#proxy服务器</span><br><span class="line">server &#123;</span><br><span class="line">    listen       81;</span><br><span class="line">    server_name  www.domain1.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass   http://www.domain2.com:8080;  #反向代理</span><br><span class="line">        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span><br><span class="line">        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*</span><br><span class="line">        add_header Access-Control-Allow-Credentials true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（5）nodejs-中间件代理跨域"><a href="#（5）nodejs-中间件代理跨域" class="headerlink" title="（5）nodejs 中间件代理跨域"></a>（5）nodejs 中间件代理跨域</h4><p>node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。</p>
<p><strong>1）非vue框架的跨域</strong></p>
<p>使用node + express + http-proxy-middleware搭建一个proxy服务器。</p>
<ul>
<li>前端代码：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">// 前端开关：浏览器是否读写cookie</span><br><span class="line">xhr.withCredentials = true;</span><br><span class="line">// 访问http-proxy-middleware代理服务器</span><br><span class="line">xhr.open(&#x27;get&#x27;, &#x27;http://www.domain1.com:3000/login?user=admin&#x27;, true);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>

<ul>
<li>中间件服务器代码：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var express = require(&#x27;express&#x27;);</span><br><span class="line">var proxy = require(&#x27;http-proxy-middleware&#x27;);</span><br><span class="line">var app = express();</span><br><span class="line">app.use(&#x27;/&#x27;, proxy(&#123;</span><br><span class="line">    // 代理跨域目标接口</span><br><span class="line">    target: &#x27;http://www.domain2.com:8080&#x27;,</span><br><span class="line">    changeOrigin: true,</span><br><span class="line">    // 修改响应头信息，实现跨域并允许带cookie</span><br><span class="line">    onProxyRes: function(proxyRes, req, res) &#123;</span><br><span class="line">        res.header(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;http://www.domain1.com&#x27;);</span><br><span class="line">        res.header(&#x27;Access-Control-Allow-Credentials&#x27;, &#x27;true&#x27;);</span><br><span class="line">    &#125;,</span><br><span class="line">    // 修改响应信息中的cookie域名</span><br><span class="line">    cookieDomainRewrite: &#x27;www.domain1.com&#x27;  // 可以为false，表示不修改</span><br><span class="line">&#125;));</span><br><span class="line">app.listen(3000);</span><br><span class="line">console.log(&#x27;Proxy server is listen at port 3000...&#x27;);</span><br></pre></td></tr></table></figure>

<p><strong>2）vue框架的跨域</strong></p>
<p>node + vue + webpack + webpack-dev-server搭建的项目，跨域请求接口，直接修改webpack.config.js配置。开发环境下，vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域。</p>
<p>webpack.config.js部分配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;&#125;,</span><br><span class="line">    module: &#123;&#125;,</span><br><span class="line">    ...</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        historyApiFallback: true,</span><br><span class="line">        proxy: [&#123;</span><br><span class="line">            context: &#x27;/login&#x27;,</span><br><span class="line">            target: &#x27;http://www.domain2.com:8080&#x27;,  // 代理跨域目标接口</span><br><span class="line">            changeOrigin: true,</span><br><span class="line">            secure: false,  // 当代理某些https服务报错时用</span><br><span class="line">            cookieDomainRewrite: &#x27;www.domain1.com&#x27;  // 可以为false，表示不修改</span><br><span class="line">        &#125;],</span><br><span class="line">        noInfo: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（6）document-domain-iframe跨域"><a href="#（6）document-domain-iframe跨域" class="headerlink" title="（6）document.domain + iframe跨域"></a>（6）document.domain + iframe跨域</h4><p>此方案仅限主域相同，子域不同的跨域应用场景。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p>
<p>1）父窗口：(domain.com/a.html)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;http://child.domain.com/b.html&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    document.domain = &#x27;domain.com&#x27;;</span><br><span class="line">    var user = &#x27;admin&#x27;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>1）子窗口：(child.domain.com/a.html)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    document.domain = &#x27;domain.com&#x27;;</span><br><span class="line">    // 获取父窗口中变量</span><br><span class="line">    console.log(&#x27;get js data from parent ---&gt; &#x27; + window.parent.user);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="（7）location-hash-iframe跨域"><a href="#（7）location-hash-iframe跨域" class="headerlink" title="（7）location.hash + iframe跨域"></a>（7）location.hash + iframe跨域</h4><p>实现原理：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p>
<p>具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。</p>
<p>1）a.html：(domain1.com/a.html)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var iframe = document.getElementById(&#x27;iframe&#x27;);</span><br><span class="line">    // 向b.html传hash值</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        iframe.src = iframe.src + &#x27;#user=admin&#x27;;</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">    </span><br><span class="line">    // 开放给同域c.html的回调方法</span><br><span class="line">    function onCallback(res) &#123;</span><br><span class="line">        alert(&#x27;data from c.html ---&gt; &#x27; + res);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>2）b.html：(.domain2.com/b.html)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain1.com/c.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var iframe = document.getElementById(&#x27;iframe&#x27;);</span><br><span class="line">    // 监听a.html传来的hash值，再传给c.html</span><br><span class="line">    window.onhashchange = function () &#123;</span><br><span class="line">        iframe.src = iframe.src + location.hash;</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>3）c.html：(<a href="https://link.zhihu.com/?target=http://www.domain1.com/c.html">http://www.domain1.com/c.html</a>)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 监听b.html传来的hash值</span><br><span class="line">    window.onhashchange = function () &#123;</span><br><span class="line">        // 再通过操作同域a.html的js回调，将结果传回</span><br><span class="line">        window.parent.parent.onCallback(&#x27;hello: &#x27; + location.hash.replace(&#x27;#user=&#x27;, &#x27;&#x27;));</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="（8）window-name-iframe跨域"><a href="#（8）window-name-iframe跨域" class="headerlink" title="（8）window.name + iframe跨域"></a>（8）window.name + iframe跨域</h4><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p>
<p>1）a.html：(domain1.com/a.html)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var proxy = function(url, callback) &#123;</span><br><span class="line">    var state = 0;</span><br><span class="line">    var iframe = document.createElement(&#x27;iframe&#x27;);</span><br><span class="line">    // 加载跨域页面</span><br><span class="line">    iframe.src = url;</span><br><span class="line">    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span><br><span class="line">    iframe.onload = function() &#123;</span><br><span class="line">        if (state === 1) &#123;</span><br><span class="line">            // 第2次onload(同域proxy页)成功后，读取同域window.name中数据</span><br><span class="line">            callback(iframe.contentWindow.name);</span><br><span class="line">            destoryFrame();</span><br><span class="line">        &#125; else if (state === 0) &#123;</span><br><span class="line">            // 第1次onload(跨域页)成功后，切换到同域代理页面</span><br><span class="line">            iframe.contentWindow.location = &#x27;http://www.domain1.com/proxy.html&#x27;;</span><br><span class="line">            state = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    document.body.appendChild(iframe);</span><br><span class="line">    // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）</span><br><span class="line">    function destoryFrame() &#123;</span><br><span class="line">        iframe.contentWindow.document.write(&#x27;&#x27;);</span><br><span class="line">        iframe.contentWindow.close();</span><br><span class="line">        document.body.removeChild(iframe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 请求跨域b页面数据</span><br><span class="line">proxy(&#x27;http://www.domain2.com/b.html&#x27;, function(data)&#123;</span><br><span class="line">    alert(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>2）proxy.html：(domain1.com/proxy.html)</p>
<p>中间代理页，与a.html同域，内容为空即可。</p>
<p>3）b.html：(domain2.com/b.html)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.name = &#x27;This is domain2 data!&#x27;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p>
<h4 id="（9）WebSocket协议跨域"><a href="#（9）WebSocket协议跨域" class="headerlink" title="（9）WebSocket协议跨域"></a>（9）WebSocket协议跨域</h4><p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。</p>
<p>原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p>
<p>1）前端代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;user input：&lt;input type=&quot;text&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var socket = io(&#x27;http://www.domain2.com:8080&#x27;);</span><br><span class="line">// 连接成功处理</span><br><span class="line">socket.on(&#x27;connect&#x27;, function() &#123;</span><br><span class="line">    // 监听服务端消息</span><br><span class="line">    socket.on(&#x27;message&#x27;, function(msg) &#123;</span><br><span class="line">        console.log(&#x27;data from server: ---&gt; &#x27; + msg); </span><br><span class="line">    &#125;);</span><br><span class="line">    // 监听服务端关闭</span><br><span class="line">    socket.on(&#x27;disconnect&#x27;, function() &#123; </span><br><span class="line">        console.log(&#x27;Server socket has closed.&#x27;); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">document.getElementsByTagName(&#x27;input&#x27;)[0].onblur = function() &#123;</span><br><span class="line">    socket.send(this.value);</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>2）Nodejs socket后台：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&#x27;http&#x27;);</span><br><span class="line">var socket = require(&#x27;socket.io&#x27;);</span><br><span class="line">// 启http服务</span><br><span class="line">var server = http.createServer(function(req, res) &#123;</span><br><span class="line">    res.writeHead(200, &#123;</span><br><span class="line">        &#x27;Content-type&#x27;: &#x27;text/html&#x27;</span><br><span class="line">    &#125;);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(&#x27;8080&#x27;);</span><br><span class="line">console.log(&#x27;Server is running at port 8080...&#x27;);</span><br><span class="line">// 监听socket连接</span><br><span class="line">socket.listen(server).on(&#x27;connection&#x27;, function(client) &#123;</span><br><span class="line">    // 接收信息</span><br><span class="line">    client.on(&#x27;message&#x27;, function(msg) &#123;</span><br><span class="line">        client.send(&#x27;hello：&#x27; + msg);</span><br><span class="line">        console.log(&#x27;data from client: ---&gt; &#x27; + msg);</span><br><span class="line">    &#125;);</span><br><span class="line">    // 断开处理</span><br><span class="line">    client.on(&#x27;disconnect&#x27;, function() &#123;</span><br><span class="line">        console.log(&#x27;Client socket has closed.&#x27;); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="3-正向代理和反向代理的区别"><a href="#3-正向代理和反向代理的区别" class="headerlink" title="3. 正向代理和反向代理的区别"></a>3. 正向代理和反向代理的区别</h3><ul>
<li><strong>正向代理：</strong></li>
</ul>
<p>客户端想获得一个服务器的数据，但是因为种种原因无法直接获取。于是客户端设置了一个代理服务器，并且指定目标服务器，之后代理服务器向目标服务器转交请求并将获得的内容发送给客户端。这样本质上起到了对真实服务器隐藏真实客户端的目的。实现正向代理需要修改客户端，比如修改浏览器配置。</p>
<ul>
<li><strong>反向代理：</strong></li>
</ul>
<p>服务器为了能够将工作负载分不到多个服务器来提高网站性能 (负载均衡)等目的，当其受到请求后，会首先根据转发规则来确定请求应该被转发到哪个服务器上，然后将请求转发到对应的真实服务器上。这样本质上起到了对客户端隐藏真实服务器的作用。</p>
<p>一般使用反向代理后，需要通过修改 DNS 让域名解析到代理服务器 IP，这时浏览器无法察觉到真正服务器的存在，当然也就不需要修改配置了。</p>
<p>两者区别如图示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/1500604/1605256274960-50bd9e69-dde9-4782-b2c0-6afc8188fca2.jpeg" alt="image"></p>
<p>正向代理和反向代理的结构是一样的，都是 client-proxy-server 的结构，它们主要的区别就在于中间这个 proxy 是哪一方设置的。在正向代理中，proxy 是 client 设置的，用来隐藏 client；而在反向代理中，proxy 是 server 设置的，用来隐藏 server。</p>
<h3 id="4-Nginx的概念及其工作原理"><a href="#4-Nginx的概念及其工作原理" class="headerlink" title="4. Nginx的概念及其工作原理"></a>4. Nginx的概念及其工作原理</h3><p>Nginx 是一款轻量级的 Web 服务器，也可以用于反向代理、负载平衡和 HTTP 缓存等。Nginx 使用异步事件驱动的方法来处理请求，是一款面向性能设计的 HTTP 服务器。</p>
<p>传统的 Web 服务器如 Apache 是 process-based 模型的，而 Nginx 是基于event-driven模型的。正是这个主要的区别带给了 Nginx 在性能上的优势。</p>
<p>Nginx 架构的最顶层是一个 master process，这个 master process 用于产生其他的 worker process，这一点和Apache 非常像，但是 Nginx 的 worker process 可以同时处理大量的HTTP请求，而每个 Apache process 只能处理一个。</p>
<h2 id="八、浏览器事件机制"><a href="#八、浏览器事件机制" class="headerlink" title="八、浏览器事件机制"></a>八、浏览器事件机制</h2><h3 id="1-事件是什么？事件模型？"><a href="#1-事件是什么？事件模型？" class="headerlink" title="1. 事件是什么？事件模型？"></a>1. 事件是什么？事件模型？</h3><p>事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。</p>
<p>事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型：</p>
<ul>
<li><strong>DOM0 级事件模型</strong>，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。所有浏览器都兼容这种方式。直接在dom对象上注册事件名称，就是DOM0写法。</li>
<li><strong>IE 事件模型</strong>，在该事件模型中，一次事件共有两个过程，事件处理阶段和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。</li>
<li><strong>DOM2 级事件模型</strong>，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。</li>
</ul>
<h3 id="2-如何阻止事件冒泡"><a href="#2-如何阻止事件冒泡" class="headerlink" title="2. 如何阻止事件冒泡"></a>2. 如何阻止事件冒泡</h3><ul>
<li>普通浏览器使用：event.stopPropagation() </li>
<li>IE浏览器使用：event.cancelBubble = true;</li>
</ul>
<h3 id="3-对事件委托的理解"><a href="#3-对事件委托的理解" class="headerlink" title="3. 对事件委托的理解"></a>3. 对事件委托的理解</h3><h4 id="（1）事件委托的概念"><a href="#（1）事件委托的概念" class="headerlink" title="（1）事件委托的概念"></a>（1）事件委托的概念</h4><p>事件委托本质上是利用了<strong>浏览器事件冒泡</strong>的机制。因为事件在冒泡过程中会上传到父节点，父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件委托（事件代理）。</p>
<p>使用事件委托可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理还可以实现事件的动态绑定，比如说新增了一个子节点，并不需要单独地为它添加一个监听事件，它绑定的事件会交给父元素中的监听函数来处理。</p>
<h4 id="（2）事件委托的特点"><a href="#（2）事件委托的特点" class="headerlink" title="（2）事件委托的特点"></a>（2）事件委托的特点</h4><ul>
<li> <strong>减少内存消耗</strong></li>
</ul>
<p>如果有一个列表，列表之中有大量的列表项，需要在点击列表项的时候响应一个事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;list&quot;&gt;</span><br><span class="line">  &lt;li&gt;item 1&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;item 2&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;item 3&lt;/li&gt;</span><br><span class="line">  ......</span><br><span class="line">  &lt;li&gt;item n&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p>如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的，效率上需要消耗很多性能。因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 ul 上，然后在执行事件时再去匹配判断目标元素，所以事件委托可以减少大量的内存消耗，节约效率。</p>
<ul>
<li><strong>动态绑定事件</strong></li>
</ul>
<p>给上述的例子中每个列表项都绑定事件，在很多时候，需要通过 AJAX 或者用户操作动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件；如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的，所以使用事件在动态绑定事件的情况下是可以减少很多重复工作的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 来实现把 #list 下的 li 元素的事件代理委托到它的父层元素也就是 #list 上：</span><br><span class="line">// 给父层元素绑定事件</span><br><span class="line">document.getElementById(&#x27;list&#x27;).addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class="line">  // 兼容性处理</span><br><span class="line">  var event = e || window.event;</span><br><span class="line">  var target = event.target || event.srcElement;</span><br><span class="line">  // 判断是否匹配目标元素</span><br><span class="line">  if (target.nodeName.toLocaleLowerCase === &#x27;li&#x27;) &#123;</span><br><span class="line">    console.log(&#x27;the content is: &#x27;, target.innerHTML);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在上述代码中， target 元素则是在 #list 元素之下具体被点击的元素，然后通过判断 target 的一些属性（比如：nodeName，id 等等）可以更精确地匹配到某一类 #list li 元素之上；</p>
<h4 id="（3）局限性"><a href="#（3）局限性" class="headerlink" title="（3）局限性"></a>（3）局限性</h4><p>当然，事件委托也是有局限的。比如 focus、blur 之类的事件没有事件冒泡机制，所以无法实现事件委托；mousemove、mouseout 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的。</p>
<p>当然事件委托不是只有优点，它也是有<strong>缺点</strong>的，事件委托会影响页面性能，主要影响因素有：</p>
<ul>
<li>元素中，绑定事件委托的次数；</li>
<li>点击的最底层元素，到绑定事件元素之间的<code>DOM</code>层数；</li>
</ul>
<p>在必须使用事件委托的地方，可以进行如下的处理：</p>
<ul>
<li>只在必须的地方，使用事件委托，比如：<code>ajax</code>的局部刷新区域</li>
<li>尽量的减少绑定的层级，不在<code>body</code>元素上，进行绑定</li>
<li>减少绑定的次数，如果可以，那么把多个事件的绑定，合并到一次事件委托中去，由这个事件委托的回调，来进行分发。</li>
</ul>
<h3 id="4-事件委托的使用场景"><a href="#4-事件委托的使用场景" class="headerlink" title="4. 事件委托的使用场景"></a>4. 事件委托的使用场景</h3><p>场景：给页面的所有的a标签添加click事件，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&quot;click&quot;, function(e) &#123;</span><br><span class="line">    if (e.target.nodeName == &quot;A&quot;)</span><br><span class="line">        console.log(&quot;a&quot;);</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>

<p>但是这些a标签可能包含一些像span、img等元素，如果点击到了这些a标签中的元素，就不会触发click事件，因为事件绑定上在a标签元素上，而触发这些内部的元素时，e.target指向的是触发click事件的元素（span、img等其他元素）。</p>
<p>这种情况下就可以使用事件委托来处理，将事件绑定在a标签的内部元素上，当点击它的时候，就会逐级向上查找，知道找到a标签为止，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&quot;click&quot;, function(e) &#123;</span><br><span class="line">    var node = e.target;</span><br><span class="line">    while (node.parentNode.nodeName != &quot;BODY&quot;) &#123;</span><br><span class="line">        if (node.nodeName == &quot;A&quot;) &#123;</span><br><span class="line">            console.log(&quot;a&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.parentNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>

<h3 id="5-同步和异步的区别"><a href="#5-同步和异步的区别" class="headerlink" title="5. 同步和异步的区别"></a>5. 同步和异步的区别</h3><ul>
<li><strong>同步</strong>指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。</li>
<li><strong>异步</strong>指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理。</li>
</ul>
<h3 id="6-对事件循环的理解"><a href="#6-对事件循环的理解" class="headerlink" title="6. 对事件循环的理解"></a>6. 对事件循环的理解</h3><p>因为 js 是单线程运行的，在代码执行时，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码时，如果遇到异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到一个任务队列中等待执行。任务队列可以分为宏任务队列和微任务队列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务队列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务队列中的任务都执行完成后再去执行宏任务队列中的任务。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1615476500217-472563e1-de67-403f-baa7-0fd574d0e618.png?x-oss-process=image/resize,w_1500" alt="image"></p>
<p>Event Loop 执行顺序如下所示：</p>
<ul>
<li>首先执行同步代码，这属于宏任务</li>
<li>当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行</li>
<li>执行所有微任务</li>
<li>当执行完所有微任务后，如有必要会渲染页面</li>
<li>然后开始下一轮 Event Loop，执行宏任务中的异步代码</li>
</ul>
<h3 id="7-宏任务和微任务分别有哪些"><a href="#7-宏任务和微任务分别有哪些" class="headerlink" title="7. 宏任务和微任务分别有哪些"></a>7. 宏任务和微任务分别有哪些</h3><ul>
<li>微任务包括： promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。</li>
<li>宏任务包括： script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲染等。</li>
</ul>
<h3 id="8-什么是执行栈"><a href="#8-什么是执行栈" class="headerlink" title="8. 什么是执行栈"></a>8. 什么是执行栈</h3><p>可以把执行栈认为是一个存储函数调用的<strong>栈结构</strong>，遵循先进后出的原则。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/gif/1500604/1615476375478-4f0a93a1-de5e-4536-9bbe-4e69c1f91773.gif" alt="image"></p>
<p>当开始执行 JS 代码时，根据先进后出的原则，后执行的函数会先弹出栈，可以看到，<code>foo</code> 函数后执行，当执行完毕后就从栈中弹出了。</p>
<p>平时在开发中，可以在报错中找到执行栈的痕迹：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  throw new Error(&#x27;error&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">function bar() &#123;</span><br><span class="line">  foo()</span><br><span class="line">&#125;</span><br><span class="line">bar()</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1615476375462-269c6a54-a21d-460c-aa82-a713ef9a2999.png" alt="img"></p>
<p>可以看到报错在 <code>foo</code> 函数，<code>foo</code> 函数又是在 <code>bar</code> 函数中调用的。当使用递归时，因为栈可存放的函数是有<strong>限制</strong>的，一旦存放了过多的函数且没有得到释放的话，就会出现爆栈的问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function bar() &#123;</span><br><span class="line">  bar()</span><br><span class="line">&#125;</span><br><span class="line">bar()</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1615476375388-2867ba62-cf27-4740-91fd-485f0ae12986.png" alt="img"></p>
<h3 id="9-Node-中的-Event-Loop-和浏览器中的有什么区别？process-nextTick-执行顺序？"><a href="#9-Node-中的-Event-Loop-和浏览器中的有什么区别？process-nextTick-执行顺序？" class="headerlink" title="9. Node 中的 Event Loop 和浏览器中的有什么区别？process.nextTick 执行顺序？"></a>9. Node 中的 Event Loop 和浏览器中的有什么区别？process.nextTick 执行顺序？</h3><p>Node 中的 Event Loop 和浏览器中的是完全不相同的东西。</p>
<p>Node 的 Event Loop 分为 6 个阶段，它们会按照<strong>顺序</strong>反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1615476641904-a9763034-9114-4a7c-aa50-1bdb612f2f5e.png" alt="image"></p>
<p>（1）<strong>Timers（计时器阶段）</strong>：初次进入事件循环，会从计时器阶段开始。此阶段会判断是否存在过期的计时器回调（包含 setTimeout 和 setInterval），如果存在则会执行所有过期的计时器回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Pending callbacks 阶段。</p>
<p>（2）<strong>Pending callbacks</strong>：执行推迟到下一个循环迭代的I / O回调（系统调用相关的回调）。</p>
<p>（3）<strong>Idle/Prepare</strong>：仅供内部使用。</p>
<p>（4）<strong>Poll（轮询阶段）</strong>：</p>
<ul>
<li>当回调队列不为空时：会执行回调，若回调中触发了相应的微任务，这里的微任务执行时机和其他地方有所不同，不会等到所有回调执行完毕后才执行，而是针对每一个回调执行完毕后，就执行相应微任务。执行完所有的回调后，变为下面的情况。</li>
<li>当回调队列为空时（没有回调或所有回调执行完毕）：但如果存在有计时器（setTimeout、setInterval和setImmediate）没有执行，会结束轮询阶段，进入 Check 阶段。否则会阻塞并等待任何正在执行的I/O操作完成，并马上执行相应的回调，直到所有回调执行完毕。</li>
</ul>
<p>（5）<strong>Check（查询阶段）</strong>：会检查是否存在 setImmediate 相关的回调，如果存在则执行所有回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Close callbacks 阶段。</p>
<p>（6）<strong>Close callbacks</strong>：执行一些关闭回调，比如socket.on(‘close’, …)等。</p>
<p>下面来看一个例子，首先在有些情况下，定时器的执行顺序其实是<strong>随机</strong>的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;setTimeout&#x27;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">setImmediate(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;setImmediate&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>对于以上代码来说，<code>setTimeout</code> 可能执行在前，也可能执行在后</p>
<ul>
<li>首先 <code>setTimeout(fn, 0) === setTimeout(fn, 1)</code>，这是由源码决定的</li>
<li>进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 <code>setTimeout</code> 回调</li>
<li>那么如果准备时间花费小于 1ms，那么就是 <code>setImmediate</code> 回调先执行了</li>
</ul>
<p>当然在某些情况下，他们的执行顺序一定是固定的，比如以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line">fs.readFile(__filename, () =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&#x27;timeout&#x27;);</span><br><span class="line">    &#125;, 0)</span><br><span class="line">    setImmediate(() =&gt; &#123;</span><br><span class="line">        console.log(&#x27;immediate&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>setImmediate</code> 永远<strong>先执行</strong>。因为两个代码写在 IO 回调中，IO 回调是在 poll 阶段执行，当回调执行完毕后队列为空，发现存在 <code>setImmediate</code> 回调，所以就直接跳转到 check 阶段去执行回调了。</p>
<p>上面都是 macrotask 的执行情况，对于 microtask 来说，它会在以上每个阶段完成前<strong>清空</strong> microtask 队列，下图中的 Tick 就代表了 microtask</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1615476641927-75409d91-38a1-4797-aa75-cb02dd95d732.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;timer21&#x27;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">Promise.resolve().then(function() &#123;</span><br><span class="line">  console.log(&#x27;promise1&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>对于以上代码来说，其实和浏览器中的输出是一样的，microtask 永远执行在 macrotask 前面。</p>
<p>最后来看 Node 中的 <code>process.nextTick</code>，这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会<strong>清空队列中的所有回调函数</strong>，并且优先于其他 microtask 执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line"> console.log(&#x27;timer1&#x27;)</span><br><span class="line"> Promise.resolve().then(function() &#123;</span><br><span class="line">   console.log(&#x27;promise1&#x27;)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">process.nextTick(() =&gt; &#123;</span><br><span class="line"> console.log(&#x27;nextTick&#x27;)</span><br><span class="line"> process.nextTick(() =&gt; &#123;</span><br><span class="line">   console.log(&#x27;nextTick&#x27;)</span><br><span class="line">   process.nextTick(() =&gt; &#123;</span><br><span class="line">     console.log(&#x27;nextTick&#x27;)</span><br><span class="line">     process.nextTick(() =&gt; &#123;</span><br><span class="line">       console.log(&#x27;nextTick&#x27;)</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>对于以上代码，永远都是先把 nextTick 全部打印出来。</p>
<h3 id="10-事件触发的过程是怎样的"><a href="#10-事件触发的过程是怎样的" class="headerlink" title="10. 事件触发的过程是怎样的"></a>10. 事件触发的过程是怎样的</h3><p>事件触发有三个阶段：</p>
<ul>
<li><code>window</code> 往事件触发处传播，遇到注册的捕获事件会触发</li>
<li>传播到事件触发处时触发注册的事件</li>
<li>从事件触发处往 <code>window</code> 传播，遇到注册的冒泡事件会触发</li>
</ul>
<p>事件触发一般来说会按照上面的顺序进行，但是也有特例，<strong>如果给一个</strong> <code>**body**</code> <strong>中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 以下会先打印冒泡然后是捕获</span><br><span class="line">node.addEventListener(</span><br><span class="line">  &#x27;click&#x27;,</span><br><span class="line">  event =&gt; &#123;</span><br><span class="line">    console.log(&#x27;冒泡&#x27;)</span><br><span class="line">  &#125;,</span><br><span class="line">  false</span><br><span class="line">)</span><br><span class="line">node.addEventListener(</span><br><span class="line">  &#x27;click&#x27;,</span><br><span class="line">  event =&gt; &#123;</span><br><span class="line">    console.log(&#x27;捕获 &#x27;)</span><br><span class="line">  &#125;,</span><br><span class="line">  true</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>通常使用 <code>addEventListener</code> 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 <code>useCapture</code> 参数来说，该参数默认值为 <code>false</code> ，<code>useCapture</code> 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性：</p>
<ul>
<li><code>capture</code>：布尔值，和 <code>useCapture</code> 作用一样</li>
<li><code>once</code>：布尔值，值为 <code>true</code> 表示该回调只会调用一次，调用后会移除监听</li>
<li><code>passive</code>：布尔值，表示永远不会调用 <code>preventDefault</code></li>
</ul>
<p>一般来说，如果只希望事件只触发在目标上，这时候可以使用 <code>stopPropagation</code> 来阻止事件的进一步传播。通常认为 <code>stopPropagation</code> 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。</p>
<p><code>stopImmediatePropagation</code> 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">node.addEventListener(</span><br><span class="line">  &#x27;click&#x27;,</span><br><span class="line">  event =&gt; &#123;</span><br><span class="line">    event.stopImmediatePropagation()</span><br><span class="line">    console.log(&#x27;冒泡&#x27;)</span><br><span class="line">  &#125;,</span><br><span class="line">  false</span><br><span class="line">)</span><br><span class="line">// 点击 node 只会执行上面的函数，该函数不会执行</span><br><span class="line">node.addEventListener(</span><br><span class="line">  &#x27;click&#x27;,</span><br><span class="line">  event =&gt; &#123;</span><br><span class="line">    console.log(&#x27;捕获 &#x27;)</span><br><span class="line">  &#125;,</span><br><span class="line">  true</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="九、浏览器垃圾回收机制"><a href="#九、浏览器垃圾回收机制" class="headerlink" title="九、浏览器垃圾回收机制"></a>九、浏览器垃圾回收机制</h2><h3 id="1-V8的垃圾回收机制是怎样的"><a href="#1-V8的垃圾回收机制是怎样的" class="headerlink" title="1. V8的垃圾回收机制是怎样的"></a>1. V8的垃圾回收机制是怎样的</h3><p>V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。</p>
<p><strong>（1）新生代算法</strong></p>
<p>新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。</p>
<p>在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。</p>
<p><strong>（2）老生代算法</strong></p>
<p>老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。</p>
<p>先来说下什么情况下对象会出现在老生代空间中：</p>
<ul>
<li>新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。</li>
<li>To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。</li>
</ul>
<p>老生代中的空间很复杂，有如下几个空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">enum AllocationSpace &#123;</span><br><span class="line">  // TODO(v8:7464): Actually map this space&#x27;s memory as read-only.</span><br><span class="line">  RO_SPACE,    // 不变的对象空间</span><br><span class="line">  NEW_SPACE,   // 新生代用于 GC 复制算法的空间</span><br><span class="line">  OLD_SPACE,   // 老生代常驻对象空间</span><br><span class="line">  CODE_SPACE,  // 老生代代码对象空间</span><br><span class="line">  MAP_SPACE,   // 老生代 map 对象</span><br><span class="line">  LO_SPACE,    // 老生代大空间对象</span><br><span class="line">  NEW_LO_SPACE,  // 新生代大空间对象</span><br><span class="line">  FIRST_SPACE = RO_SPACE,</span><br><span class="line">  LAST_SPACE = NEW_LO_SPACE,</span><br><span class="line">  FIRST_GROWABLE_PAGED_SPACE = OLD_SPACE,</span><br><span class="line">  LAST_GROWABLE_PAGED_SPACE = MAP_SPACE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在老生代中，以下情况会先启动标记清除算法：</p>
<ul>
<li>某一个空间没有分块的时候</li>
<li>空间中被对象超过一定限制</li>
<li>空间不能保证新生代中的对象移动到老生代中</li>
</ul>
<p>在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行。</p>
<p>清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象向一端移动，直到所有对象都移动完成然后清理掉不需要的内存。</p>
<h3 id="2-哪些操作会造成内存泄漏？"><a href="#2-哪些操作会造成内存泄漏？" class="headerlink" title="2. 哪些操作会造成内存泄漏？"></a>2. 哪些操作会造成内存泄漏？</h3><ul>
<li>第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li>
<li>第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li>
<li>第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。</li>
<li>第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li>
</ul>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://z1.ax1x.com/2023/09/24/pPToDgg.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://z1.ax1x.com/2023/09/24/pPToDgg.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Tiamo</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://blog.xiaoadai.com/2022/08/19/9%20offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E7%AF%87/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://blog.xiaoadai.com/2022/08/19/9%20offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E7%AF%87/')">军哥面试题-9.浏览器原理篇</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://blog.xiaoadai.com/2022/08/19/9%20offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E7%AF%87/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=军哥面试题-9.浏览器原理篇&amp;url=https://blog.xiaoadai.com/2022/08/19/9%20offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E7%AF%87/&amp;pic=https://source.fomal.cc/img/default_cover_9.webp" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.xiaoadai.com" target="_blank">By Wang</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E5%86%9B%E5%93%A5%E9%9D%A2%E8%AF%95%E9%A2%98/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>军哥面试题<span class="tagsPageCount">14</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://source.fomal.cc/img/default_cover_7.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/08/18/8%20offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://source.fomal.cc/img/default_cover_8.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">军哥面试题-8.计算机网络篇</div></div></a></div><div class="next-post pull-right"><a href="/2022/08/20/10%20offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%AF%87/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://source.fomal.cc/img/default_cover_10.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">军哥面试题-10.手写代码篇</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2022/08/10/1%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/" title="军哥面试题--1.前端面试准备"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://source.fomal.cc/img/default_cover_1.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-08-10</div><div class="title">军哥面试题--1.前端面试准备</div></div></a></div><div><a href="/2022/08/21/11%20offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%AF%87/" title="军哥面试题-11.代码输出篇"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://source.fomal.cc/img/default_cover_11.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-08-21</div><div class="title">军哥面试题-11.代码输出篇</div></div></a></div><div><a href="/2022/08/20/10%20offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%AF%87/" title="军哥面试题-10.手写代码篇"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://source.fomal.cc/img/default_cover_10.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-08-20</div><div class="title">军哥面试题-10.手写代码篇</div></div></a></div><div><a href="/2022/08/23/13%20offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8BVue%E7%AF%87/" title="军哥面试题-13.Vue篇"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://source.fomal.cc/img/default_cover_13.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-08-23</div><div class="title">军哥面试题-13.Vue篇</div></div></a></div><div><a href="/2022/08/22/12LeetCode%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83%E9%A2%98%E7%9B%AE/" title="军哥面试题-12.LeetCode面试常考题目"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://source.fomal.cc/img/default_cover_12.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-08-22</div><div class="title">军哥面试题-12.LeetCode面试常考题目</div></div></a></div><div><a href="/2022/08/11/2%20%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E8%BD%AF%E6%8A%80%E8%83%BD/" title="军哥面试题--2.程序员面试软技能"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://source.fomal.cc/img/default_cover_2.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-08-11</div><div class="title">军哥面试题--2.程序员面试软技能</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://z1.ax1x.com/2023/09/24/pPToDgg.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://github.githubassets.com/images/icons/emoji/unicode/270d.png" ait="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">前端、Python、开发</b>相关的问题和看法，还有<b style="color:#fff">文章翻译</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来看我的博客鸭~</div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(null) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8"><span class="toc-text">一、浏览器安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF-XSS-%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-text">1.  什么是 XSS 攻击？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%A6%82%E5%BF%B5"><span class="toc-text">（1）概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B"><span class="toc-text">（2）攻击类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E9%98%B2%E5%BE%A1-XSS-%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-text">2. 如何防御 XSS 攻击？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AF-CSRF-%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-text">3. 什么是 CSRF 攻击？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%A6%82%E5%BF%B5-1"><span class="toc-text">（1）概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B-1"><span class="toc-text">（2）攻击类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A6%82%E4%BD%95%E9%98%B2%E5%BE%A1-CSRF-%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-text">4. 如何防御 CSRF 攻击？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-text">5. 什么是中间人攻击？如何防范中间人攻击？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%AF%E8%83%BD%E5%BC%95%E8%B5%B7%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">6. 有哪些可能引起前端安全的问题**?**</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%BD%91%E7%BB%9C%E5%8A%AB%E6%8C%81%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%8C%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%EF%BC%9F"><span class="toc-text">7. 网络劫持有哪几种，如何防范？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-text">二、进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">1. 进程与线程的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2. 进程和线程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">3. 浏览器渲染进程的线程有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%BF%9B%E7%A8%8B%E4%B9%8B%E5%89%8D%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-text">4. 进程之前的通信方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">5. 僵尸进程和孤儿进程是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9F-%E5%A6%82%E6%9E%9C%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">6. 死锁产生的原因？ 如果解决死锁的问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E5%A4%9A%E4%B8%AA%E6%A0%87%E7%AD%BE%E9%A1%B5%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-text">7. 如何实现浏览器内多个标签页之间的通信?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%AF%B9Service-Worker%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">8. 对Service Worker的理解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98"><span class="toc-text">三、浏览器缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AF%B9%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">1. 对浏览器的缓存机制的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B5%84%E6%BA%90%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%8D%E7%BD%AE%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">2. 浏览器资源缓存的位置有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E5%92%8C%E5%BC%BA%E7%BC%93%E5%AD%98%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">3. 协商缓存和强缓存的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%BC%BA%E7%BC%93%E5%AD%98"><span class="toc-text">（1）强缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-text">（2）协商缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-text">4. 为什么需要浏览器缓存？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%82%B9%E5%87%BB%E5%88%B7%E6%96%B0%E6%8C%89%E9%92%AE%E6%88%96%E8%80%85%E6%8C%89-F5%E3%80%81%E6%8C%89-Ctrl-F5-%EF%BC%88%E5%BC%BA%E5%88%B6%E5%88%B7%E6%96%B0%EF%BC%89%E3%80%81%E5%9C%B0%E5%9D%80%E6%A0%8F%E5%9B%9E%E8%BD%A6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">5. 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%84%E6%88%90"><span class="toc-text">四、浏览器组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AF%B9%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">1. 对浏览器的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AF%B9%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">2. 对浏览器内核的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E6%AF%94%E8%BE%83"><span class="toc-text">3. 常见的浏览器内核比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B8%B8%E8%A7%81%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%80%E7%94%A8%E5%86%85%E6%A0%B8"><span class="toc-text">4. 常见浏览器所用内核</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-text">5. 浏览器的主要组成部分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86"><span class="toc-text">五、浏览器渲染原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B"><span class="toc-text">1. 浏览器的渲染过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96"><span class="toc-text">2. 浏览器渲染优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0-JS-%E6%96%87%E4%BB%B6%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-text">3. 渲染过程中遇到 JS 文件如何处理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%87%E6%A1%A3%E7%9A%84%E9%A2%84%E8%A7%A3%E6%9E%90%EF%BC%9F"><span class="toc-text">4. 什么是文档的预解析？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-CSS-%E5%A6%82%E4%BD%95%E9%98%BB%E5%A1%9E%E6%96%87%E6%A1%A3%E8%A7%A3%E6%9E%90%EF%BC%9F"><span class="toc-text">5. CSS 如何阻塞文档解析？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E5%85%B3%E9%94%AE%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84%EF%BC%9F"><span class="toc-text">6. 如何优化关键渲染路径？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BC%9A%E9%98%BB%E5%A1%9E%E6%B8%B2%E6%9F%93%EF%BC%9F"><span class="toc-text">7. 什么情况会阻塞渲染？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8"><span class="toc-text">六、浏览器本地存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">1. 浏览器本地存储方式及使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89Cookie"><span class="toc-text">（1）Cookie</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89LocalStorage"><span class="toc-text">（2）LocalStorage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89SessionStorage"><span class="toc-text">（3）SessionStorage</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Cookie%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AD%97%E6%AE%B5%EF%BC%8C%E4%BD%9C%E7%94%A8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">2. Cookie有哪些字段，作用分别是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Cookie%E3%80%81LocalStorage%E3%80%81SessionStorage%E5%8C%BA%E5%88%AB"><span class="toc-text">3. Cookie、LocalStorage、SessionStorage区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%89%8D%E7%AB%AF%E5%82%A8%E5%AD%98%E7%9A%84%E2%BD%85%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">4. 前端储存的⽅式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-IndexedDB%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-text">5. IndexedDB有哪些特点？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="toc-text">七、浏览器同源策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="toc-text">1. 什么是同源策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E8%B6%8A%E9%97%AE%E9%A2%98"><span class="toc-text">2. 如何解决跨越问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89CORS"><span class="toc-text">（1）CORS</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%8F%E5%B0%91OPTIONS%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0%EF%BC%9A"><span class="toc-text">减少OPTIONS请求次数：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CORS%E4%B8%ADCookie%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">CORS中Cookie相关问题：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89JSONP"><span class="toc-text">（2）JSONP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89postMessage-%E8%B7%A8%E5%9F%9F"><span class="toc-text">（3）postMessage 跨域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89nginx%E4%BB%A3%E7%90%86%E8%B7%A8%E5%9F%9F"><span class="toc-text">（4）nginx代理跨域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89nodejs-%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%BB%A3%E7%90%86%E8%B7%A8%E5%9F%9F"><span class="toc-text">（5）nodejs 中间件代理跨域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%886%EF%BC%89document-domain-iframe%E8%B7%A8%E5%9F%9F"><span class="toc-text">（6）document.domain + iframe跨域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%887%EF%BC%89location-hash-iframe%E8%B7%A8%E5%9F%9F"><span class="toc-text">（7）location.hash + iframe跨域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%888%EF%BC%89window-name-iframe%E8%B7%A8%E5%9F%9F"><span class="toc-text">（8）window.name + iframe跨域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%889%EF%BC%89WebSocket%E5%8D%8F%E8%AE%AE%E8%B7%A8%E5%9F%9F"><span class="toc-text">（9）WebSocket协议跨域</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">3. 正向代理和反向代理的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Nginx%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">4. Nginx的概念及其工作原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">八、浏览器事件机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BA%8B%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-text">1. 事件是什么？事件模型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="toc-text">2. 如何阻止事件冒泡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AF%B9%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">3. 对事件委托的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">（1）事件委托的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">（2）事件委托的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-text">（3）局限性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">4. 事件委托的使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">5. 同步和异步的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%AF%B9%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">6. 对事件循环的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1%E5%88%86%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">7. 宏任务和微任务分别有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%A7%E8%A1%8C%E6%A0%88"><span class="toc-text">8. 什么是执行栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Node-%E4%B8%AD%E7%9A%84-Event-Loop-%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9Fprocess-nextTick-%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-text">9. Node 中的 Event Loop 和浏览器中的有什么区别？process.nextTick 执行顺序？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="toc-text">10. 事件触发的过程是怎样的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">九、浏览器垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-V8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="toc-text">1. V8的垃圾回收机制是怎样的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BC%9A%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F"><span class="toc-text">2. 哪些操作会造成内存泄漏？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/01/09/%E3%80%90Typora%E3%80%91Typora%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/" title="【Typora】Typora破解教程"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://source.fomal.cc/img/default_cover_7.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Typora】Typora破解教程"/></a><div class="content"><a class="title" href="/2024/01/09/%E3%80%90Typora%E3%80%91Typora%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/" title="【Typora】Typora破解教程">【Typora】Typora破解教程</a><time datetime="2024-01-08T16:00:00.000Z" title="发表于 2024-01-09 00:00:00">2024-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/13/%E3%80%90JavaScript%E3%80%91JavaScript%20%E5%86%85%E7%9A%84%20this%20%E6%8C%87%E5%90%91/" title="前端【JavaScript】JavaScript 内的 this 指向"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://source.fomal.cc/img/default_cover_10.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端【JavaScript】JavaScript 内的 this 指向"/></a><div class="content"><a class="title" href="/2023/11/13/%E3%80%90JavaScript%E3%80%91JavaScript%20%E5%86%85%E7%9A%84%20this%20%E6%8C%87%E5%90%91/" title="前端【JavaScript】JavaScript 内的 this 指向">前端【JavaScript】JavaScript 内的 this 指向</a><time datetime="2023-11-13T13:31:28.000Z" title="发表于 2023-11-13 21:31:28">2023-11-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/13/%E3%80%90Vue%E3%80%91%E5%88%86%E4%BA%AB%E4%B8%8B%E5%A6%82%E4%BD%95%E5%9C%A8Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80/" title="【Vue】分享下如何在Vue项目中进行网页布局"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://source.fomal.cc/img/default_cover_15.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Vue】分享下如何在Vue项目中进行网页布局"/></a><div class="content"><a class="title" href="/2023/11/13/%E3%80%90Vue%E3%80%91%E5%88%86%E4%BA%AB%E4%B8%8B%E5%A6%82%E4%BD%95%E5%9C%A8Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80/" title="【Vue】分享下如何在Vue项目中进行网页布局">【Vue】分享下如何在Vue项目中进行网页布局</a><time datetime="2023-11-13T13:31:28.000Z" title="发表于 2023-11-13 21:31:28">2023-11-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/12/%E3%80%90Css%E3%80%91CSS%E3%80%81LESS%E3%80%81SASS%E3%80%81SCSS%20%E7%9A%84%E5%8C%BA%E5%88%AB/" title="【Css】CSS、LESS、SASS、SCSS 的区别"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://source.fomal.cc/img/default_cover_6.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Css】CSS、LESS、SASS、SCSS 的区别"/></a><div class="content"><a class="title" href="/2023/11/12/%E3%80%90Css%E3%80%91CSS%E3%80%81LESS%E3%80%81SASS%E3%80%81SCSS%20%E7%9A%84%E5%8C%BA%E5%88%AB/" title="【Css】CSS、LESS、SASS、SCSS 的区别">【Css】CSS、LESS、SASS、SCSS 的区别</a><time datetime="2023-11-11T16:00:00.000Z" title="发表于 2023-11-12 00:00:00">2023-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/09/%E3%80%90Python%E3%80%9157box%E8%87%AA%E5%8A%A8%E4%BB%BB%E5%8A%A1%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/" title="【Python】57Box自动任务脚本学习"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://source.fomal.cc/img/default_cover_6.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Python】57Box自动任务脚本学习"/></a><div class="content"><a class="title" href="/2023/11/09/%E3%80%90Python%E3%80%9157box%E8%87%AA%E5%8A%A8%E4%BB%BB%E5%8A%A1%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/" title="【Python】57Box自动任务脚本学习">【Python】57Box自动任务脚本学习</a><time datetime="2023-11-08T16:00:00.000Z" title="发表于 2023-11-09 00:00:00">2023-11-09</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="Tiamo" target="_blank">Tiamo</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">13</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://blog.xiaoadai.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Chat-GPT/" style="font-size: 0.88rem;">Chat GPT<sup>1</sup></a><a href="/tags/Linux%E3%80%90Vi%E3%80%91/" style="font-size: 0.88rem;">Linux【Vi】<sup>1</sup></a><a href="/tags/python%E3%80%90%E7%88%AC%E8%99%AB%E3%80%91/" style="font-size: 0.88rem;">python【爬虫】<sup>2</sup></a><a href="/tags/%E3%80%90JavaScript%E3%80%91/" style="font-size: 0.88rem;">【JavaScript】<sup>1</sup></a><a href="/tags/%E3%80%90Python%E3%80%91/" style="font-size: 0.88rem;">【Python】<sup>1</sup></a><a href="/tags/%E3%80%90Typora%E3%80%91/" style="font-size: 0.88rem;">【Typora】<sup>1</sup></a><a href="/tags/%E3%80%90%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E3%80%91/" style="font-size: 0.88rem;">【青龙面板】<sup>1</sup></a><a href="/tags/%E5%86%9B%E5%93%A5%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 0.88rem;">军哥面试题<sup>14</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF%E3%80%90CSS%E3%80%91/" style="font-size: 0.88rem;">前端【CSS】<sup>2</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF%E3%80%90JavaScript%E3%80%91/" style="font-size: 0.88rem;">前端【JavaScript】<sup>6</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF%E3%80%90JaveScript%E3%80%91/" style="font-size: 0.88rem;">前端【JaveScript】<sup>1</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF%E3%80%90Layui%E3%80%91/" style="font-size: 0.88rem;">前端【Layui】<sup>2</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF%E3%80%90Vue%E3%80%91/" style="font-size: 0.88rem;">前端【Vue】<sup>4</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 0.88rem;">博客<sup>1</sup></a><a href="/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/" style="font-size: 0.88rem;">学习日常<sup>4</sup></a><a href="/tags/%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">模拟面试<sup>1</sup></a><a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 0.88rem;">笔记<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://comment.xiaoadai.com/',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.18/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://comment.xiaoadai.com/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://comment.xiaoadai.com/',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.18/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>